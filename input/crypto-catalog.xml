<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../transforms/cat2html.xsl"?>


<SFRCatalog name="CCDB Class FCS"
    xmlns="https://niap-ccevs.org/cc/v1"
    xmlns:sec="https://niap-ccevs.org/cc/v1/section"
    xmlns:h="http://www.w3.org/1999/xhtml"
    >

	<PPReference>
		<PPTitle>Functional Requirements for Cryptography - Class FCS (NIAP XML Version)</CatTitle>
        <PPVersion>1.0</CatVersion>
        <PPAuthor>CCDB Crypto Working Group/NIAP</CatAuthor>
        <PPPubDate>2025-01-31</CatPubDate>
	</PPReference>

	<RevisionHistory>
		<entry>
			<version>1.0</version>
			<date>2025-01-31</date>
			<subject>Initial publication</subject>
		</entry>
	</RevisionHistory>	

	<pp-preferences>
<!--		<display-audit-with-sfrs/>  
		<audit-events-in-sfrs/>    -->
           <display-comp-rel-in-sfrs/>
	</pp-preferences>
	
	
	<!-- 1.0 Security Functional Requirements -->
	<section title="Security Functional Requirements" id="catsec-sfrs">
		
		<section title="Class FCS: Cryptographic Support" id="catsec-fcs">

			<ext-comp-class class="FCS">
				<description>
					The TSF may employ cryptographic functionality to help satisfy several high-level security
					objectives. These include, but are not limited to: identification and authentication,
					nonrepudiation, trusted path, trusted channel, and data separation. This class is used when the
					TOE implements cryptographic functions, the implementation of which can be in hardware,
					firmware and/or software. <h:p/>
					The FCS: Cryptographic support class is composed of five families. <h:ul>
						<h:li>FCS_CKM: Cryptographic support</h:li>
						<h:li>FCS_COP: Cryptographic operation</h:li>
						<h:li>FCS_OTV: One-time value generation</h:li>
						<h:li>FCS_RBG: Random bit generation</h:li>
						<h:li>FCS_RNG: Random number generation</h:li>
					</h:ul>
				</description>
			</ext-comp-class>			

			<section title="Cryptographic Key Management (FCS_CKM)" id="catsec-fcs-ckm">
			
				<ext-comp-def fam-id="FCS_CKM_EXT" title="Cryptographic Key Management (extended)(FCS_CKM_EXT)">
					<fam-behavior>
						This family defines requirements for management of cryptographic keys that are not addressed 
						by FCS_CKM in CC Part 2.<h:p/>
						Cryptographic keys must be managed throughout their life cycle. This family is intended to
						support that lifecycle and consequently defines requirements for the following activities:<h:ul>
						<h:li>cryptographic key generation;</h:li>
						<h:li>cryptographic key distribution;</h:li>
						<h:li>cryptographic key access;</h:li>
						<h:li>cryptographic key derivation;</h:li>
						<h:li>timing and event of cryptographic key destruction;</h:li>
						<h:li>cryptographic key agreement;</h:li>
						<h:li>password-based key derivation.</h:li></h:ul>
						<h:p/>
						This family should be included whenever there are functional requirements for the
						management of cryptographic keys. 
					</fam-behavior>					
				</ext-comp-def>
			
				<section title="Catalog Guidance Notes for Family FCS_CKM" id="catsec-cgn-fam-fcs-ckm">
					SFRs under FCS_CKM pertain to cryptographic keys. This includes key management activities
					that occur during the typical lifecycle of a key. This section includes key generation, key
					derivation, key distribution, key agreement, key access, and key destruction. <h:p/>
				
					<h:b>Key Generation and Key Derivation</h:b><h:p/>
						This catalog distinguishes key generation from key derivation. <h:i>Key generation</h:i> refers to those
						instances in which a new key is created from a source of entropy. Those instances in which a
						reproducible process derives a key from other material that are themselves reasonable sources of
						entropy are referred to as <h:i>key derivation</h:i>. Ideally, the sources of entropy in a key derivation
						process are unknown. However, <h:i>password-based key derivation</h:i>, which uses low-entropy
						sources of derivation material that may be easily guessable, has been used and supported for
						decades. This catalog recommends FCS_CKM.5 Cryptographic Key Derivation for instances in
						which the sources for derivation are reasonably expected to be unknown and unguessable and
						introduces FCS_CKM_EXT.8 Password-Based Key Derivation to add constraints, work, or
						more entropy for the instances in which one or more components of the derivation material may
						contain limited entropy. 
					<h:p/>

					<h:b>Key Establishment, Key Distribution/Transport, and Key Agreement</h:b><h:p/>
						NIST SP 800-56A Revision 3 explains that “[a] key-establishment scheme can be characterized
						as either a key-agreement scheme or a key-transport scheme.” <h:i>Key agreement</h:i> schemes refer to
						cases in which two or more parties want to establish a single key between them, and all parties
						contribute to the entropy of the agreed-upon key. <h:i>Key transport</h:i> schemes refer to cases in which
						one party has a key to share with another party. In this case, only one party has contributed to
						the entropy of the key. Since FCS_CKM.2 supports key distribution, this catalog recommends
						using FCS_CKM.2 Cryptographic Key Distribution to specify key transport schemes and
						introduces FCS_CKM_EXT.7 Cryptographic Key Agreement to cover key agreement schemes. <h:p/>
						NIST SP 800-56A Revision 3, Section 6, presents several key agreement schemes. Rather than
						list all of them here, this document presents all the primitives necessary to build these schemes.
						Namely, find Finite Field Cryptography Diffie-Hellman (FFC DH) and Elliptic Curve DiffieHellman (ECDH) in FCS_CKM_EXT.7, key derivation functions in FCS_CKM.5, and pseudorandom functions (PRFs) in FCS_COP.1/CMAC, FCS_COP.1/Hash, FCS_COP.1/KeyedHash,
						and FCS_COP.1/SKC. For integrated encryption schemes such as the Elliptic Curve Integrated
						Encryption Scheme (ECIES), consult the ECIES standards such as those from ISO, IEEE, ANSI,
						and SECG. Each has slight variations, but the key agreement primitives can be found in
						FCS_CKM_EXT.7 and the KDF primitives in FCS_CKM.5. 
					<h:p/>

					<h:b>Key Access</h:b><h:p/>
						Cryptographic key access applies primarily to the storage of keys for future use and retrieval of
						keys for immediate use by the TOE. The end goal here is to protect the confidentiality and
						authenticity of the keys while in storage. <h:p/>
						<h:b>Cryptographic key archival, backup, and escrow</h:b> – TOEs often perform cryptographic key
						archival to manage limited memory resources inside their own security boundaries. Often the
						TOE encrypts the cryptographic keys prior to saving them to storage that is close by, on the same
						device as the TOE and can be accessed quickly. TOEs may perform cryptographic key backups
						into storage that is meant for longer term keeping. Backup storage is often not on the same
						device as the TOE and may be physically hundreds of miles away. In practice, the TOE encrypts
						the keys using an approved method before sending them to backup storage. TOEs may perform
						cryptographic key escrow in which it entrusts a third party with access to the private or secret
						keys. In practice, the TOE protects the keys using a cryptographic key access method agreed
						upon with the escrow agent before sending them. <h:p/>
						<h:b>Cryptographic key recovery</h:b> – This refers to the retrieval of cryptographic keys from either
						archival, backup, or escrow locations. In each case, the TOE uses the agreed upon cryptographic
						key access method. 
					<h:p/>
				</section>
				

				<section title="FCS_CKM.1/AKG Cryptographic Key Generation - Asymmetric Keys" id="catsec-fcs-ckm-1-akg">
					
					<!-- <note role="ppdev">Blahblah</note>  -->
					<h:b>Catalog Guidance Notes</h:b><h:p/>
						FIPS PUB 186-5 does not approve Finite Field Cryptography (FFC) DSA for digital signature
						generation but allows DSA for digital signature verification for legacy purposes. Since it is not
						approved for digital signature, then methods for key generation are restricted to key agreement.<h:p/>
						If the Requirements Document does not include “DH” in FCS_CKM_EXT.7, then it need not
						include “FCC-ERB” or “FCC-RS” here.<h:p/>
						If the Requirements Document includes “ECDH” or “ECDH-Ed” in FCS_CKM_EXT.7, then
						“ECC–ERB” or “ECC–RS” must be included here.<h:p/>
						If the Requirements Document includes “ECDSA” or “EC-KCDSA” in FCS_COP.1/SigGen,
						then “ECC–ERB” or “ECC–RS” must be included here.<h:p/>
						If the Requirements Document includes “EdDSA” in FCS_COP.1/SigGen, then “EdDSA” must
						be included here.<h:p/>
						If the Requirements Document includes “LMS”, “HSS”, “XMSS”, or “XMSSMT” in
						FCS__COP.1/SigGen, then “LMS”, “HSS”, “XMSS”, or “XMSSMT” must be included here,
						respectively. 

					<f-component id="sfr-fcs-ckm-1-akg" cc-id="fcs_ckm.1" iteration="AKG" 
						name="Cryptographic Key Generation - Asymmetric Key">

						<comp-rel>
							<hierarchical-to/>
							<dependencies-to>
								<or-dep>
									<comp-ref>FCS_CKM.2 Cryptographic key distribution</comp-ref> 
									<comp-ref>FCS_CKM.5 Cryptographic key derivation</comp-ref> 
									<comp-ref>FCS_COP.1 Cryptographic operation</comp-ref>
								</or-dep>
								<or-dep>
									<comp-ref>FCS_RBG.1 Random bit generation</comp-ref>
									<comp-ref>FCS_RNG.1 Generation of random numbers</comp-ref>
								</or-dep>
								<comp-ref>FCS_CKM.6 Timing and event of cryptographic key destruction</comp-ref>
							</dependencies-to>
						</comp-rel>

			<f-element id="fcs-ckm-1e1-akg">
				<title>
					The TSF shall generate <h:b>asymmetric</h:b> cryptographic keys in accordance with
					a specified cryptographic key generation algorithm<selectables>
						<tabularize id="fcs-ckm-1-ak-sels" title="Recommended choices for FCS_CKM.1/AKG">
							<textcol>Identifier</textcol>
							<selectcol>Cryptographic key generation algorithm</selectcol>
							<reqtext>and specified cryptographic <h:b>algorithm parameters</h:b> <h:s>key sizes</h:s></reqtext>
							<selectcol>Cryptographic algorithm parameters</selectcol>
							<reqtext>that meet the following: </reqtext>
							<selectcol>List of standards</selectcol>
							<reqtext><h:p/><h:p/>The following table provides the recommended choices for
										completion of the selection operations of FCS_CKM.1/AKG.</reqtext>
						</tabularize>

						<!-- RSA -->
						<selectable id="sel-fcs-ckm-ak-rsa">
							<col>RSA</col>
							<col>RSA</col>
							<col>Modulus of size <selectables>
								<selectable id="sel-exp-ak-rsa-2048">2048</selectable>
								<selectable id="sel-exp-ak-rsa-3072">3072</selectable>
								<selectable id="sel-exp-ak-rsa-4096">4096</selectable></selectables> bits
							</col>
							<col>NIST FIPS PUB 186-5 (Section A.1.1)</col>
						</selectable>

						<!-- ECC-ERB - Extra Random Bits -->
						<selectable id="sel-fcs-ckm-ak-ecdsa-erb">
							<col>ECC-ERB</col>
							<col>ECC-ERB - Extra Random Bits</col>
							<col>Elliptic Curve <selectables>
								<selectable id="sel-exp-ak-edcsa-erb-P256">P-256</selectable>
								<selectable id="sel-exp-ak-ecdsa-erb-brainpoolP256r1">brainpoolP256r1</selectable>
								<selectable id="sel-exp-ak-edcsa-erb-P384">P-384</selectable>
								<selectable id="sel-exp-ak-edcsa-erb-brainpoolP384r1">brainpoolP384r1</selectable>
								<selectable id="sel-exp-ak-edcsa-erb-P521">P-521</selectable>
								<selectable id="sel-exp-ak-edcsa-erb-brainpoolP512r1">brainpoolP512r1</selectable></selectables>
							</col>
							<col>
								FIPS PUB 186-5 (Section A.2.1)<h:p/>
								<selectables>
								<selectable>NIST SP 800-186 (Section 3) [NIST Curves]</selectable>
								<selectable>RFC 5639 (Section 3) [Brainpool curves]</selectable></selectables>
							</col>
						</selectable>

						<!-- ECC-RS - Rejection Sampling -->
						<selectable id="sel-fcs-ckm-ak-ecdsa-rs">
							<col>ECC-RS</col>
							<col>ECC-RS - Rejection Sampling</col>
							<col>Elliptic Curve <selectables>
								<selectable id="sel-exp-ak-edcsa-rs-P256">P-256</selectable>
								<selectable id="sel-exp-ak-ecdsa-rs-brainpoolP256r1">brainpoolP256r1</selectable>
								<selectable id="sel-exp-ak-edcsa-rs-P384">P-384</selectable>
								<selectable id="sel-exp-ak-edcsa-rs-brainpoolP384r1">brainpoolP384r1</selectable>
								<selectable id="sel-exp-ak-edcsa-rs-P521">P-521</selectable>
								<selectable id="sel-exp-ak-edcsa-rs-brainpoolP512r1">brainpoolP512r1</selectable></selectables>
							</col>
							<col>
								FIPS PUB 186-5 (Section A.2.2)<h:p/>
								<selectables>
								<selectable>NIST SP 800-186 (Section 3) [NIST Curves]</selectable>
								<selectable>RFC 5639 (Section 3) [Brainpool curves]</selectable></selectables>
							</col>
						</selectable>

						<!-- FFC-ERB - Extra Random Bits -->
						<selectable id="sel-fcs-ckm-ak-ffc-erb">
							<col>FFC-ERB</col>
							<col>FFC-ERB - Extra Random Bits</col>
							<col>Static domain parameters approved for <selectables>
								<selectable>IKE Groups <selectables>
									<selectable id="sel-dp-ak-ffc-erb-modp2048">MODP-2048</selectable>
									<selectable id="sel-dp-ak-ffc-erb-modp3072">MODP-3072</selectable>
									<selectable id="sel-dp-ak-ffc-erb-modp4096">MODP-4096</selectable>
									<selectable id="sel-dp-ak-ffc-erb-modp6144">MODP-6144</selectable>
									<selectable id="sel-dp-ak-ffc-erb-modp8192">MODP-8192</selectable>
								</selectables></selectable>
								<selectable>TLS Groups <selectables>
									<selectable id="sel-dp-ak-ffc-erb-ffdhe2048">ffdhe2048</selectable>
									<selectable id="sel-dp-ak-ffc-erb-ffdhe3072">ffdhe3072</selectable>
									<selectable id="sel-dp-ak-ffc-erb-ffdhe4096">ffdhe4096</selectable>
									<selectable id="sel-dp-ak-ffc-erb-ffdhe6144">ffdhe6144</selectable>
									<selectable id="sel-dp-ak-ffc-erb-ffdhe8192">ffdhe8192</selectable>
								</selectables></selectable></selectables>
							</col>
							<col>
								NIST SP 800-56A Revision 3 (Section 5.6.1.1.3) [key pair generation]<h:p/>
								<selectables>
								<selectable>RFC 3526 [IKE groups]</selectable>
								<selectable>RFC 7919 [TLS groups]</selectable></selectables>
							</col>
						</selectable>

						<!-- FFC-RS - Extra Random Bits -->
						<selectable id="sel-fcs-ckm-ak-ffc-rs">
							<col>FFC-RS</col>
							<col>FFC-RS - Extra Random Bits</col>
							<col>Static domain parameters approved for <selectables>
								<selectable>IKE Groups <selectables>
									<selectable id="sel-dp-ak-ffc-rs-modp2048">MODP-2048</selectable>
									<selectable id="sel-dp-ak-ffc-rs-modp3072">MODP-3072</selectable>
									<selectable id="sel-dp-ak-ffc-rs-modp4096">MODP-4096</selectable>
									<selectable id="sel-dp-ak-ffc-rs-modp6144">MODP-6144</selectable>
									<selectable id="sel-dp-ak-ffc-rs-modp8192">MODP-8192</selectable>
								</selectables></selectable>
								<selectable>TLS Groups <selectables>
									<selectable id="sel-dp-ak-ffc-rs-ffdhe2048">ffdhe2048</selectable>
									<selectable id="sel-dp-ak-ffc-rs-ffdhe3072">ffdhe3072</selectable>
									<selectable id="sel-dp-ak-ffc-rs-ffdhe4096">ffdhe4096</selectable>
									<selectable id="sel-dp-ak-ffc-rs-ffdhe6144">ffdhe6144</selectable>
									<selectable id="sel-dp-ak-ffc-rs-ffdhe8192">ffdhe8192</selectable>
								</selectables></selectable></selectables>
							</col>
							<col>
								NIST SP 800-56A Revision 3 (Section 5.6.1.1.3) [key pair generation]<h:p/>
								<selectables>
								<selectable>RFC 3526 [IKE groups]</selectable>
								<selectable>RFC 7919 [TLS groups]</selectable></selectables>
							</col>
						</selectable>

						<!-- EdDSA -->
						<selectable id="sel-fcs-ckm-ak-eddsa">
							<col>EdDSA</col>
							<col>EdDSA</col>
							<col>Domain parameters approved for elliptic curves 
								<selectables>
								<selectable>Edwards25519</selectable>
								<selectable>Edwards448</selectable></selectables>
							</col>
							<col>
								NIST FIPS PUB 186-5 (Section 6.2.1) [key-pair generation]<h:p/>
								NIST SP 800-186 (Section 3.2.3) [Edwards Curves]
							</col>
						</selectable>
									
						<!-- KCDSA -->
						<selectable id="sel-fcs-ckm-ak-kcdsa">
							<col>KCDSA</col>
							<col>KCDSA</col>
							<col>Domain parameters generation with (L, N) = <selectables>
								<selectable>(2048, 224)</selectable>
								<selectable>(2048, 256)</selectable>
								<selectable>(3072, 256)</selectable>
								</selectables>bits
							</col>
							<col>ISO/IEC 14888-3:2018 (Subclause 6.3) [KCDSA]</col>
						</selectable>
									
						<!-- EC-KCDSA -->
						<selectable id="sel-fcs-ckm-ak-eckcdsa">
							<col>EC-KCDSA</col>
							<col>EC-KCDSA</col>
							<col>Elliptic Curves <selectables>
								<selectable>P-224</selectable>
								<selectable>B-233</selectable>
								<selectable>K-233</selectable>
								<selectable>P-256</selectable>
								<selectable>B-283</selectable>
								<selectable>K-283</selectable></selectables>
							</col>
							<col>ISO/IEC 14888-3:2018 (Subclause 6.7) [EC-KCDSA]<h:p/>
								 NIST SP 800-186 (Section 3) [NIST Curves]
							</col>
						</selectable>
						
						<!-- LMS -->
						<selectable id="sel-fcs-ckm-ak-lms">
							<col>LMS</col>
							<col>LMS</col>
							<col>Private key size = <selectables>
								<selectable>192 bits with <selectables>
									<selectable>SHA-256/192</selectable>
									<selectable>SHAKE256/192</selectable>
								</selectables></selectable>
								<selectable>256 bits with <selectables>
									<selectable>SHA-256</selectable>
									<selectable>SHAKE256</selectable>
								</selectables></selectable>
								</selectables><h:p/>
								Winternitz parameter = <selectables>
									<selectable>1</selectable>
									<selectable>2</selectable>
									<selectable>4</selectable>
									<selectable>8</selectable></selectables><h:p/>
								Tree height = <selectables>
									<selectable>5</selectable>
									<selectable>10</selectable>
									<selectable>15</selectable>
									<selectable>20</selectable>
									<selectable>25</selectable></selectables>
							</col>
							<col>RFC 8554 [LMS]<h:p/>
								 NIST SP 800-208 [parameters]
							</col>
						</selectable>
						
						<!-- HSS -->
						<selectable id="sel-fcs-ckm-ak-hss">
							<col>HSS</col>
							<col>HSS</col>
							<col>Private key size = <selectables>
								<selectable>192 bits with <selectables>
									<selectable>SHA-256/192</selectable>
									<selectable>SHAKE256/192</selectable>
								</selectables></selectable>
								<selectable>256 bits with <selectables>
									<selectable>SHA-256</selectable>
									<selectable>SHAKE256</selectable>
								</selectables></selectable>
								</selectables><h:p/>
								Winternitz parameter = <selectables>
									<selectable>1</selectable>
									<selectable>2</selectable>
									<selectable>4</selectable>
									<selectable>8</selectable></selectables><h:p/>
								Tree height = <selectables>
									<selectable>5</selectable>
									<selectable>10</selectable>
									<selectable>15</selectable>
									<selectable>20</selectable>
									<selectable>25</selectable></selectables><h:p/>
								Number of levels = <selectables>
									<selectable>1</selectable>
									<selectable>2</selectable>
									<selectable>3</selectable>
									<selectable>4</selectable>
									<selectable>5</selectable>
									<selectable>6</selectable>
									<selectable>7</selectable>
									<selectable>8</selectable></selectables>
							</col>
							<col>RFC 8554 [HSS]<h:p/>
								 NIST SP 800-208 [parameters]
							</col>
						</selectable>
						
						<!-- XMSS -->
						<selectable id="sel-fcs-ckm-ak-xmss">
							<col>XMSS</col>
							<col>XMSS</col>
							<col>Private key size = <selectables>
								<selectable>192 bits with <selectables>
									<selectable>SHA-256/192</selectable>
									<selectable>SHAKE256/192</selectable>
								</selectables></selectable>
								<selectable>256 bits with <selectables>
									<selectable>SHA-256</selectable>
									<selectable>SHAKE256</selectable>
								</selectables></selectable>
								</selectables><h:p/>
								Tree height = <selectables>
									<selectable>10</selectable>
									<selectable>16</selectable>
									<selectable>20</selectable>
								</selectables>
							</col>
							<col>RFC 8391 [XMSS]<h:p/>
								 NIST SP 800-208 [parameters]
							</col>
						</selectable>

						<!-- XMSS(TM) -->
						<selectable id="sel-fcs-ckm-ak-xmssmt">
							<col>XMSS(MT)</col>
							<col>XMSS(MT)</col>
							<col>Private key size = <selectables>
								<selectable>192 bits with <selectables>
									<selectable>SHA-256/192</selectable>
									<selectable>SHAKE256/192</selectable>
								</selectables></selectable>
								<selectable>256 bits with <selectables>
									<selectable>SHA-256</selectable>
									<selectable>SHAKE256</selectable>
								</selectables></selectable>
								</selectables><h:p/>
								(Total Tree height, Number of Levels) = <selectables>
									<selectable>(20, 2)</selectable>
									<selectable>(20, 4)</selectable>
									<selectable>(40, 2)</selectable>
									<selectable>(40, 4)</selectable>
									<selectable>(40, 8)</selectable>
									<selectable>(60, 3)</selectable>
									<selectable>(60, 6)</selectable>
									<selectable>(60, 12)</selectable>
								</selectables>
							</col>
							<col>RFC 8391 [XMSS(MT)]<h:p/>
								 NIST SP 800-208 [parameters]
							</col>
						</selectable>

						<!-- ML-KEM Key Generation -->
						<selectable id="sel-fcs-ckm-ak-mlkem">
							<col>ML-KEM</col>
							<col>ML-KEM KeyGen</col>
							<col>Parameter set = <selectables>
								<selectable>ML-KEM-512</selectable>
								<selectable>ML-KEM-768</selectable>
								<selectable>ML-KEM-1024</selectable>
								</selectables>
							</col>
							<col>NIST FIPS 203 (Section 7.1)</col>
						</selectable>

						<!-- ML-DSA Key Generation -->
						<selectable id="sel-fcs-ckm-ak-mldsa">
							<col>ML-DSA</col>
							<col>ML-DSA KeyGen</col>
							<col>Parameter set = <selectables>
								<selectable>ML-DSA-44</selectable>
								<selectable>ML-DSA-65</selectable>
								<selectable>ML-DSA-87</selectable>
								</selectables>
							</col>
							<col>NIST FIPS 204 (Section 5.1)</col>
						</selectable>
					</selectables>
				</title>
				<note role="application">
					This SFR must be included in the ST if asymmetric key generation is a service provided by 
					the TOE to tenant software, or if it is used by the TOE itself to support or implement PP-specified
					security functionality.<h:p/> 
					Also, this SFR must be included in the ST if FCS_IPSEC_EXT.1 is claimed, or if 
					"<h:i>causing the TOE to generate [asymmetric] keys/secrets</h:i>" is selected in FCS_STG_EXT.1.2.<h:p/>
					If this SFR is included in the ST, then FCS_CKM.6 and FCS_RBG.1 must also be claimed.<h:p/>
					
					<comment>From catalog</comment>For RSA the choice of the modulus implies the resulting key sizes of the public and 
					private keys generated using the specified standard methods.<h:p/>

					For Finite Field Cryptography (FFC) DSA, ST authors should consult schemes for 
					guidelines on use.  FIPS PUB 186-5 does not approve DSA for digital signature 
					generation but allows DSA for digital signature verification for legacy purposes.
					“FFC-ERB” or  “FFC–RS” may be claimed only for generating private and public keys
					when “DH” is claimed in FCS_CKM_EXT.7.<h:p/>

					When generating ECC keys pairs for key agreement and if “ECDH” or “ECDH-Ed” is 
					claimed in FCS_CKM_EXT.7, then “ECC–ERB” or “ECC–RS” must be claimed.  The sizes 
					of the private key, which is a scalar, and the public key, which is a point on 
					the elliptic curve, are determined by the choice of the curve.<h:p/>

					When generating ECC key pairs for digital signature generation and if “ECDSA” or 
					“EC-KCDSA” are claimed in FCS_COP.1/SigGen, then “ECC–ERB” or “ECC–RS” must be 
					claimed.  The sizes of the private key, which is a scalar, and the public key, 
					which is a point on the elliptic curve, are determined by the choice of the 
					curve.<h:p/>

					When generating EdDSA key pairs for digital signatures and if “EdDSA” is claimed
					in FCS_COP.1/SigGen, then “EdDSA” must be claimed here.  The chosen domain
					parameters determine the size of the private keys and the public keys.<h:p/>

					For LMS, HSS, XMSS, and XMSS<h:sup>MT</h:sup>, the key sizes do not represent the expected 
					security strength.  All key sizes given here correspond to an expected security 
					strength of 128 bits, per NIST SP 800-208.<h:p/>

					For HSS and XMSS<h:sup>MT</h:sup> the same hash or XOF function must be used at each level.  
					Within each level, the same Winternitz parameter must be used but can be 
					different for each level.  For HSS, within each level, the same tree height 
					must be used but can be different for each level.
				</note>
				<aactivity>
					<TSS>
						The evaluator shall examine the TSS to verify that it describes how the TOE generates a key
						based on output from a random bit generator as specified in FCS_RBG.1. The evaluator shall
						review the TSS to verify that it describes how the functionality described by FCS_RBG.1 is
						invoked.<h:p/>
						The evaluator shall examine the TSS to verify that it identifies the usage, and key lifecycle
						for keys generated using each selected algorithm.<h:p/>
						If the TOE uses the generated key in a key chain/hierarchy then the evaluator shall verify that the
						TSS describes how the key is used as part of the key chain/hierarchy.
					</TSS>
					<Guidance>
						The evaluator shall verify that the AGD instructs the administrator how to configure the TOE to
						generate keys for the selected key generation algorithms for all key types and uses identified in
						the TSS.
					</Guidance>
					<Tests>
						The following tests are conditional based upon the selections made in the SFR. 
						The evaluator shall perform the following test or witness respective tests 
						executed by the developer. The tests must be executed on a platform that is as 
						close as practically possible to the operational platform (but which may be 
						instrumented in terms of, for example, use of a debug mode). Where the test is
						not carried out on the TOE itself, the test platform shall be identified and the
						differences between test environment and TOE execution environment shall be 
						described.<h:p/>			
					
						<h:br/><h:b>RSA Key Generation</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Key Generation Algorithm</h:td>
								<h:td valign="top">Cryptographic Algorithm Parameters</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">RSA</h:td>
								<h:td valign="top">RSA</h:td>
								<h:td valign="top">Modulus of size [<h:b>selection:</h:b> 2048, 3072, 4096] bits</h:td>
								<h:td valign="top">NIST FIPS PUB 186-5 (Section A.1.1)</h:td>
							</h:tr>
						</h:table><h:p/>						
						FIPS PUB 186-5 Key Pair generation specifies five methods for generating the 
						primes <h:i>p</h:i> and <h:i>q</h:i>.<h:p/>
						These are:<h:ol> 
						<h:li>Random Provable primes</h:li>
						<h:li>Random Probable primes</h:li>
						<h:li>Provable primes with conditions based on auxiliary provable primes</h:li>
						<h:li>Probable primes with conditions based on auxiliary provable primes</h:li>
						<h:li>Probable primes with conditions based on auxiliary probable primes</h:li>
						</h:ol><h:p/>
						In addition to the key generation method, the input parameters are:<h:ul>
						<h:li>Modulus [2048, 3072, 4096]</h:li>
						<h:li>Hash algorithm [SHA-1, SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, SHA-512/256, SHA3-224, SHA3-256, SHA3-384, SHA3-512] (methods 1, 3, 4 only)</h:li>
						<h:li>Rabin-Miller prime test [2<h:sup>100</h:sup>, 2<h:sup>Security String</h:sup>] (methods 2, 4, 5 only)</h:li> 
						<h:li><h:i>p</h:i> mod 8 value [0,1,3,5,7]</h:li>
						<h:li><h:i>q</h:i> mod 8 value [0,1,3,5,7]</h:li>
						<h:li>Private key format [standard, Chinese Remainder Theorem]</h:li>
						<h:li>Public exponent [fixed value, random]</h:li></h:ul><h:p/>
						The evaluator shall verify the ability of the TSF to correctly produce values
						for the RSA key components, including the public verification exponent <h:i>e</h:i>, the
						private prime factors <h:i>p</h:i> and <h:i>q</h:i>, the public modulus <h:i>n</h:i> and 
						the calculation of the private signature exponent <h:i>d</h:i>.<h:p/>
						
						<h:br/><h:i><h:b>Testing for Random Provable Primes and Conditional Methods</h:b></h:i><h:p/> 
						To test the key generation method for the Random Provable primes method and for
						all the Primes with Conditions methods (methods 1, 3-5), the evaluator must seed 
						the TSF key generation routine with sufficient data to deterministically 
						generate the RSA key pair. <h:p/>
						For each supported combination of the above input parameters, the evaluator
						shall have the TSF generate 25 key pairs. The evaluator shall verify the
						correctness of the TSF’s implementation by comparing values generated by the TSF 
						with those generated by a known good implementation using the same input 
						parameters.<h:p/>
						<h:br/><h:i><h:b>Testing for Random Probable Primes Method</h:b></h:i><h:p/>
						If the TOE generates Random Probable Primes (method 2) then, if possible, the 
						Random Probable primes method should also be verified against a known good
						implementation as described above. If verification against a known good
						implementation is not possible, the evaluator shall have the TSF generate 25 key
						pairs for each supported key length nlen and verify that all of the following 
						are true:<h:p/><h:ul>
						<h:li><h:i>n</h:i> = <h:i>p</h:i>*<h:i>q</h:i></h:li>
						<h:li><h:i>p</h:i> and <h:i>q</h:i> are probably prime according to Miller-Rabin tests with error
							probability &lt;2<h:sup>(-125)</h:sup></h:li>
						<h:li>2<h:sup>16</h:sup> &lt; <h:i>e</h:i> &lt; 2<h:sup>256</h:sup> and <h:i>e</h:i> is an odd integer</h:li>
						<h:li>GCD(<h:i>p</h:i>-1,<h:i>e</h:i>) = 1</h:li>
						<h:li>GCD(<h:i>q</h:i>-1,<h:i>e</h:i>) = 1</h:li>
						<h:li>|<h:i>p</h:i>-<h:i>q</h:i>| &gt; 2<h:sup>(<h:i>nlen</h:i>/2 – 100)</h:sup></h:li>
						<h:li><h:i>p</h:i> &#8805; squareroot(2)*( 2<h:sup>(<h:i>nlen</h:i>/2 -1)</h:sup> )</h:li>
						<h:li><h:i>q</h:i> &#8805; squareroot(2)*( 2<h:sup>(<h:i>nlen</h:i>/2 -1)</h:sup> )</h:li>
						<h:li>2<h:sup>(<h:i>nlen</h:i>/2)</h:sup> &lt; d &lt; LCM(<h:i>p</h:i>-1,<h:i>q</h:i>-1)</h:li>
						<h:li>e*d = 1 mod LCM(<h:i>p</h:i>-1,<h:i>q</h:i>-1)</h:li></h:ul>
 
						<h:br/><h:b>Eliptic Curve Key Generation</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Key Generation Algorithm</h:td>
								<h:td valign="top">Cryptographic Algorithm Parameters</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">ECC-ERB</h:td>
								<h:td valign="top">ECC - Extra Random Bits</h:td>
								<h:td valign="top">Elliptic Curve [<h:b>selection:</h:b> P-256, brainpoolP256r1, P-384, brainpoolP384r1, P-521, brainpoolP512r1]</h:td>
								<h:td valign="top">NIST FIPS PUB 186-5 (Section A.2.1)<h:p/>
													[<h:b>selection:</h:b> NIST SP 800-186 (Section 3) [NIST Curves], 
													RFC 5639 (Section 3) [Brainpool curves]]</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">ECC-RS</h:td>
								<h:td valign="top">ECC - Rejection Sampling</h:td>
								<h:td valign="top">Elliptic Curve [<h:b>selection:</h:b> P-256, brainpoolP256r1, P-384, brainpoolP384r1, P-521, brainpoolP512r1]</h:td>
								<h:td valign="top">NIST FIPS PUB 186-5 (Section A.2.2)<h:p/>
													[<h:b>selection:</h:b> NIST SP 800-186 (Section 3) [NIST Curves], 
													RFC 5639 (Section 3) [Brainpool curves]]</h:td>
							</h:tr>
						</h:table><h:p/>						
						To test the TOE’s ability to generate asymmetric cryptographic keys using
						elliptic curves, the evaluator shall perform the ECC Key Generation Test 
						and the ECC Key Validation Test using the following input parameters:<h:ul>
						<h:li>Elliptic curve [P-256, brainpoolP256r1, P-384, brainpoolP384r1, P-521, brainpoolP512r1]</h:li>
						<h:li>Key pair generation method [extra random bits, rejection sampling]</h:li></h:ul><h:p/>
						
						<h:br/><h:i><h:b>ECC Key Generation Test</h:b></h:i><h:br/>
						For each supported combination of the above input parameters the evaluator shall
						require the implementation under test to generate 10 private/public key pairs
						(<h:i>d, Q</h:i>). The private key, <h:i>d</h:i>, shall be generated using a
						random bit generator as specified in FCS_RBG.1. The private key, <h:i>d</h:i>, is
						used to compute the public key, <h:i>Q’</h:i>. The evaluator shall confirm that
						0&lt;<h:i>d</h:i>&lt;<h:i>n</h:i> (where <h:i>n</h:i> is the order of the group),
						and the computed value <h:i>Q’</h:i> is then compared to the generated 
						public/private key pairs’ public key, <h:i>Q</h:i>, to confirm that <h:i>Q</h:i> is 
						equal to <h:i>Q’</h:i>.	<h:p/>					
						
						<h:br/><h:i><h:b>ECC Key Validation Test</h:b></h:i><h:br/>
						For each supported combination of the above parameters the evaluator shall
						generate 12 private/public key pairs using the key generation function of a 
						known-good implementation. For each set of 12 public keys, the evaluator shall
						modify four public key values by shifting <h:i>x</h:i> or <h:i>y</h:i> out of 
						range by adding the order of the field and modify four other public key values 
						by shifting <h:i>x</h:i> or <h:i>y</h:i> so that they are still in bounds, but 
						not on the curve. The remaining public key values are left unchanged (i.e., 
						correct). To determine correctness, the evaluator shall submit the public keys
						to the public key validation (PKV) function of the TOE and shall confirm that 
						the results correspond as expected for the modified and unmodified values.<h:p/>
					
						<h:br/><h:b>Finite Field Cryptography Key Generation</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Key Generation Algorithm</h:td>
								<h:td valign="top">Cryptographic Algorithm Parameters</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">FFC-ERB</h:td>
								<h:td valign="top">FFC – Extra Random Bits</h:td>
								<h:td valign="top">Static domain parameters approved for [<h:b>selection:</h:b>
									IKE groups [<h:b>selection:</h:b> MODP-2048, MODP-3072, MODP-4096, 
									MODP-6144, MODP-8192], TLS groups [<h:b>selection:</h:b> ffdhe2048, 
									ffdhe3072, ffdhe4096, ffdhe6144, ffdhe8192]]]</h:td>
								<h:td valign="top">NIST SP 800-56A Revision 3 (Section 5.6.1.1.3) [key pair generation]<h:p/>
												[<h:b>selection:</h:b> RFC 3526 [IKE groups], RFC 7919 [TLS groups]]</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">FFC-RS</h:td>
								<h:td valign="top">FFC – Rejection Sampling</h:td>
								<h:td valign="top">Static domain parameters approved for [<h:b>selection:</h:b>
									IKE groups [<h:b>selection:</h:b> MODP-2048, MODP-3072, MODP-4096, 
									MODP-6144, MODP-8192], TLS groups [<h:b>selection:</h:b> ffdhe2048, 
									ffdhe3072, ffdhe4096, ffdhe6144, ffdhe8192]]]</h:td>
								<h:td valign="top">NIST SP 800-56A Revision 3 (Section 5.6.1.1.4) [key pair generation]<h:p/>
												[<h:b>selection:</h:b> RFC 3526 [IKE groups], RFC 7919 [TLS groups]]</h:td>
							</h:tr>
						</h:table><h:p/>						
						To test the TOE’s ability to generate asymmetric cryptographic keys using finite
						fields, the evaluator shall perform the Safe Primes Generation Test and the Safe
						Primes Validation Test using the following input parameter:<h:ul>
						<h:li>Fields/Groups [MODP-2048, MODP-3072, MODP-4096, MODP-6144, MODP-8192,  ffdhe2048,
							ffdhe3072, ffdhe4096, ffdhe6144, ffdhe8192]</h:li></h:ul><h:p/>
					
						<h:br/><h:i><h:b>Safe Primes Generation Test</h:b></h:i><h:br/>
						For each supported safe primes group, generate 10 key pairs. The evaluator shall 
						verify the correctness of the TSF’s implementation by comparing values generated
						by the TSF with those generated by a known good implementation using the same 
						input parameters.<h:p/>
						
						<h:br/><h:i><h:b>Safe Primes Verification Test</h:b></h:i><h:br/>
						For each supported safe primes group, use a known good implementation to generate
						10 key pairs. For each set of 10, the evaluator shall modify three such that 
						they are incorrect. The remaining values are left unmodified (i.e. correct). To
						determine correctness, the evaluator shall submit the key pairs to the public 
						key validation (PKV) function of the TOE and shall confirm that the results
						correspond as expected for the modified and unmodified values.<h:p/>
		
						<h:br/><h:b>Edwards Elliptic Curve Key Generation</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Key Generation Algorithm</h:td>
								<h:td valign="top">Cryptographic Algorithm Parameters</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">EdDSA</h:td>
								<h:td valign="top">EdDSA</h:td>
								<h:td valign="top">Domain parameters approved for elliptic curves [<h:b>selection:</h:b> Edwards25519, Edwards448]</h:td>
								<h:td valign="top">NIST FIPS PUB 186-5 (Section 6.2.1) [key-pair generation]<h:p/>
												NIST SP 800-186 (Section 3.2.3) [Edwards Curves]</h:td>
							</h:tr>
						</h:table><h:p/>						
						To test the TOE’s ability to generate asymmetric cryptographic keys using 
						Edwards key generation, the evaluator shall perform the EdDSA Key Generation 
						Test and the EdDSA Key Validation Test using the following input parameter:<h:ul>
						<h:li>Elliptic curve [Edwards25519, Edwards448]</h:li></h:ul><h:p/>

						<h:br/><h:i><h:b>EdDSA Key Generation Test</h:b></h:i><h:br/>
						For each supported curve the evaluator shall require the implementation under 
						test to generate 10 private/public key pairs (<h:i>d, Q</h:i>). The private key, 
						<h:i>d</h:i>, shall be generated using a random bit generator as specified in 
						FCS_RBG.1. The private key, <h:i>d</h:i>, is used to compute the public key,
						<h:i>Q’</h:i>. The evaluator shall confirm that 0&lt;<h:i>d</h:i>&lt;<h:i>n</h:i> 
						(where <h:i>n</h:i> is the order of the group), and the computed value <h:i>Q’</h:i> is 
						then compared to the generated public/private key pairs’ public key, <h:i>Q</h:i>, to 
						confirm that <h:i>Q</h:i> is equal to <h:i>Q’</h:i>. <h:p/>

						<h:br/><h:i><h:b>EdDSA Key Validation  Test</h:b></h:i><h:br/>
						For each supported curve, the evaluator shall generate 10 private/public key 
						pairs using the key generation function of a known good implementation, For
						each set of 10 public keys the evaluator shall modify five public key values by 
						shifting <h:i>x</h:i> or <h:i>y</h:i> so that they are still in bounds, but not 
						on the curve. The remaining values are left unmodified (i.e. correct). To 
						determine correctness, the evaluator shall submit the public keys to the public
						key validation (PKV) function of the TOE and shall confirm that the results 
						correspond as expected for the modified and unmodified values.<h:p/>

						<h:br/><h:b>KCDSA Key Generation</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Key Generation Algorithm</h:td>
								<h:td valign="top">Cryptographic Algorithm Parameters</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">KCDSA</h:td>
								<h:td valign="top">KCDSA</h:td>
								<h:td valign="top">Domain parameters generation with (L, N) = [<h:b>selection:</h:b> (2048, 224), (2048, 256), (3072, 256)] bits</h:td>
								<h:td valign="top">ISO/IEC 14888-3:2018 (Subclause 6.3) [KCDSA]</h:td>
							</h:tr>
						</h:table><h:p/>						
						To test the TOE’s ability to generate asymmetric cryptographic keys using KCDSA, 
						the evaluator shall perform the DSA Key Generation Test using the following 
						input parameter:<h:ul>
						<h:li>Values of L and N: [(2048, 224), (2048, 256), (3072, 256)]</h:li></h:ul><h:p/>

						<h:br/><h:i><h:b>KCDSA Key Generation Test</h:b></h:i><h:br/>
						For each supported (<h:i>L, N</h:i>) the evaluator shall cause the TOE to 
						generate 10 key pairs. The evaluator shall verify the correctness of the TSF’s
						implementation by comparing values generated by the TSF with those generated by
						a known good implementation using the same input parameters. <h:p/>

						<h:br/><h:b>EC-KCDSA Key Generation</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Key Generation Algorithm</h:td>
								<h:td valign="top">Cryptographic Algorithm Parameters</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">EC-KCDSA</h:td>
								<h:td valign="top">EC-KCDSA</h:td>
								<h:td valign="top">Elliptic Curves [<h:b>selection:</h:b> P-224, B-233, K-233, P-256, B-283, K-283]</h:td>
								<h:td valign="top">ISO/IEC 14888-3:2018 (Subclause 6.7) [EC-KCDSA]<h:p/>
									NIST SP 800-186 (Section 3) [NIST Curves]</h:td>
							</h:tr>
						</h:table><h:p/>						
						To test the TOE’s ability to generate asymmetric cryptographic keys using KCDSA with
						elliptic curves, the evaluator shall perform the ECC Key Generation Test and
						the ECC Key Validation Test using the following input parameters:<h:ul>
						<h:li>Elliptic curve [P-224, B-233, K-233, P-256, B-283, K-283]</h:li>
						<h:li>Key pair generation method [extra random bits, rejection sampling]</h:li></h:ul><h:p/>

						<h:br/><h:i><h:b>ECC Key Generation Test</h:b></h:i><h:br/>
						For each supported combination of the above input parameters the evaluator shall
						require the implementation under test to generate 10 private/public key pairs
						(<h:i>d, Q</h:i>). The private key, <h:i>d</h:i>, shall be generated using a
						random bit generator as specified in FCS_RBG.1. The private key, <h:i>d</h:i>, is
						used to compute the public key, <h:i>Q’</h:i>. The evaluator shall confirm that
						0&lt;<h:i>d</h:i>&lt;<h:i>n</h:i> (where <h:i>n</h:i> is the order of the group),
						and the computed value <h:i>Q’</h:i> is then compared to the generated 
						public/private key pairs’ public key, <h:i>Q</h:i>, to confirm that <h:i>Q</h:i> is 
						equal to <h:i>Q’</h:i>.<h:p/>

						<h:br/><h:i><h:b>ECC Key Validation Test</h:b></h:i><h:br/>
						For each supported combination of the above parameters the evaluator shall
						generate 12 private/public key pairs using the key generation function of a 
						known-good implementation. For each set of 12 public keys, the evaluator shall
						modify four public key values by shifting <h:i>x</h:i> or <h:i>y</h:i> out of 
						range by adding the order of the field and modify four other public key values 
						by shifting <h:i>x</h:i> or <h:i>y</h:i> so that they are still in bounds, but 
						not on the curve. The remaining public key values are left unchanged (i.e., 
						correct). To determine correctness, the evaluator shall submit the public keys
						to the public key validation (PKV) function of the TOE and shall confirm that 
						the results correspond as expected for the modified and unmodified values.<h:p/>

						<h:br/><h:b>Key Generation using LMS and HSS</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Key Generation Algorithm</h:td>
								<h:td valign="top">Cryptographic Algorithm Parameters</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">LMS</h:td>
								<h:td valign="top">LMS</h:td>
								<h:td valign="top">Private key size = [<h:b>selection:</h:b> 192 bits
									with [<h:b>selection:</h:b> SHA-256/192, SHAKE256/192], 256 bits with
									[<h:b>selection:</h:b> SHA-256, SHAKE256]], Winternitz parameter = 
									[<h:b>selection:</h:b> 1, 2, 4, 8], and tree height = [<h:b>selection:</h:b>
									5, 10, 15, 20, 25]</h:td>
								<h:td valign="top">RFC 8554 [LMS]<h:p/>
									NIST SP 800-208 [parameters]</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">HSS</h:td>
								<h:td valign="top">HSS</h:td>
								<h:td valign="top">Private key size = [<h:b>selection:</h:b> 192 bits
									with [<h:b>selection:</h:b> SHA-256/192, SHAKE256/192], 256 bits with
									[<h:b>selection:</h:b> SHA-256, SHAKE256]], Winternitz parameter = 
									[<h:b>selection:</h:b> 1, 2, 4, 8], and tree height = [<h:b>selection:</h:b>
									5, 10, 15, 20, 25], ], and number of levels = [selection: 1, 2, 3, 4, 5, 6, 7, 8]</h:td>
								<h:td valign="top">RFC 8554 [HSS]<h:p/>
									NIST SP 800-208 [parameters]</h:td>
							</h:tr>
						</h:table><h:p/>						
						To test the TOE’s ability to generate asymmetric cryptographic keys using LMS or HSS, the evaluator
						shall perform the LMS Key Generation Test using the following input parameters:<h:ul>
						<h:li>Hash algorithm [SHA-256/192, SHAKE256/192, SHA-256, SHAKE256]</h:li>
						<h:li>Winternitz [1, 2, 4, 8]</h:li>
						<h:li>Tree height [5, 10, 15, 20, 25]</h:li>
						<h:li>Number of levels [1, 2, 3, 4, 5, 6, 7, 8] (HSS only)</h:li></h:ul><h:p/>

						<h:br/><h:i><h:b>LMS Key Generation Test</h:b></h:i><h:br/>
						For each supported combination of the hash algorithm, Winternitz parameter, 
						and tree height the evaluator shall generate one public key for each of the test 
						cases.  The number of test cases depends on the tree height:<h:p/>

						<h:b><h:div style="text-align: center;">
							<ctr ctr-type="Table" pre="Table " id="lms-test-cases">: Number of LMS Test Cases</ctr>
							</h:div>
						</h:b>
							
						<h:table border="1" style="width:50%">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Height</h:td>
								<h:td valign="top">Number of test cases</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">5</h:td>
								<h:td valign="top">5</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">10</h:td>
								<h:td valign="top">4</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">15</h:td>
								<h:td valign="top">3</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">20</h:td>
								<h:td valign="top">2</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">25</h:td>
								<h:td valign="top">1</h:td>
							</h:tr>
						</h:table><h:p/>						
						The evaluator shall verify the correctness of the TSF’s implementation by
						comparing the public key generated by the TSF with that generated by a known
						good implementation using the same input parameters.<h:p/>
						
						<h:br/><h:i><h:b>HSS Key Generation Test</h:b></h:i><h:br/>
						For each supported hash algorithm generate an HSS hierarchy of LMS trees and public
						certificates. You may use eight of the LMS trees generated in LMS Key Generation, or generate
						eight new LMS trees using the supported parameters.<h:p/>
						For level one, choose an LMS tree at random. For each supported level 2 through 8 in each
						hierarchy choose another LMS tree from the set. The Winternitz parameters and LMS tree
						heights do not have to match.<h:p/>
						Create a certificate by randomly selecting a private key from the LMS tree at level <h:i>n</h:i>-1 and
						generate a certificate for the LMS public key at level <h:i>n</h:i>.<h:p/>
						The evaluator shall verify the correctness of the TSF’s implementation by comparing the
						certificates generated by the TSF with those generated by a known good implementation using
						the same input parameters.<h:p/>

						<h:br/><h:b>XMSS Key Generation</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Key Generation Algorithm</h:td>
								<h:td valign="top">Cryptographic Algorithm Parameters</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">XMSS</h:td>
								<h:td valign="top">XMSS</h:td>
								<h:td valign="top">Private key size = [<h:b>selection:</h:b> 192 bits
									with [<h:b>selection:</h:b> SHA-256/192, SHAKE256/192], 256 bits 
									with [<h:b>selection:</h:b> SHA-256, SHAKE256]], tree height = 
									[<h:b>selection:</h:b> 10, 16, 20]</h:td>
								<h:td valign="top">RFC 8391 [XMSS]<h:p/>
									NIST SP 800-208 [parameters]</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">XMSS<h:sup>MT</h:sup></h:td>
								<h:td valign="top">XMSS<h:sup>MT</h:sup></h:td>
								<h:td valign="top">Private key size = [<h:b>selection:</h:b> 192 bits
									with [<h:b>selection:</h:b> SHA-256/192, SHAKE256/192], 256 bits 
									with [<h:b>selection:</h:b> SHA-256, SHAKE256]], (total tree height, 
									number of levels) = [<h:b>selection:</h:b> (20, 2), (20, 4), (40, 2),
									(40, 4), (40, 8), (60, 3), (60, 6), (60, 12)]</h:td>
								<h:td valign="top">RFC 8391 [XMSS<h:sup>MT</h:sup>]<h:p/>
									NIST SP 800-208 [parameters]</h:td>
							</h:tr>
						</h:table><h:p/>
						To test the TOE’s ability to generate asymmetric cryptographic keys using 
						XMSS or XMSS<h:sup>MT</h:sup>, the evaluator shall perform the XMSS Key 
						Generation Test using the following input parameters:<h:ul>
						<h:li>Hash algorithm [SHA-256/192, SHAKE256/192, SHA-256, SHAKE256]</h:li>
						<h:li>Tree height [10, 16, 20] (XMSS only)</h:li>
						<h:li>Tree height/levels [20/2, 20/4, 40/2, 40/4, 40/8, 60/3, 60/6, 60/12] (XMSS<h:sup>MT</h:sup> only)</h:li></h:ul><h:p/>

						<h:b><h:div style="text-align: center;">
							<ctr ctr-type="Table" pre="Table " id="xmss-akg-test-cases">: Number of Test Cases for XMSS and XMSS<h:sup>MT</h:sup></ctr>
						</h:div></h:b>
						<h:table border="1" style="width:50%">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Height</h:td>
								<h:td valign="top">Number of test cases</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">10</h:td>
								<h:td valign="top">5</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">20</h:td>
								<h:td valign="top">3</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">40</h:td>
								<h:td valign="top">2</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">60</h:td>
								<h:td valign="top">1</h:td>
							</h:tr>
						</h:table><h:p/>						

						<h:br/><h:i><h:b>XMSS Key Generation Test</h:b></h:i><h:br/>
						For each supported combination of hash algorithm and tree height, the evaluator 
						shall generate one public key for each test case. The number of test cases
						depends on the tree height as specified in <xref to="xmss-test-cases"/>.<h:p/>

						The evaluator shall verify the correctness of the TSF’s implementation by comparing 
						values generated by the TSF with those generated by a known good implementation using 
						the same input parameters.<h:p/>
						
						<h:br/><h:i><h:b>XMSS<h:sup>MT</h:sup> Key Generation Test</h:b></h:i><h:br/>
						For each supported combination of hash algorithm and tree height, the evaluator 
						shall generate one public key for each test case. The number of test cases
						depends on the tree height as specified in <xref to="xmss-test-cases"/>.<h:p/>

						The evaluator shall verify the correctness of the TSF’s implementation by 
						comparing values generated by the TSF with those generated by a known good 
						implementation using the same input parameters.<h:p/>
						
						Note: The number of test cases is limited due to the extreme amount of time it can
						take to generate XMSS trees.<h:p/>
						
						<h:br/><h:b>ML-KEM Key Generation</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Key Generation Algorithm</h:td>
								<h:td valign="top">Cryptographic Algorithm Parameters</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">ML-KEM</h:td>
								<h:td valign="top">ML-KEM Key Generation</h:td>
								<h:td valign="top">Parameter set = [<h:b>selection:</h:b> ML-KEM-512, ML-KEM-768, ML-KEM-1024]</h:td>
								<h:td valign="top">NIST FIPS PUB 203 (Section 7.1)</h:td>
							</h:tr>
						</h:table><h:p/>						
							To test the TOE’s ability to generate asymmetric cryptographic keys using ML-KEM,
							the evaluator shall perform the Algorithm Functional Test using the following 
							input parameters:<h:ul>
							<h:li>Parameter set [ML-KEM-512, ML-KEM-768, ML-KEM-1024]</h:li>
							<h:li>Random seed d [32 bytes]</h:li>
							<h:li>Random seed z [32 bytes]</h:li></h:ul><h:p/>
							<h:br/><h:i><h:b>Algorithm Functional Test</h:b></h:i><h:br/>
							For each supported parameter set the evaluator shall require the implementation under test to
							generate 25 key pairs using 25 different randomly generated pairs of 32-byte seed values (<h:i>d, z</h:i>).
							To determine correctness, the evaluator shall compare the resulting key pairs (<h:i>ek, dk</h:i>) with those
							generated using a known-good implementation using the same inputs.<h:p/>

						<h:br/><h:b>ML-DSA Key Generation</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Key Generation Algorithm</h:td>
								<h:td valign="top">Cryptographic Algorithm Parameters</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">ML-DSA</h:td>
								<h:td valign="top">ML-DSA Key Generation</h:td>
								<h:td valign="top">Parameter set = [<h:b>selection:</h:b> ML-DSA-44, ML-DSA-65, ML-DSA-87]</h:td>
								<h:td valign="top">NIST FIPS PUB 204 (Section 5.1)</h:td>
							</h:tr>
						</h:table><h:p/>						
							To test the TOE’s ability to generate asymmetric cryptographic keys using ML-DSA, 
							the evaluator shall perform the Algorithm Functional Test using the following
							input parameters:<h:ul>
							<h:li>Parameter set [ML-DSA-44, ML-DSA-65, ML-DSA-87]</h:li>
							<h:li>Random seed [32 bytes]</h:li></h:ul><h:p/>
							<h:br/><h:i><h:b>Algorithm Functional Test</h:b></h:i><h:br/>
							For each supported parameter set the evaluator shall require the implementation 
							under test to generate 25 key pairs using 25 different randomly generated 32-byte 
							seed values. To determine correctness, the evaluator shall compare the resulting
							key pairs with those generated using a known-good implementation using the same 
							inputs.<h:p/>							
					</Tests>				
				</aactivity>
			</f-element>
						<audit-event/>
					</f-component>
					
				</section>  <!-- FCS_CKM.1/AKG -->
				
				<section title="FCS_CKM.1/SKG Cryptographic Key Generation - Symmetric Keys" id="catsec-fcs-ckm-1-skg">
					
					<!-- <note role="ppdev">Blahblah</note>  -->
					<h:b>Catalog Guidance Notes</h:b><h:p/>
						Include this component if the TOE supports creating symmetric keys directly from the output of
						an RBG without further conditioning.<h:p/>
						To derive symmetric keys from other keying material, see FCS_CKM.5. To derive symmetric
						keys from passwords, see FCS_CKM_EXT.8. To derive symmetric keys from keying material
						contributed from two parties, see FCS_CKM_EXT.7. 
					
					<!-- FCS_CKM.1/SKG Cryptographic Key Generation - Symmetric Key -->
					<f-component id="sfr-fcs-ckm-1-skg" cc-id="fcs_ckm.1" iteration="SKG" 
						name="Cryptographic Key Generation - Symmetric Key">

						<comp-rel>
							<hierarchical-to/>
							<dependencies-to>
								<or-dep>
									<comp-ref>FCS_CKM.2 Cryptographic key distribution</comp-ref> 
									<comp-ref>FCS_CKM.5 Cryptographic key derivation</comp-ref> 
									<comp-ref>FCS_CKM_EXT.7 Cryptographic Key Agreement</comp-ref> 
									<comp-ref>FCS_COP.1 Cryptographic operation</comp-ref>
								</or-dep>
								<comp-ref>FCS_CKM.6 Timing and event of cryptographic key destruction</comp-ref>
								<or-dep>
									<comp-ref>FCS_RBG.1 Random bit generation</comp-ref>
									<comp-ref>FCS_RNG.1 Generation of random numbers</comp-ref>
								</or-dep>
							</dependencies-to>
						</comp-rel>

			<f-element id="fcs-ckm-1e1-skg">
				<title>
					The TSF shall generate <h:b>symmetric</h:b> cryptographic keys in accordance with
					a specified cryptographic key generation algorithm<selectables>
						<tabularize id="fcs-ckm-1-skg-sels" title="Recommended choices for FCS_CKM.1/SKG">
							<textcol>Identifier</textcol>
							<selectcol>Cryptographic Key Generation Algorithm</selectcol>
							<reqtext>and specified cryptographic key sizes</reqtext>
							<selectcol>Cryptographic Key Sizes</selectcol>
							<reqtext>that meet the following: </reqtext>
							<selectcol>List of standards</selectcol>
							<reqtext><h:p/><h:p/>The following table provides the recommended choices for
										completion of the selection operations of FCS_CKM.1/SKG.</reqtext>
						</tabularize>

						<!-- RSK -->
						<selectable id="sel-fcs-ckm-sk-rsk">
							<col>RSK</col>
							<col>Direct Generation from a Random Bit Generator as specified in FCS_RBG.1</col>
							<col><selectables>
								<selectable id="sel-exp-skg-128">123</selectable>
								<selectable id="sel-exp-skg-256">256</selectable>
								<selectable id="sel-exp-skg-512">512</selectable></selectables> bits
							</col>
							<col>NIST SP 800-133 Revision 2 (Section 6.1)[Direct generation of symmetric keys]</col>
						</selectable>
					</selectables>
				</title>
				<note role="application">
					This SFR must be included in the ST if it is a service provided by the TOE to tenant software,
					or if it is used by the TOE itself to support or implement PP-specified security functionality.<h:p/> 
					This SFR must be included in the ST if "<h:i>causing the TOE to generate [symmetric] keys/secrets</h:i>"
					is selected in FCS_STG_EXT.1.2.<h:p/>
					If this SFR is included in the ST, then FCS_CKM.6 and FCS_RBG.1 must also be claimed.
				</note>
				<aactivity>
					<TSS>
						The evaluator shall examine the TSS to verify that it describes how the TOE obtains a symmetric
						cryptographic key through direct generation from a random bit generator as specified in
						FCS_RBG.1. The evaluator shall review the TSS to verify that it describes how the functionality
						described by FCS_RBG.1 is invoked.<h:p/>
						The evaluator shall examine the TSS to verify that it identifies the usage, and key lifecycle for
						keys generated using each selected algorithm.<h:p/>
						If the TOE uses the generated key in a key chain/hierarchy then the evaluator shall verify that the
						TSS describes how the key is used as part of the key chain/hierarchy.
					</TSS>
					<Guidance>
						The evaluator shall verify that the AGD instructs the administrator how to configure the TOE to
						use the RBG to generate symmetric keys for all uses identified in the ST.
					</Guidance>
					<Tests>
						The following tests are conditional based upon the selections made in the SFR.
						The evaluator shall perform the following test or witness respective tests 
						executed by the developer. The tests must be executed on a platform that is as 
						close as practically possible to the operational platform (but which may be 
						instrumented in terms of, for example, use of a debug mode). Where the test 
						is not carried out on the TOE itself, the test platform shall be identified and
						the differences between test environment and TOE execution environment shall be
						described.<h:p/>
						To test the TOE’s ability to generate symmetric cryptographic keys using a 
						random bit generator, the evaluator shall configure the asymmetric cryptographic 
						key generation capability for each claimed key size. The evaluator shall use the
						description of the RBG interface to verify that the TOE requests and receives an
						amount of RBG output greater than or equal to the requested key size.
					</Tests>				
				</aactivity>
			</f-element>
						<audit-event/>
					</f-component>
					
				</section>  <!-- FCS_CKM.1/SKG -->

				<section title="FCS_CKM.2 Cryptographic Key Distribution" id="catsec-fcs-ckm-2">
					
					<!-- <note role="ppdev">Blahblah</note>  -->
					<h:b>Catalog Guidance Notes</h:b><h:p/>
						Key distribution (or key transport) is a key establishment scheme in which one party creates a key
						and sends it to another party.<h:p/>
						Key distribution methods cover both the transmission and reception of keys. Although many
						products support both the transmission and reception of keys, it is not unusual to find that
						constrained environments only support one or the other. 
				
					<!-- FCS_CKM.2 Cryptographic Key Distribution -->
					<f-component id="sfr-fcs-ckm-2" cc-id="fcs_ckm.2" name="Cryptographic Key Distribution">
				
						<comp-rel>
							<hierarchical-to/>
							<dependencies-to>
								<or-dep>
									<comp-ref>FDP_ITC.1 Import of user data without security attributes</comp-ref> 
									<comp-ref>FDP_ITC.2 Import of user data with security attributes</comp-ref> 
									<comp-ref>FCS_CKM.1 Cryptographic key generation</comp-ref> 
									<comp-ref>FCS_CKM.5 Cryptographic key derivation</comp-ref> 
									<comp-ref>FCS_CKM_EXT.8 Password-based key derivation</comp-ref> 
									<comp-ref>FCS_CKM_EXT.3 Cryptographic Key Access</comp-ref>
								</or-dep>
								<comp-ref>FCS_CKM.6 Timing and event of cryptographic key destruction</comp-ref>
								<or-dep>
									<comp-ref>FCS_COP.1/KeyEncap Key Encapsulation</comp-ref>
									<comp-ref>FCS_COP.1/KeyWrap Key Wrapping</comp-ref>
									<comp-ref>FTP_PRO.1 Trusted Channel Protocol</comp-ref>
								</or-dep>
							</dependencies-to>
						</comp-rel>
				
			<f-element id="fcs-ckm-2e1">
				<title>The TSF shall distribute cryptographic keys in accordance with a specified cryptographic 
					key distribution method <selectables>
						<selectable>key encapsulation</selectable>
						<selectable>key wrapping</selectable>
						<selectable>encrypted channels</selectable>
					</selectables> that meets the following: [none].
				</title>
				<note role="application">
					If “key encapsulation” is selected, FCS_COP.1/KeyEncap must be claimed, which specifies 
					the relevant list of standards.  <h:p/>
					If “key wrapping” is selected, FCS_COP.1/KeyWrap must be claimed, which specifies the 
					relevant list of standards.<h:p/>
					If “encrypted channels” is selected, FTP_PRO.1 must be claimed, which specifies the relevant 
					list of standards.
				</note>
				<aactivity>
					<TSS>
						The evaluator shall ensure that the TSS documents that the security strength supported by
						the selected key distribution methods is sufficient for the security strength of the keys
						distributed through those methods.<h:p/>
						It is not necessary to identify the services that use each key distribution method here. That
						information should be documented in the requirements for the individual services and
						protocols that invoke key distribution.
					</TSS>
					<Guidance>
						The evaluator shall verify that the AGD guidance instructs the administrator
						how to configure the TOE to use the selected key distribution methods.
					</Guidance>
					<Tests>
						Specific testing for this component is covered by testing for the claimed components in
						FCS_COP.1/KeyEncap, FCS_COP.1/KeyWrap, or FTP_PRO.1.
					</Tests>
				</aactivity>
			</f-element>
						<audit-event/>
					</f-component>
				</section>     <!-- FCS_CKM.2 -->

				<section title="FCS_CKM_EXT.3 Cryptographic Key Access" id="catsec-fcs-ckm-ext-3">
					
					<!-- <note role="ppdev">Blahblah</note>  -->
					<h:b>Catalog Guidance Notes</h:b><h:p/>
						FCS_CKM_EXT.3 cryptographic key access applies primarily to the storage of keys for future
						use and retrieval of keys for immediate use by the TOE. There may be some overlap in
						primitives used in other SFRs, but the end goals here are to protect the confidentiality and
						authenticity of the keys while in storage.<h:p/>
						This SFR recasts FCS_CKM.3.1 of CC:2022 Part 2 to place the emphasis on key access
						methods.<h:p/>
						It may be necessary to combine this component with other components to ensure the
						confidentiality, integrity, and authenticity of the key while it is outside the control 
						of the TOE.  
				
					<!-- FCS_CKM_EXT.3 Cryptographic Key Access -->
					<f-component id="sfr-fcs-ckm-ext-3" cc-id="fcs_ckm_ext.3" name="Cryptographic Key Access">
				
						<ecd-info>
							<comp-lev> requires access to cryptographic keys stored outside the TOE to be 
								performed in accordance with a specified access method
							</comp-lev>
							<manageable-actions/>
							<auditable-actions>
								<action-descr>minimal: Success and failure of the activity;</action-descr>
								<action-descr>basic: The object attribute(s), and object value(s) excluding 
									any sensitive information.</action-descr>
							</auditable-actions>
						</ecd-info>

						<comp-rel>
							<hierarchical-to/>
							<dependencies-to>
								<or-dep>
									<comp-ref>FCS_CKM.1 Cryptographic key generation</comp-ref> 
									<comp-ref>FCS_CKM.5 Cryptographic key derivation</comp-ref> 
									<comp-ref>FCS_CKM_EXT.8 Password-based key derivation</comp-ref> 
								</or-dep>
								<comp-ref>FCS_CKM.6 Timing and event of cryptographic key destruction</comp-ref>
								<or-dep>
									<comp-ref>FCS_COP.1/KeyEncap Key Encapsulation</comp-ref>
									<comp-ref>FCS_COP.1/KeyWrap Key Wrapping</comp-ref>
									<comp-ref>FCS_COP.1/SKC Symmetric Key Cryptography</comp-ref>
									<comp-ref>FCS_COP.1/AEAD Authenticated Encryption with Associated Data]</comp-ref>
								</or-dep>
							</dependencies-to>
						</comp-rel>
				
			<f-element id="fcs-ckm-ext-3e1">
				<title>The TSF shall use specified cryptographic key access methods <selectables>
						<selectable>key encapsulation</selectable>
						<selectable>key wrapping</selectable>
						<selectable>key encryption</selectable>
					</selectables> to access keys when performing <selectables>
						<selectable>cryptographic key archival</selectable>
						<selectable>cryptographic key backup</selectable>
						<selectable>cryptographic key escrow</selectable>
						<selectable>cryptographic key recovery</selectable>
						<selectable>cryptographic key import</selectable>
						<selectable>cryptographic key export</selectable>
					</selectables>
				</title>
				<note role="application">
					If “key encapsulation” is selected, FCS_COP.1/KeyEncap must be claimed. <h:p/>
					If “key wrapping” is selected, FCS_COP.1/KeyWrap must be claimed.<h:p/>
					If “key encryption” is selected, FCS_COP.1/SKC or FCS_COP.1/AEAD must be claimed. 
				</note>
				<aactivity>
					<TSS>
						The evaluator shall ensure that the TSS documents that the security strength 
						supported by the selected key access methods are sufficient for the security
						strength of the keys accessed through those methods.<h:p/>
						The evaluator shall ensure that the TSS identifies the key management services
						implemented by the TOE and the key access methods used for each service.
					</TSS>
					<Guidance>
						The evaluator shall ensure that the AGD instructs the admnistrator how to configure
						the TOE to use the selected key access methods.
					</Guidance>
					<Tests>
						Specific testing for this component is covered by testing for the claimed components
						in FCS_COP.1/KeyEncap, FCS_COP.1/KeyWrap, FCS_COP.1/AEAD, and FCS_COP.1/SKC.
					</Tests>
				</aactivity>
			</f-element>
						<audit-event/>
					</f-component>
				</section>     <!-- FCS_CKM_EXT.3 -->
			
	
				<section title="FCS_CKM.5 Cryptographic Key Derivation" id="catsec-fcs-ckm-5">
					
					<!-- <note role="ppdev">Blahblah</note>  -->
					<h:b>Catalog Guidance Notes</h:b><h:p/>
						FCS_CKM.5 Cryptographic Key Derivation covers keys derived using specified cryptographic
						algorithms. The input to the cryptographic algorithms may be from an entropy source or from
						other sources. Passwords and pass phrases as input are special cases of key derivation with
						limited entropy input, which are addressed in FCS_CKM_EXT.8. <h:p/>
						The output may be used as a symmetric key or for other cryptographic purposes, such as
						initialization vectors, authentication secrets, HMAC keys, KMAC keys, secret IVs, and secret
						seeds. <h:p/>
						The protocol- and application-specific KDFs specified in NIST SP 800-135r1 (e.g., IKE, TLS) do
						not appear in this catalog.   
				
					<!-- FCS_CKM.5 Cryptographic Key Derivation -->
					<f-component id="sfr-fcs-ckm-5" cc-id="fcs_ckm.5" name="Cryptographic Key Derivation">
					
						<comp-rel>
							<hierarchical-to/>
							<dependencies-to>
								<or-dep>
									<comp-ref>FCS_CKM.2 Cryptographic key distribution</comp-ref> 
									<comp-ref>FCS_COP.1 Cryptographic Operation</comp-ref> 
								</or-dep>
								<comp-ref>FCS_CKM.6 Timing and event of cryptographic key destruction</comp-ref>
								<or-dep>
									<comp-ref>FCS_COP.1/CMAC Cryptographic Operation - CMAC</comp-ref>
									<comp-ref>FCS_COP.1/Hash Cryptographic Operation - Hashing</comp-ref>
									<comp-ref>FCS_COP.1/KeyedHash Cryptographic Operation - Keyed hash</comp-ref>
									<comp-ref>FCS_COP.1/SKC Cryptographic Operation - Symmetric key cryptography</comp-ref>
									<comp-ref>FCS_COP.1/AEAD Authenticated Encryption with Associated Data</comp-ref>
								</or-dep>
							</dependencies-to>
						</comp-rel>
					
			<f-element id="fcs-ckm-5e1">
				<title>
					The TSF shall derive cryptographic keys
					<selectables>
						<tabularize id="fcs-ckm-keydrv-sels" title="Recommended choices for FCS_CKM.5">
							<selectcol>Key type</selectcol>
							<reqtext>from</reqtext>
							<selectcol>Input parameters</selectcol>
							<reqtext>in accordance with a specified key derivation algorithm</reqtext>
							<selectcol>Key derivation algorithm</selectcol>
							<reqtext>and specified cryptographic key sizes</reqtext>
							<selectcol>Key sizes</selectcol>
							<reqtext>that meet the following:</reqtext>
							<selectcol>List of standards</selectcol>
							<reqtext><h:p/><h:p/>The following table provides the recommended choices for
										completion of the selection operations of FCS_CKM.5.</reqtext>
						</tabularize>

						<!-- KDF-CTR -->
						<selectable id="sel-fcs-ckm-5-kdf-ctr">
							<col>KDF-CTR</col>  <!-- formerly KeyDrv1 -->
							<col><selectables>
								<selectable id="sel-fcs-ckm-5-kdf-ctr-dirgen">Direct Generation from a Random
									Bit Generator as specified in FCS_RBG.1</selectable>
								<selectable>Concatenated keys</selectable>
							</selectables></col>
							<col>KPF2 - KDF in Counter Mode using <selectables>
								<selectable>AES-128-CMAC</selectable>
								<selectable>AES-192-CMAC</selectable>
								<selectable>AES-256-CMAC</selectable>
								<selectable>Camillia-128-CMAC</selectable>
								<selectable>Camillia-192-CMAC</selectable>
								<selectable>Camillia-256-CMAC</selectable>
								<selectable>CMAC-HIGHT-128</selectable>
								<selectable>CMAC-LEA-128</selectable>
								<selectable>CMAC-LEA-256</selectable>
								<selectable>CMAC-SEED-128</selectable>
								<selectable>HMAC-SHA-1</selectable>
								<selectable>HMAC-SHA-256</selectable>
								<selectable>HMAC-SHA-512</selectable>
							</selectables> as the PRF</col>
							<col><selectables>
								<selectable>128</selectable>
								<selectable>192</selectable>
								<selectable>256</selectable>
								<selectable>512</selectable>
							</selectables> bits</col>
							<col><selectables>
								<selectable>ISO/IEC 11770-6:2016 (Subclause 7.3.2) [KPF2]</selectable>
								<selectable>NIST SP 800-108 Revision 1 Update 1 (Section 4.1) [KDF in Counter Mode]</selectable>
							</selectables></col>
						</selectable>

						<!-- KDF-FB -->
						<selectable id="sel-fcs-ckm-5-kdf-fb">
							<col>KDF-FB</col>  <!-- formerly KeyDrv2  -->
							<col><selectables>
								<selectable id="sel-fcs-ckm-5-kdf-fb-dirgen">Direct Generation from a Random Bit Generator as specified in FCS_RBG.1</selectable>
								<selectable>Concatenated keys</selectable>
							</selectables></col>
							<col>KPF3 - KDF in Feedback Mode using <selectables>
								<selectable>AES-128-CMAC</selectable>
								<selectable>AES-192-CMAC</selectable>
								<selectable>AES-256-CMAC</selectable>
								<selectable>Camillia-128-CMAC</selectable>
								<selectable>Camillia-192-CMAC</selectable>
								<selectable>Camillia-256-CMAC</selectable>
								<selectable>CMAC-HIGHT-128</selectable>
								<selectable>CMAC-LEA-128</selectable>
								<selectable>CMAC-LEA-256</selectable>
								<selectable>CMAC-SEED-128</selectable>
								<selectable>HMAC-SHA-1</selectable>
								<selectable>HMAC-SHA-256</selectable>
								<selectable>HMAC-SHA-512</selectable>
							</selectables> as the PRF</col>
							<col><selectables>
								<selectable>128</selectable>
								<selectable>192</selectable>
								<selectable>256</selectable>
								<selectable>512</selectable>
							</selectables> bits</col>
							<col><selectables>
								<selectable>ISO/IEC 11770-6:2016 (Subclause 7.3.3) [KPF3]</selectable>
								<selectable>NIST SP 800-108 Revision 1 Update 1 (Section 4.2) [KDF in Feedback Mode]</selectable>
							</selectables></col>
						</selectable>

						<!-- KDF-DPI -->
						<selectable id="sel-fcs-ckm-5-kdf-dpi">
							<col>KDF-DPI</col> <!-- formerly KeyDrv3  -->
								<col><selectables><selectable id="sel-fcs-ckm-5-kdf-dpi-dirgen">Direct Generation from a Random Bit Generator as specified in FCS_RBG.1</selectable>
								<selectable>Concatenated keys</selectable>
								</selectables></col>
							<col>KDF in Double Pipeline Iteration Mode using <selectables>
									<selectable>AES-128-CMAC</selectable>
									<selectable>AES-192-CMAC</selectable>
									<selectable>AES-256-CMAC</selectable>
									<selectable>Camillia-128-CMAC</selectable>
									<selectable>Camillia-192-CMAC</selectable>
									<selectable>Camillia-256-CMAC</selectable>
									<selectable>CMAC-HIGHT-128</selectable>
									<selectable>CMAC-LEA-128</selectable>
									<selectable>CMAC-LEA-256</selectable>
									<selectable>CMAC-SEED-128</selectable>
									<selectable>HMAC-SHA-1</selectable>
									<selectable>HMAC-SHA-256</selectable>
									<selectable>HMAC-SHA-512</selectable>
								</selectables> as the PRF</col>
							<col><selectables>
								<selectable>128</selectable>
								<selectable>192</selectable>
								<selectable>256</selectable>
								<selectable>512</selectable>
								</selectables>bits</col>
							<col><selectables>
								<selectable>ISO/IEC 11770-6:2016 (Subclause 7.3.4) [KPF4]</selectable>
								<selectable>NIST SP 800-108 Revision 1 Update 1 (Section 4.3) [KDF in Double-Pipeline Iteration Mode]</selectable>
							</selectables></col>
						</selectable>
						
						<!-- KDF-XOR -->
						<selectable id="sel-fcs-ckm-5-kdf-xor">
							<col>KDF-XOR</col>  <!-- formerly KeyDrv4  -->
							<col>More than one intermediary key</col>
							<col>exclusive OR (XOR)</col>
							<col><selectables>
								<selectable>128</selectable>
								<selectable>192</selectable>
								<selectable>256</selectable>
								<selectable>512</selectable>
								</selectables> bits</col>
							<col>N/A</col>
						</selectable>

						<!-- KDF-ENC -->
						<selectable id="sel-fcs-ckm-5-kdf-enc">
							<col>KDF-ENC</col>  <!-- formerly KeyDrv6 -->
							<col>Two keys</col>
							<col>Encrypting using an algorithm specified in <selectables>
								<selectable>FCS_COP.1/SKC</selectable>
								<selectable>FCS_COP.1/AEAD</selectable></selectables>
							</col>
							<col><selectables>
								<selectable>128</selectable>
								<selectable>192</selectable>
								<selectable>256</selectable>
								<selectable>512</selectable>
								</selectables> bits</col>
							<col>N/A</col>
						</selectable>

						<!-- KDF-HASH -->
						<selectable id="sel-fcs-ckm-5-kdf-hash">
							<col>KDF-HASH</col>  <!-- formerly KeyDrv7 -->
							<col>Shared secret</col>
							<col>Hash function from FCS_COP.1/Hash</col> 
							<col><selectables>
								<selectable>128</selectable>
								<selectable>192</selectable>
								<selectable>256</selectable>
								<selectable>512</selectable>
								</selectables> bits</col>
							<col>NIST SP 800-56C Revision 2 (Section 4.1, Option 1) [One-Step Key Derivation]</col>
						</selectable>

						<!-- KDF-MAC-1S -->
						<selectable id="sel-fcs-ckm-5-kdf-mac-1S">
							<col>KDF-MAC-1S</col>  <!-- formerly KeyDrv8 -->
							<col>Shared secret, salt, IV, output length, fixed information</col>
							<col>Keyed hash from FCS_COP.1/KeyedHash</col>
							<col><selectables>
								<selectable>128</selectable>
								<selectable>192</selectable>
								<selectable>256</selectable>
								<selectable>512</selectable>
								</selectables> bits</col>
							<col>NIST SP 800-56C Revision 2 (Section 4.1, Options 2, 3) [One-Step Key Derivation]</col>
						</selectable>

						<!-- KDF-MAC-2S -->
						<selectable id="sel-fcs-ckm-5-kdf-mac-2S">
							<col>KDF-MAC-2S</col>  
							<col>Shared secret, salt, IV, output length, fixed information</col>
							<col>MAC Step <selectables>
								<selectable>AES-128-CMAC</selectable>
								<selectable>AES-192-CMAC</selectable>
								<selectable>AES-256-CMAC</selectable>
								<selectable>Camillia-128-CMAC</selectable>
								<selectable>Camillia-192-CMAC</selectable>
								<selectable>Camillia-256-CMAC</selectable>
								<selectable>HMAC-SHA-1</selectable>
								<selectable>HMAC-SHA-256</selectable>
								<selectable>HMAC-SHA-512</selectable></selectables>
								as randomness extraction and; KDF Step <selectables>
								<selectable>KDF-CTR</selectable>
								<selectable>KDF-FB</selectable>
								<selectable>KDF-DPI</selectable></selectables>
								using <selectables>	
								<selectable>AES-128-CMAC</selectable>
								<selectable>AES-192-CMAC</selectable>
								<selectable>AES-256-CMAC</selectable>
								<selectable>Camillia-128-CMAC</selectable>
								<selectable>Camillia-192-CMAC</selectable>
								<selectable>Camillia-256-CMAC</selectable>
								<selectable>HMAC-SHA-1</selectable>
								<selectable>HMAC-SHA-256</selectable>
								<selectable>HMAC-SHA-512</selectable></selectables>
								as PRF.</col>
							<col><selectables>
								<selectable>128</selectable>
								<selectable>192</selectable>
								<selectable>256</selectable>
								<selectable>512</selectable>
								</selectables> bits</col>
							<col>NIST SP 800-56C Revision 2 (Section 5) [Two-Step Key Derivation]</col>
						</selectable>

						<!-- KDF-KMAC -->
						<selectable id="sel-fcs-ckm-5-kdf-kmac">
							<col>KDF-KMAC</col>
							<col>Key, context string, output length, label</col>
							<col><selectables>
								<selectable>KMAC128</selectable>
								<selectable>KMAC256</selectable>
							</selectables></col>
							<col><selectables>
								<selectable>128</selectable>
								<selectable>192</selectable>
								<selectable>256</selectable>
								<selectable>512</selectable>
								</selectables> bits</col>
							<col>NIST SP 800-108 Revision 1 Update 1 (Section 4.4 “KDF Using KMAC”)</col>
						</selectable>
					</selectables>
				</title>
				<note role="application">
					In KDF-MAC-2S, if a CMAC is selected in the MAC step, then select AES-128-CMAC or
					Camellia-128-CMAC in the KDF step and select 128 as the output key size. If HMAC is selected
					in the MAC step, then select the same HMAC in the KDF.<h:p/>
					The respective FCS_COP.1 component must be claimed for each primitive selected in key
					derivation algorithm.
				</note>
				<aactivity>
					<TSS>
						The evaluator shall ensure that the TSS documents that the security strength of the
						auxiliary functions in the below key derivation methods are sufficient for the security
						strength of the keys derived through those methods.<h:p/>
					
						The evaluator shall ensure that the TSS identifies the purposes for which each of the 
						claimed key derivation functions are used.<h:p/>
						TBD

						The evaluator shall examine the TSS to ensure that:<h:ul>
						<h:li>The TSS describes the complete key derivation chain and the description
							must be consistent with the description in the TSS. For all key derivations the
							TOE must use a method as described in the PP table. There should be no
							uncertainty about how a key is derived from another in the chain.</h:li>
						<h:li>The length of the key derivation key is defined by the PRF. The evaluator
							should check whether the key derivation key length is consistent with the
							length provided by the selected PRF.</h:li>
						<h:li>If a key is used as an input to several KDFs, each invocation must use a
							distinct context string. If the output of a KDF execution is used for multiple
							cryptographic keys, those keys must be disjoint segments of the output.</h:li>
						<h:li>If keys are combined, the ST Author shall describe which method of combination is used in order
							to justify that the effective entropy of each factor is preserved.</h:li>
						</h:ul>

					</TSS>
					<Guidance>
						The evaluator shall verify that the AGD instructs the administrator how
						to configure the TOE to use the selected key derivation functions for all uses identified in the ST.
					</Guidance>
					
					<Tests>
						The evaluator shall perform the following test or witness respective tests 
						executed by the developer. The tests must be executed on a platform that is as 
						close as practically possible to the operational platform (but which may be 
						instrumented in terms of, for example, use of a debug mode). Where the test is
						not carried out on the TOE itself, the test platform shall be identified and
						the differences between test environment and TOE execution environment shall be
						described.<h:p/>
						
						<!-- KDF in Counter Mode -->
						<h:br/><h:b>KDF in Counter Mode</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Key Type</h:td>
								<h:td valign="top">Input Parameters</h:td>
								<h:td valign="top">Key Derivation Algorithm</h:td>
								<h:td valign="top">Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">KDF-CTR</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> Direct Generation from a Random Bit Generator as 
									specified in FCS_RBG.1, Concatenated keys]</h:td>
								<h:td valign="top">KPF2 - KDF in Counter Mode using [<h:b>selection:</h:b> 
									AES-128-CMAC; AES-192-CMAC; AES-256-CMAC; 
									Camellia-128-CMAC; Camellia-192-CMAC; Camellia-256-CMAC;
									CMAC-HIGHT-128;
									CMAC-LEA-128; CMAC-LEA-256;
									CMAC-SEED-128;
									HMAC-SHA-1; HMAC-SHA-256; HMAC-SHA-512] as the PRF</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> 128, 192, 256, 512] bits</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> ISO/IEC 11770-6:2016
									(Subclause 7.3.2) [KPF2], NIST SP 800-108 Revision 1 Update 1 (Section 4.1) 
									[KDF in Counter Mode]]</h:td>
							</h:tr>
						</h:table><h:p/>						
						To test the TOE’s ability to derive cryptographic keys using KDF in Counter 
						Mode/KDF2, the evaluator shall perform the Counter KDF Algorithm Functional
						Test using the following input parameters:<h:ul>
						<h:li>Pseudo Random Function (PRF) [AES-128-CMAC, AES-192-CMAC, AES-256-CMAC,
							Camellia-128-CMAC, Camellia-192-CMAC, Camellia-256-CMAC, CMAC-HIGHT-128, 
							CMAC-LEA-128, CMAC-LEA-256, CMAC-SEED-128, HMAC-SHA-1, HMAC-SHA-256, 
							HMAC-SHA-512]</h:li>
						<h:li>Derived key length [128, 192, 256, 512] bits</h:li>
						<h:li>Location of the counter [after fixed data, before fixed data, middle fixed data]</h:li>
						<h:li>Counter length [8, 16, 24, 32] bits</h:li></h:ul><h:p/>
						<h:br/><h:i><h:b>Counter KDF Algorithm Functional Test</h:b></h:i><h:br/>
						For each supported combination of the above input parameters the evaluator 
						shall require the implementation under test to derive two keys using random 
						data. The evaluator shall compare the resulting keys with keys generated using 
						a known-good implementation using the same input parameters.<h:p/>
						
						<!-- KDF in Feedback Mode -->
						<h:br/><h:b>KDF in Feedback Mode</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Key Type</h:td>
								<h:td valign="top">Input Parameters</h:td>
								<h:td valign="top">Key Derivation Algorithm</h:td>
								<h:td valign="top">Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">KDF-FB</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> Direct Generation from a Random Bit Generator as 
									specified in FCS_RBG.1, Concatenated keys]</h:td>
								<h:td valign="top">KPF3 - KDF in Feedback Mode using [<h:b>selection:</h:b> 
									AES-128-CMAC; AES-192-CMAC; AES-256-CMAC; 
									Camellia-128-CMAC; Camellia-192-CMAC; Camellia-256-CMAC;
									CMAC-HIGHT-128;
									CMAC-LEA-128; CMAC-LEA-256;
									CMAC-SEED-128;
									HMAC-SHA-1; HMAC-SHA-256; HMAC-SHA-512] as the PRF</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> 128, 192, 256, 512] bits</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> ISO/IEC 11770-6:2016
									(Subclause 7.3.3) [KPF3], NIST SP 800-108 Revision 1 Update 1 (Section 4.2) 
									[KDF in Feedback Mode]]</h:td>
							</h:tr>
						</h:table><h:p/>						
						To test the TOE’s ability to derive cryptographic keys using KDF in Feedback 
						Mode/KDF3, the evaluator shall perform the Feedback KDF Algorithm Functional
						Test using the following input parameters:<h:ul>
						<h:li>Pseudo Random Function (PRF) [AES-128-CMAC, AES-192-CMAC, AES-256-CMAC,
							Camellia-128-CMAC, Camellia-192-CMAC, Camellia-256-CMAC, CMAC-HIGHT-128, 
							CMAC-LEA-128, CMAC-LEA-256, CMAC-SEED-128, HMAC-SHA-1, HMAC-SHA-256, 
							HMAC-SHA-512]</h:li>
						<h:li>Derived key length [128, 192, 256, 512] bits</h:li>
						<h:li>Location of the counter [none, after fixed data, before fixed data, before iterator]</h:li>
						<h:li>Counter length [0, 8, 16, 24, 32] bits</h:li></h:ul><h:p/>		
						<h:br/><h:i><h:b>Feedback KDF Algorithm Functional Test</h:b></h:i><h:br/>
						For each supported combination of the above input parameters the evaluator 
						shall require the implementation under test to derive two keys using random 
						data. The evaluator shall compare the resulting keys with keys generated using 
						a known-good implementation using the same input parameters.<h:p/>

						<!-- KDF in Double-Pipeline Iteraton Mode -->
						<h:br/><h:b>KDF in Double-Pipeline Iteraton Mode</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Key Type</h:td>
								<h:td valign="top">Input Parameters</h:td>
								<h:td valign="top">Key Derivation Algorithm</h:td>
								<h:td valign="top">Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">KDF-DPI</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> Direct Generation from a Random Bit Generator as 
									specified in FCS_RBG.1, Concatenated keys]</h:td>
								<h:td valign="top">KPF4 - KDF in Double-Pipeline Iteration Mode using [<h:b>selection:</h:b> 
									AES-128-CMAC; AES-192-CMAC; AES-256-CMAC; 
									Camellia-128-CMAC; Camellia-192-CMAC; Camellia-256-CMAC;
									CMAC-HIGHT-128;
									CMAC-LEA-128; CMAC-LEA-256;
									CMAC-SEED-128;
									HMAC-SHA-1; HMAC-SHA-256; HMAC-SHA-512] as the PRF</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> 128, 192, 256, 512] bits</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> ISO/IEC 11770-6:2016
									(Subclause 7.3.4) [KPF4], NIST SP 800-108 Revision 1 Update 1 (Section 4.3) 
									[KDF in Double-Pipeline Iteration Mode]]</h:td>
							</h:tr>
						</h:table><h:p/>						
						To test the TOE’s ability to derive cryptographic keys using KDF in Double Pipeline Iteration  
						Mode/KDF4, the evaluator shall perform the Double Pipeline Iteration KDF Algorithm Functional
						Test using the following input parameters:<h:ul>
						<h:li>Pseudo Random Function (PRF) [AES-128-CMAC, AES-192-CMAC, AES-256-CMAC,
							Camellia-128-CMAC, Camellia-192-CMAC, Camellia-256-CMAC, CMAC-HIGHT-128, 
							CMAC-LEA-128, CMAC-LEA-256, CMAC-SEED-128, HMAC-SHA-1, HMAC-SHA-256, 
							HMAC-SHA-512]</h:li>
						<h:li>Derived key length [128, 192, 256, 512] bits</h:li>
						<h:li>Location of the counter [none, after fixed data, before fixed data, before iterator]</h:li>
						<h:li>Counter length [0, 8, 16, 24, 32] bits</h:li></h:ul><h:p/>
						<h:br/><h:i><h:b>Double Pipeline Iteration KDF Algorithm Functional Test</h:b></h:i><h:br/>
						For each supported combination of the above input parameters the evaluator 
						shall require the implementation under test to derive two keys using random 
						data. The evaluator shall compare the resulting keys with keys generated using 
						a known-good implementation using the same input parameters.<h:p/>

						<!-- KDF XORing Keys -->
						<h:br/><h:b>KDF XORing Keys</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Key Type</h:td>
								<h:td valign="top">Input Parameters</h:td>
								<h:td valign="top">Key Derivation Algorithm</h:td>
								<h:td valign="top">Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">KDF-XOR</h:td>
								<h:td valign="top">More than one intermediary keys</h:td>
								<h:td valign="top">exclusive OR (XOR)</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> 128, 192, 256, 512] bits</h:td>
								<h:td valign="top">N/A</h:td>
							</h:tr>
						</h:table><h:p/>						
						There are no tests for this key derivation method. <h:p/>

						<!-- KDF by Encryting Keys -->
						<h:br/><h:b>KDF by Encrypting Keys</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Key Type</h:td>
								<h:td valign="top">Input Parameters</h:td>
								<h:td valign="top">Key Derivation Algorithm</h:td>
								<h:td valign="top">Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">KDF-ENC</h:td>
								<h:td valign="top">Two keys</h:td>
								<h:td valign="top">Encrypting using an algorithm specified in 
									[<h:b>selection:</h:b> FCS_COP.1/SKC,  FCS_COP.1/AEAD]</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> 128, 192, 256, 512] bits</h:td>
								<h:td valign="top">N/A</h:td>
							</h:tr>
						</h:table><h:p/>						
						Specific testing for this key derivation method is covered by testing for the
						supported symmetric encryption algorithms in FCS_COP.1/SKC or FCS_COP.1/AEAD.<h:p/>

						<!-- KDF by Hashing a Shared Secret -->
						<h:br/><h:b>KDF by Hashing a Shared Secret</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Key Type</h:td>
								<h:td valign="top">Input Parameters</h:td>
								<h:td valign="top">Key Derivation Algorithm</h:td>
								<h:td valign="top">Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">KDF-HASH</h:td>
								<h:td valign="top">Shared secret</h:td>
								<h:td valign="top">Hash function from FCS_COP.1/Hash</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> 128, 192, 256, 512] bits</h:td>
								<h:td valign="top">NIST SP 800-56C Revision 2 (Section 4.1, Option 1) 
									[One-Step Key Derivation]</h:td>
							</h:tr>
						</h:table><h:p/>						
						To test the TOE’s ability to derive cryptographic keys by hashing a shared 
						secret (a.k.a. One-Step HASH-based Key Derivation), the evaluator shall perform 
						the Algorithm Functional Test using the following input
						parameters:<h:ul>
						<h:li>Auxiliary Function [SHA-1, SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224,
							SHA-512/256, SHA3-224, SHA3-256, SHA3-384, SHA3-512]</h:li>
						<h:li>Derived key length [128, 192, 256, 512] bits</h:li></h:ul><h:p/>
						<h:br/><h:i><h:b>Algorithm Functional Test</h:b></h:i><h:br/>
						For each supported fixed information pattern and combination of the above input
						parameters the evaluator shall require the implementation under test to derive
						five keys using random data for a shared secret that is the same size as the 
						derived key. The evaluator shall compare the resulting keys with keys derived
						using a known-good implementation using the same fixed information patterns and
						input parameters.<h:p/>

						<!-- One-Step MAC-based KDF -->
						<h:br/><h:b>One-Step MAC-based KDF</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Key Type</h:td>
								<h:td valign="top">Input Parameters</h:td>
								<h:td valign="top">Key Derivation Algorithm</h:td>
								<h:td valign="top">Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">KDF-MAC-1S</h:td>
								<h:td valign="top">Shared secret, salt, output length, fixed information</h:td>
								<h:td valign="top">Keyed Hash function from FCS_COP.1/KeyedHash</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> 128, 192, 256, 512] bits</h:td>
								<h:td valign="top">NIST SP 800-56C Revision 2 (Section 4.1, Options 2, 3) 
									[One-Step Key Derivation]</h:td>
							</h:tr>
						</h:table><h:p/>			
						<comment>Catalog EA not finalized</comment>
						To test the TOE’s ability to derive cryptographic keys using One-Step
						MAC-based Key Derivation, the evaluator shall perform the Algorithm Functional
						Test using the following input parameters:<h:ul>
						<h:li>Auxiliary Function [HMAC-SHA-1, HMAC-SHA-224, HMAC-SHA-256, HMAC-SHA-384,
							HMAC-SHA-512, KMAC128, KMAC256, KMACXOF128, KMACXOF256]</h:li>
						<h:li>Salt [0s, random]</h:li>
						<h:li>Derived key length [128, 192, 256, 512] bits</h:li>
						<h:li>Fixed information pattern </h:li></h:ul><h:p/>		
						<h:br/><h:i><h:b>Algorithm Functional Test</h:b></h:i><h:br/>
						For each supported fixed information pattern and combination of the above input
						parameters the evaluator shall require the implementation under test to derive
						five keys using random data for a shared secret. The evaluator shall compare 
						the resulting keys with keys derived using a known-good implementation using the 
						same fixed information patterns and input parameters.<h:p/>

						<!-- Two-Step MAC-based KDF -->
						<h:br/><h:b>Two-Step MAC-based KDF</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Key Type</h:td>
								<h:td valign="top">Input Parameters</h:td>
								<h:td valign="top">Key Derivation Algorithm</h:td>
								<h:td valign="top">Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">KDF-MAC-2S</h:td>
								<h:td valign="top">Shared secret, salt, IV, output length, fixed information</h:td>
								<h:td valign="top">MAC Step [<h:b>selection:</h:b> 
									AES-128-CMAC; AES-192-CMAC; AES-256-CMAC; 
									Camellia-128-CMAC; Camellia-192-CMAC; Camellia-256-CMAC;
									HMAC-SHA-1; HMAC-SHA-256; HMAC-SHA-512] as randomness extraction and; 
									KDF Step [<h:b>selection:</h:b> 
									KDF-CTR, KDF-FB, KDF-DPI] using [<h:b>selection:</h:b> 
									AES-128-CMAC; AES-192-CMAC; AES-256-CMAC; 
									Camellia-128-CMAC; Camellia-192-CMAC; Camellia-256-CMAC;
									HMAC-SHA-1; HMAC-SHA-256; HMAC-SHA-512] as PRF</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> 128, 192, 256, 512] bits</h:td>
								<h:td valign="top">NIST SP 800-56C Revision 2 (Section 5) [Two-Step Key Derivation]</h:td>
							</h:tr>
						</h:table><h:p/>			
						<comment>Catalog EA not finalized</comment>
						To test the TOE’s ability to derive cryptographic keys using Two-Step MAC-based
						Key Derivation, the evaluator shall perform the Algorithm Functional Test using the following input parameters:<h:ul>
						<h:li>MAC mode [AES-128-CMAC; AES-192-CMAC; AES-256-CMAC; Camellia-128-CMAC;
							Camellia-192-CMAC; Camellia-256-CMAC; HMAC-SHA-1; HMAC-SHA-256; HMAC-SHA-512]</h:li>
						<h:li>KDF Mode [Counter, feedback, Double Pipeline iteration]</h:li>
						<h:li>Salt [0s, random]</h:li>
						<h:li>Length of shared secret [224-65535]</h:li>
						<h:li>Hybrid shared secret ???, aux Shared Secret length??</h:li>
						<h:li>Derived key length [128, 192, 256, 512] bits</h:li>
						<h:li>Fixed information pattern </h:li>
						<h:li>Counter location [none, before fixed data, after fixed data, before iterator]</h:li>
						<h:li>Counter length [0, 8, 16, 24, 32]</h:li></h:ul><h:p/>		
						<h:br/><h:i><h:b>Algorithm Functional Test</h:b></h:i><h:br/>
						For each supported fixed information pattern and combination of the above input 
						parameters the evaluator shall require the implementation under test to derive 
						five keys using random data for a shared secret. The evaluator shall compare the
						resulting keys with keys derived using a known-good implementation using the 
						same fixed information patterns and input parameters.<h:p/>

						<!-- KMAC KDF -->
						<h:br/><h:b>KMAC KDF</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Key Type</h:td>
								<h:td valign="top">Input Parameters</h:td>
								<h:td valign="top">Key Derivation Algorithm</h:td>
								<h:td valign="top">Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">KDF-KMAC</h:td>
								<h:td valign="top">Key, context string, output length, label</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> KMAC128, KMAC256]</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> 128, 192, 256, 512] bits</h:td>
								<h:td valign="top">NIST SP 800-108 Revision 1 Update 1 (Section 4.4 “KDF Using KMAC”)</h:td>
							</h:tr>
						</h:table><h:p/>			
						To test the TOE’s ability to derive cryptographic keys using KMAC Key Derivation, the evaluator shall
						perform the Algorithm Functional Test using the following input parameters:<h:ul>
						<h:li>MAC Function [KMAC128, KMAC256]</h:li>
						<h:li>Key Derivation Key Length [112-4096 by 8] bits</h:li>
						<h:li>Context length [8-4096 by 8] bits</h:li>
						<h:li>Label length [8-4096 by 8] bits</h:li>
						<h:li>Derived key length [128, 192, 256, 512] bits</h:li></h:ul><h:p/>
					
						<h:br/><h:i><h:b>Algorithm Functional Test</h:b></h:i><h:br/>
						For each supported MAC function [KMAC128, KMAC256], for each supported minimum and maximum key
						length:<h:p/>
						Generate 50 test cases using random data for Key Derivation Key, Context, and 
						Label. The length of each derived key shall be randomly selected from all 
						supported values such that the minimum and maximum lengths are chosen once each.
						The evaluator shall compare the resulting derived keys with keys derived using 
						a known-good implementation using the same input parameters.<h:p/>
					</Tests>
				</aactivity>
			</f-element>
						<audit-event/>
					</f-component>
				</section>   <!-- FCS_CKM.5 -->


				<section title="FCS_CKM.6 Timing and Event of Cryptographic Key Destruction" id="catsec-fcs-ckm-6">
					
					<!-- FCS_CKM.6 Timing and Event of Cryptographic Key Destruction -->
					<f-component id="sfr-fcs-ckm-6" cc-id="fcs_ckm.6" name="Timing and Event of Cryptographic Key Destruction">

						<comp-rel>
							<hierarchical-to/>
							<dependencies-to>
								<or-dep>
									<comp-ref>FDP_ITC.1 Import of user data without security attributes</comp-ref> 
									<comp-ref>FDP_ITC.2 Import of user data with security attributes</comp-ref> 
									<comp-ref>FCS_CKM.1 Cryptographic key generation</comp-ref>
									<comp-ref>FCS_CKM_EXT.3 Cryptographic key access</comp-ref>
									<comp-ref>FCS_CKM.5 Cryptographic key derivation</comp-ref>
									<comp-ref>FCS_CKM_EXT.7 Cryptographic key agreement</comp-ref>
									<comp-ref>FCS_CKM_EXT.8 Password-based key derivation</comp-ref>
								</or-dep>
							</dependencies-to>
						</comp-rel>

						<f-element id="fcs-ckm-6e1">
							<title>
								The TSF shall destroy <assignable>list of cryptographic keys (including keying 
								material)</assignable> when <selectables>
									<selectable>no longer needed</selectable>
									<selectable><assignable>other circumstances for key or keying material destruction</assignable>
									</selectable></selectables>
							</title>
							<note role="application">
								<comment>From catalog</comment>The TOE will have mechanisms to destroy keys, including intermediate keys and key material, by using
								an approved method as specified in FCS_CKM.6.2.  Examples of keys include intermediate keys, leaf keys, 
								encryption keys, and signing keys.  Key material includes seeds, authentication secrets, passwords, 
								PINs, and other secret values used to derive keys.  The ST Author shall list all such keys and keying
								material that are subject to destruction in the first assignment.<h:p/>
			 
								This SFR does not apply to the public component of asymmetric key pairs or to keys that are permitted
								to remain stored, such as device identification keys. 
							</note>
							
						</f-element>
						<f-element id="fcs-ckm-6e2">
							<title>The TSF shall destroy cryptographic keys and keying material specified by FCS_CKM.6.1 in accordance
								with a specified cryptographic key destruction method [<h:i>
								<h:ul><h:li>For volatile memory, the destruction shall be executed by a 
									<selectables linebreak="yes">
										<selectable>single overwrite consisting of 
											<selectables onlyone="yes">
												<selectable>a pseudo-random pattern using the TSF’s RBG</selectable>
												<selectable>zeroes</selectable>
												<selectable>ones</selectable>
												<selectable>a new value of a key</selectable>
												<selectable><assignable>some value that does not contain any CSP</assignable></selectable>
											</selectables></selectable>
										<selectable>removal of power to the memory</selectable>
										<selectable>removal of all references to the key directly followed by a request for garbage
											collection</selectable>
									</selectables></h:li>
									<h:li>For non-volatile memory 
									<selectables linebreak="yes">
										<selectable>that employs a wear-leveling algorithm, the destruction shall be executed by a
											<selectables>
												<selectable>single overwrite consisting of 
													<selectables onlyone="yes">
														<selectable>zeroes</selectable>
														<selectable>ones</selectable>
														<selectable>pseudo-random pattern</selectable>
														<selectable>a new value of a key of the same size</selectable>
														<selectable><assignable>some value that does not contain any CSP</assignable></selectable>
													</selectables></selectable>
												<selectable>block erase</selectable>
											</selectables></selectable>
										<selectable>that does not employ a wear-leveling algorithm, the destruction shall be executed by a
											<selectables linebreak="yes">
												<selectable>
													<selectables onlyone="yes">
														<selectable>single</selectable>
														<selectable><assignable>ST Author-defined multi-pass</assignable></selectable>
													</selectables> overwrite consisting of 
													<selectables>
														<selectable>zeros</selectable>
														<selectable>ones</selectable>
														<selectable>pseudo-random pattern</selectable>
														<selectable>a new value of a key of the same size</selectable>
														<selectable><assignable>some value that does not contain any CSP</assignable></selectable>
													</selectables> followed by a read-verify. If the read-verification of the overwritten data fails,
													the process shall be repeated again up to <assignable>number of times to attempt overwrite</assignable> times, 
													whereupon an error is returned</selectable>
												<selectable>block erase</selectable>
											</selectables></selectable>
									</selectables></h:li></h:ul></h:i>]
								that meets the following: [<h:i>no standard</h:i>].
							</title>
							<note role="application">
								This SFR must be included in the ST if the TOE handles sensitive cryptographic keys or credentials.
								In particular, if the TOE creates or stores keys, it must be able to destroy them. Specifically, this SFR
								must be included in the ST if any of the following SFRs are claimed: FCS_CKM.1/AKG, FCS_CKM.1/SKG,
								FCS_CKM.2, FCS_CKM_EXT.5, FCS_COP.1/KAT, FCS_STG_EXT.1, or FIA_AFL_EXT.1<h:p/>
								The term “cryptographic keys” in this SFR includes
								the authorization data that is the entry point to a key chain and all other cryptographic keys and
								keying material (whether in plaintext or encrypted form). Examples of keys and key material include intermediate keys, 
								encryption keys, signing keys, verification keys, authentication tokens, and submasks.
								This SFR does not apply to the public
								component of asymmetric key pairs, or to keys that are permitted to remain stored such as device
								identification keys. The TOE will have mechanisms to destroy keys and key material when the keys and key material is 
								no longer needed. Based on their implementations, vendors will explain when certain keys are no longer needed.<h:p/>
								In the case of volatile memory, the selection “<h:i>removal of all references to the key directly followed
								by a request for garbage collection</h:i>” is used in a situation where the TSF cannot address the
								specific physical memory locations holding the data to be erased and therefore relies on
								addressing logical addresses (which frees the relevant physical addresses holding the old data)
								and then requesting the platform to ensure that the data in the physical addresses is no longer
								available for reading (i.e. the “garbage collection” referred to in the SFR text).<h:p/>
								The selection for destruction of data in non-volatile memory includes block erase as an option,
								and this option applies only to flash memory. A block erase does not require a read verify, since 
								the mappings of logical addresses to the erased memory locations are erased as well as the data
								itself.<h:p/>
								Some selections allow assignment of “some value that does not contain any CSP.” This means
								that the TOE uses some specified data not drawn from an RBG meeting FCS_RBG
								requirements, and not being any of the particular values listed as other selection options. The point
								of the phrase “does not contain any sensitive data” is to ensure that the overwritten data is
								carefully selected, and not taken from a general pool that might contain current or residual data
								that itself requires confidentiality protection.<h:p/>
								<h:p/>
								<comment>From crypto catalog</comment>In the case of volatile memory, the selection “removal of all references to the key directly followed 
								by a request for garbage collection” is used in a situation where the TSF cannot address the specific 
								physical memory locations holding the data to be erased and therefore relies on addressing logical 
								addresses (which frees the relevant physical addresses holding the old data) and then requesting the 
								platform to ensure that the data in the physical addresses is no longer available for reading (i.e. 
								the “garbage collection” referred to in the SFR text). <h:p/>

								The selection for destruction of data in non-volatile memory includes block erase as an option, and 
								this option applies only to flash memory.  A block erase does not require a read verify, since the
								mappings of logical addresses to the erased memory locations are erased, as well as the data itself.<h:p/>

								Some selections allow the assignment of “some value that does not contain any CSP.” This means that 
								the TOE uses some specified data not drawn from an RBG meeting FCS_RBG requirements, and not being 
								any of the values listed as other selection options.  The point of the phrase “does not contain any 
								CSP” is to ensure that the overwritten data is carefully selected, and not taken from a general pool 
								that might contain data that itself requires confidentiality protection. 
							</note>
							<aactivity>
								<TSS>
									The evaluator shall examine the TSS to ensure it lists all relevant keys and keying
									material (describing the source of the data, all memory types in which the data is
									stored (covering storage both during and outside of a session, and both plaintext and
									non-plaintext forms of the data)), all relevant destruction situations (including the
									point in time at which the destruction occurs; e.g. factory reset or device wipe
									function, change of authorization data, change of DEK, completion of use of an
									intermediate key) and the destruction method used in each case. The evaluator shall
									confirm that the description of the data and storage locations is consistent with the
									functions carried out by the TOE (e.g. that all keys in the key chain are accounted
									for). (Where keys are stored encrypted or wrapped under another key then this may need to
									be explained in order to allow the evaluator to confirm the consistency of the description 
									of keys with the TOE functions). <h:p/>
									The evaluator shall check that the TSS identifies any configurations or
									circumstances that may not conform to the key destruction requirement (see further
									discussion in the AGD section below). Note that reference may be made to the AGD
									for description of the detail of such cases where destruction may be prevented or
									delayed.<h:p/>
									Where the ST specifies the use of “a value that does not contain any sensitive data”
									to overwrite keys, the evaluator shall examine the TSS to ensure that it describes
									how that pattern is obtained and used, and that this justifies the claim that the pattern
									does not contain any sensitive data.
								</TSS>
								<Guidance>
									A TOE may be subject to situations that could prevent or delay data destruction in
									some cases. The evaluator shall check that the AGD identifies
									configurations or circumstances that may not strictly conform to the key destruction
									requirement, and that this description is consistent with the relevant parts of the TSS
									(and KMD). The evaluator shall check that the AGD provides
									guidance on situations where key destruction may be delayed at the physical layer,
									identifying any additional mitigation actions for the user (e.g. there might be some
									operation the user can invoke, or the user might be advised to retain control of the
									device for some particular time to maximize the probability that garbage collection
									has occurred).<h:p/>
									For example, when the TOE does not have full access to the physical memory, it is
									possible that the storage may implement wear-leveling and garbage collection. This
									may result in additional copies of the data that are logically inaccessible but persist
									physically. Where available, the TOE might then describe use of the TRIM
									command	and garbage collection to destroy these persistent copies upon their
									deletion (this would be explained in TSS and AGD). <h:p/>
									Where TRIM is used then the TSS or AGD is also expected to describe how
									the keys are stored such that they are not inaccessible to TRIM, (e.g. they would need not
									to be contained in a file less than 982 bytes which would be completely contained in the
									master file table.
								</Guidance>
								<KMD>
									The evaluator shall examine the KMD to verify that it identifies and describes the
									interfaces that are used to service commands to read/write memory. The evaluator
									shall examine the interface description for each different media type to ensure that
									the interface supports the selections made by the ST Author.<h:p/>
									The evaluator shall examine the KMD to ensure that all keys and keying material
									identified in the TSS and KMD have been accounted for.<h:p/>
									Note that where selections include "<h:i>destruction of reference to the key directly
									followed by a request for garbage collection</h:i>" (for volatile memory) then the
									evaluator shall examine the KMD to ensure that it explains the nature of the
									destruction of the reference, the request for garbage collection, and of the garbage
									collection process itself.
								</KMD>
								<Tests>
									The following tests require the developer to provide access to a test platform that
									provides the evaluator with tools that are typically not found on factory products.<h:p/>
									The evaluator shall perform the following tests:
									<testlist>
										<test>
											Applied to each key or keying material held as plaintext in volatile
											memory and subject to destruction by overwrite by the TOE (whether or not the
											plaintext value is subsequently encrypted for storage in volatile or non-volatile
											memory).<h:p/>
											The evaluator shall:<h:ol type="1">
											<h:li>Record the value of the key or keying material.</h:li>
											<h:li>Cause the TOE to dump the SDO/SDE memory of the TOE into a binary file.</h:li>
											<h:li>Search the content of the binary file created in Step #2 to locate all
												instances of the known key value from Step #1.<h:p/>
												Note that the primary purpose of Step #3 is to demonstrate that appropriate
												search commands are being used for Steps #8 and #9.</h:li>
											<h:li>Cause the TOE to perform normal cryptographic processing with the key
												from Step #1.</h:li>
											<h:li>Cause the TOE to destroy the key.</h:li>
											<h:li>Cause the TOE to stop execution but not exit.</h:li>
											<h:li>Cause the TOE to dump the SDO/SDE memory of the TOE into a binary
												file.</h:li>
											<h:li>Search the content of the binary file created in Step #7 for instances of the
												known key value from Step #1.</h:li>
											<h:li>Break the key value from Step #1 into an evaluator-chosen set of
												fragments and perform a search using each fragment. (Note that the
												evaluator shall first confirm with the developer how the key is normally
												stored, in order to choose fragment sizes that are the same or smaller than
												any fragmentation of the data that may be implemented by the TOE. The
												endianness or byte-order should also be taken into account in the search.)</h:li>
											</h:ol><h:p/>
											Steps #1-8 ensure that the complete key does not exist anywhere in volatile
											memory. If a copy is found, then the test fails.<h:p/>
											Step #9 ensures that partial key fragments do not remain in memory. If the
											evaluator finds a 32-or-greater-consecutive-bit fragment, then fail immediately.
											Otherwise, there is a chance that it is not within the context of a key (e.g., some
											random bits that happen to match). If this is the case the test should be repeated
											with a different key in Step #1. If a fragment is also found in this repeated run,
											then the test fails unless the developer provides a reasonable explanation for the
											collision, then the evaluator may give a pass on this test.<h:p/>
										</test>
										<test>
											Applied to each key and keying material held in non-volatile memory and
											subject to destruction by overwrite by the TOE.<h:ol type="1">
											<h:li>Record the value of the key or keying material.</h:li>
											<h:li>Cause the TOE to perform normal cryptographic processing with the key
												from Step #1.</h:li>
											<h:li>Search the non-volatile memory the key was stored in for instances of the
												known key value from Step #1. <h:p/>
												Note that the primary purpose of Step #3 is to demonstrate that appropriate
												search commands are being used for Steps #5 and #6.</h:li>
											<h:li>Cause the TOE to clear the key.</h:li>
											<h:li>Search the non-volatile memory in which the key was stored for instances
												of the known key value from Step #1. If a copy is found, then the test fails.</h:li>
											<h:li>Break the key value from Step #1 into an evaluator-chosen set of
												fragments and perform a search using each fragment. (Note that the
												evaluator shall first confirm with the developer how the key is normally
												stored, in order to choose fragment sizes that are the same or smaller than
												any fragmentation of the data that may be implemented by the TOE. The
												endianness or byte-order should also be taken into account in the search).</h:li>
											</h:ol>
											Step #6 ensures that partial key fragments do not remain in non-volatile memory.
											If the evaluator finds a 32-or-greater-consecutive-bit fragment, then fail
											immediately. Otherwise, there is a chance that it is not within the context of a key
											(e.g., some random bits that happen to match). If this is the case the test should be
											repeated with a different key in Step #1. If a fragment is also found in this
											repeated run, then the test fails unless the developer provides a reasonable
											explanation for the collision, then the evaluator may give a pass on this test.<h:p/>
										</test>
										<test>
											Applied to each key and keying material held in non-volatile memory and
											subject to destruction by overwrite by the TOE.<h:ol type="1">
											<h:li>Record memory of the key or keying material.</h:li>
											<h:li>Cause the TOE to perform normal cryptographic processing with the key
												from Step #1.</h:li>
											<h:li>Cause the TOE to clear the key. Record the value to be used for the
												overwrite of the key. </h:li>
											<h:li>Examine the memory from Step #1 to ensure the appropriate pattern
												(recorded in Step #3) is used. </h:li>
											</h:ol>
											The test succeeds if correct pattern is found in the memory location. If the pattern
											is not found, then the test fails.
										</test>
									</testlist>
								</Tests>
							</aactivity>
						</f-element>
						<audit-event/>
					</f-component>
				</section>  <!-- FCS_CKM.6 -->

				<section title="FCS_CKM_EXT.7 Cryptographic Key Agreement " id="catsec-fcs-ckm-ext-7">

					<h:b>Catalog Guidance Notes</h:b><h:p/>
						This component contains methods for multi-party key agreement in which two or more parties
						contribute material used to derive the shared key used by each party to encrypt and decrypt
						incoming and outgoing messages. TOEs can use the keys as symmetric keys, keyed-hash keys, or
						cryptographic keys for key derivation functions.    			

					<!-- FCS_CKM_EXT.7 Cryptographic Key Agreement -->
					<f-component id="sfr-fcs-ckm-ext-7" cc-id="fcs_ckm_ext.7" name="Cryptographic Key Agreement">

						<ecd-info>
							<comp-lev> requires cryptographic keys to be derived and shared between multiple
								parties in accordance with a specified multi-party key derivation
								method which can be based on an assigned standard. 
							</comp-lev>
							<manageable-actions/>
							<auditable-actions>
								<action-descr>minimal: Success and failure of the activity;</action-descr>
								<action-descr>basic: The object attribute(s), and object value(s) excluding 
									any sensitive information.</action-descr>
							</auditable-actions>
						</ecd-info>

						<comp-rel>
							<hierarchical-to/>
							<dependencies-to>
								<or-dep>
									<comp-ref>FDP_ITC.1 Import of user data without security attributes</comp-ref> 
									<comp-ref>FDP_ITC.2 Import of user data with security attributes</comp-ref> 
									<comp-ref>FCS_CKM.1 Cryptographic key generation</comp-ref>
									<comp-ref>FCS_CKM.5 Cryptographic key derivation</comp-ref>
									<comp-ref>FCS_CKM_EXT.8 Password-based key derivation</comp-ref>
								</or-dep>
								<or-dep>
									<comp-ref>FCS_CKM.2 Cryptographic key distribution</comp-ref> 
									<comp-ref>FCS_COP.1 Cryptographic operation</comp-ref> 
								</or-dep>
								<comp-ref>FCS_CKM.6 Timing and event of cryptographic key destruction</comp-ref> 
								<or-dep>
									<comp-ref>FCS_COP.1/AEAD Authenticated encryption with associated data</comp-ref>
									<comp-ref>FCS_COP.1/CMAC CMAC</comp-ref>
									<comp-ref>FCS_COP.1/Hash Hashing</comp-ref>
									<comp-ref>FCS_COP.1/KeyedHash, Keyed Hashing</comp-ref>
									<comp-ref>FCS_COP.1/SKC Symmetric Key Cryptography</comp-ref>
									<comp-ref>no other dependencies</comp-ref>									
								</or-dep>
							</dependencies-to>
						</comp-rel>

			<f-element id="fcs-ckm-ext-7e1">
				<title>
					The TSF shall derive shared cryptographic keys with input from multiple parties in accordance 
					with specified cryptographic key agreement algorithms  
					<selectables>
						<tabularize id="fcs-ckm-ext-7-sels" 
							    title="Recommended choices for FCS_CKM_EXT.7">
							<textcol>Identifier</textcol>
							<selectcol>Cryptographic algorithm</selectcol>
							<reqtext>and specified cryptographic parameters</reqtext>
							<selectcol>Cryptographic parameters</selectcol>
							<reqtext>that meet the following:</reqtext>
							<selectcol>List of standards</selectcol>
							<reqtext><h:p/><h:p/>The following table provides the recommended choices for
										completion of the selection operations of FCS_CKM_EXT.7.</reqtext>
						</tabularize>

						<selectable id="sel-fcs-ckm-kat-kas2">
							<col>KAS2</col>
							<col>RSA</col>
							<col>Modulus size <selectables>
								<selectable>2048</selectable>
								<selectable>3072</selectable>
								<selectable>4096</selectable>
								<selectable>6144</selectable>
								<selectable>8192</selectable>
							</selectables> bits</col>
							<col>NIST SP 800-56B Revision 2 (Section 8.3) [KAS2]</col>
						</selectable>

						<selectable id="sel-fcs-ckm-kat-dh">
							<col>DH</col>
							<col>Finite Field Cryptography Diffie-Hellman</col>
							<col>Static domain parameters approved for <selectables>
								<selectable>IKE Groups <selectables>
									<selectable id="sel-kat-ffc-modp2048">MODP-2048</selectable>
									<selectable id="sel-kat-ffc-modp3072">MODP-3072</selectable>
									<selectable id="sel-kat-ffc-modp4096">MODP-4096</selectable>
									<selectable id="sel-kat-ffc-modp6144">MODP-6144</selectable>
									<selectable id="sel-kat-ffc-modp8192">MODP-8192</selectable>
								</selectables></selectable>
								<selectable>TLS Groups <selectables>
									<selectable id="sel-kat-ffc-ffdhe2048">ffdhe2048</selectable>
									<selectable id="sel-kat-ffc-ffdhe3072">ffdhe3072</selectable>
									<selectable id="sel-kat-ffc-ffdhe4096">ffdhe4096</selectable>
									<selectable id="sel-kat-ffc-ffdhe6144">ffdhe6144</selectable>
									<selectable id="sel-kat-ffc-ffdhe8192">ffdhe8192</selectable>
								</selectables></selectable></selectables>
							</col>
							<col>
								NIST SP 800-56A Revision 3 (Section 5.7.1.1) [DH]<h:p/>
								<selectables>
								<selectable>RFC 3526 [IKE groups]</selectable>
								<selectable>RFC 7919 [TLS groups]</selectable></selectables>
							</col>
						</selectable>

						<selectable id="sel-fcs-ckm-kat-ecdh">
							<col>ECDH</col>
							<col>Elliptic Curve Diffie-Hellman</col>
							<col>Elliptic Curve <selectables>
								<selectable id="sel-exp-kat-ecdh-P256">P-256</selectable>
								<selectable id="sel-exp-kat-ecdh-brainpoolP256r1">brainpoolP256r1</selectable>
								<selectable id="sel-exp-kat-ecdh-P384">P-384</selectable>
								<selectable id="sel-exp-kat-ecdh-brainpoolP384r1">brainpoolP384r1</selectable>
								<selectable id="sel-exp-kat-ecdh-P521">P-521</selectable>
								<selectable id="sel-exp-kat-ecdh-brainpoolP512r1">brainpoolP512r1</selectable></selectables>
							</col>
							<col>
								NIST SP 800-56A Revision 3 (Section 5.7.1.2) [ECDH]<h:p/>
								<selectables>
								<selectable>: NIST SP 800-186 (Section 3.2.1) [NIST Curves]</selectable>
								<selectable>RFC 5639 (Section 3) [Brainpool curves]</selectable></selectables>
							</col>
						</selectable>

						<selectable id="sel-fcs-ckm-kat-eddsa">
							<col>ECDH-Ed</col>
							<col>ECDH with Montgomery Curves</col>
							<col>Domain parameters approved for elliptic curves 
								<selectables>
								<selectable>curve25519</selectable>
								<selectable>curve448</selectable></selectables>
							</col>
							<col>
								RFC 7748 (Section 5) [ECDH-Ed]<h:p/>
								NIST SP 800-186 (Section 3.2.2) [Montgomery Curves]
							</col>
						</selectable>

					</selectables>
				</title>
				<note role="application">
					This SFR must be included in the ST if key agreement or transport is a service provided by the TOE to 
					tenant software, or if they are used by the TOE itself to support or implement PP-specified security 
					functionality.<h:p/> 
					If this SFR is claimed, then FCS_CKM.6 must also be claimed.<h:p/>
					This SFR has dependencies FCS_COP.1/Hash and FCS_COP.1/XOF only if ML-KEM is selected.
				</note>
				<aactivity>
					<TSS>
						The evaluator shall ensure that the TSS documents that the security strength of the
						material contributed by the TOE is sufficient for the security strength of the key and the
						agreement method.
					</TSS>
					<Guidance>TBD</Guidance>
					<Tests>
						The following tests are conditional based upon the selections made in the SFR.
						The evaluator shall perform the following test or witness respective tests
						executed by the developer. The tests must be executed on a platform that is as 
						close as practically possible to the operational platform (but which may be 
						instrumented in terms of, for example, use of a debug mode). Where the test is 
						not carried out on the TOE itself, the test platform shall be identified and the 
						differences between test environment and TOE execution environment shall be 
						described.<h:p/>
					
						<!-- KAS2 -->
						<h:br/><h:b>KAS2</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Algorithm</h:td>
								<h:td valign="top">Cryptographic Parameters</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">KAS2</h:td>
								<h:td valign="top">RSA</h:td>
								<h:td valign="top">Modulus Size [<h:b>selection:</h:b> 2048, 3072, 4096,
									6144, 8192] bits</h:td>
								<h:td valign="top">NIST SP 800-56B Revision 2 (Section 8.3) [KAS2]</h:td>
							</h:tr>
						</h:table><h:p/>						
						To test the TOE’s implementation of the of the KAS2 RSA Key Agreement scheme, the evaluator
						shall perform the Algorithm Functional Test and Validation Test using the 
						following input parameters:<h:ul>
						<h:li>RSA Private key format [Basic, Prime Factor, Chinese Remainder Theorem]</h:li>
						<h:li>Modulo value [2048, 3072, 4096, 6144, 8192]</h:li>
						<h:li>Role [initiator, responder]</h:li></h:ul><h:p/>
						The evaluator shall generate a test group (i.e. set of tests) for each parameter
						value of the above parameter type with the largest number of supported values.
						For example, if the TOE supports all five Modulo values, then the evaluator 
						shall generate five test groups. Each of the above supported parameter values
						must be included in at least one test group.<h:p/>
						Regardless of how many parameter values are supported, there must be at least two 
						test groups.<h:p/>
						Half of the test groups are designated as Algorithm Functional Tests (AFT) and the 
						remainder are designated as Validation Tests (VAT). If there is an odd number of 
						groups, then the extra group is designated randomly as either AFT or VAT.<h:p/>
						<h:br/><h:i><h:b>Algorithm Functional Test</h:b></h:i><h:br/>
						For each test group designated as AFT, the evaluator shall generate 10 test 
						cases using random data (except for a fixed public exponent, if supported). 
						The resulting shared secrets shall be compared with those generated by a 
						known-good implementation using the same inputs.<h:p/>
						<h:br/><h:i><h:b>Validation Test</h:b></h:i><h:br/>
						For each test group designated as VAT, the evaluator shall generate 25 test cases are
						using random data (except for a fixed public exponent, if supported). Of the 25
						test cases:<h:ul>
						<h:li>Two test cases must have a shared secret with a leading nibble of 0s,</h:li>
						<h:li>Two test cases have modified derived key material,</h:li>
						<h:li>Two test cases have modified tags, if key confirmation is supported,</h:li>
						<h:li>Two test cases have modified MACs, if key confirmation is supported, and</h:li>
						<h:li>The remaining test cases are not modified.</h:li></h:ul><h:p/>
						To determine correctness, the evaluator shall confirm that the resulting 25 shared 
						secrets correspond as expected for both the modified and unmodified values.<h:p/>
					
						<!-- FFC Diffie-Hellman Key Agreement -->
						<h:br/><h:b>FFC Diffie-Hellman Key Agreement</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Algorithm</h:td>
								<h:td valign="top">Cryptographic Parameters</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">DH</h:td>
								<h:td valign="top">Finite Field Cryptography Diffie-Hellman</h:td>
								<h:td valign="top">Static domain parameters approved for [<h:b>selection:</h:b>
									IKE groups [<h:b>selection:</h:b> MODP-2048, MODP-3072, MODP-4096,
									MODP-6144, MODP-8192], TLS groups [<h:b>selection:</h:b> ffdhe2048, 
									ffdhe3072, ffdhe4096, ffdhe6144, ffdhe8192]]]</h:td>
								<h:td valign="top">NIST SP 800-56A Revision 3 (Section 5.7.1.1) [DH]<h:p/>
									[<h:b>selection:</h:b> RFC 3526 [IKE Groups], RFC 7919 [TLS Groups]]</h:td>
							</h:tr>
						</h:table><h:p/>						
						To test the TOE’s implementation of FFC Diffie-Hellman Key Agreement, the evaluator shall
						perform the Algorithm Functional Test and Validation Test using the following 
						input parameters:<h:ul>
						<h:li>Domain Parameter Group [MODP-2048, MODP-3072, MODP-4096, MODP-6144, MODP-8192, ffdhe2048,
							ffdhe3072, ffdhe4096, ffdhe6144, ffdhe8192]</h:li></h:ul><h:p/>
						<h:br/><h:i><h:b>Algorithm Functional Test</h:b></h:i><h:br/>
						For each supported domain parameter group, the evaluator shall generate 10 test
						cases by generating the initiator and responder secret keys using random data,
						calculating the responder public key, and creating the shared secret. The 
						resulting shared secrets shall be compared with those generated by a known-good 
						implementation using the same inputs.<h:p/>
						<h:br/><h:i><h:b>Validation Test</h:b></h:i><h:br/>
						For each supported combination of the above parameters the evaluator shall
						generate 15 Diffie Hellman initiator/responder key pairs using the key generation
						function of a known-good implementation. For each set of key pairs, the 
						evaluator shall modify five initiator private key values. The remaining key
						values are left unchanged (i.e., correct). To determine correctness, the 
						evaluator shall confirm that the 15 shared secrets correspond as expected for 
						both the modified and unmodified inputs.<h:p/>

						<!-- Elliptic Curve Diffie-Hellman Key Agreement -->
						<h:br/><h:b>Elliptic Curve Diffie-Hellman Key Agreement</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Algorithm</h:td>
								<h:td valign="top">Cryptographic Parameters</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">ECDH</h:td>
								<h:td valign="top">Elliptic Curve Diffie-Hellman</h:td>
								<h:td valign="top">Elliptic Curve [<h:b>selection:</h:b> P-256, brainpoolP256r1,
									P-384, brainpoolP384r1, P-521, brainpoolP512r1]</h:td>
								<h:td valign="top">NIST SP 800-56A Revision 3 (Section 5.7.1.2) [ECDH]<h:p/>
									[<h:b>selection:</h:b> NIST SP 800-186 (Section 3.2.1) [NIST Curves],
										RFC 5639 (Section 3) [Brainpool Curves]]</h:td>
							</h:tr>
						</h:table><h:p/>						
						To test the TOE’s implementation of Elliptic Curve Diffie-Hellman Key Agreement,
						the evaluator shall perform the Algorithm Functional Test and Validation Test 
						using the following input parameters:<h:ul>
						<h:li>Elliptic Curve [P-256, brainpoolP256r1, P-384, brainpoolP384r1, P-521, brainpoolP512r1]</h:li></h:ul><h:p/>
						<h:br/><h:i><h:b>Algorithm Functional Test</h:b></h:i><h:br/>
						For each supported Elliptic Curve the evaluator shall generate 10 test cases by
						generating the initiator and responder secret keys using random data, calculating 
						the responder public key, and creating the shared secret. The resulting shared 
						secrets shall be compared with those generated by a known-good implementation using
						the same inputs.<h:p/>
						<h:br/><h:i><h:b>Validation Test</h:b></h:i><h:br/>
						For each supported Elliptic Curve the evaluator shall generate 15 Diffie Hellman
						initiator/responder key pairs using the key generation function of a known-good 
						implementation. For each set of key pairs, the evaluator shall modify five 
						initiator private key values. The remaining key values are left unchanged (i.e.,
						correct). To determine correctness, the evaluator shall confirm that the 15 
						shared secrets correspond as expected for the modified and unmodified values.<h:p/>
					
						<!-- Elliptic Curve Diffie-Hellman Key Agreement with Montgomery Curves -->
						<h:br/><h:b>Elliptic Curve Diffie-Hellman Key Agreement with Montgomery Curves</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Algorithm</h:td>
								<h:td valign="top">Cryptographic Parameters</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">ECDH-Ed</h:td>
								<h:td valign="top">ECDH with Montgomery Curves</h:td>
								<h:td valign="top">Domain parameters approved for elliptic curves
									[<h:b>selection:</h:b> curve25519, curve448]</h:td>
								<h:td valign="top">RFC 7748 (Section 5) [ECDH-Ed]<h:p/>
									NIST SP 800-186 (Section 3.2.2) [Montgomery Curves]</h:td>
							</h:tr>
						</h:table><h:p/>						
						To test the TOE’s implementation of Elliptic Curve Diffie-Hellman Key Agreement
						with Montgomery Curves, the evaluator shall perform the Algorithm Functional
						Test and Validation Test using the following input parameters:<h:ul>
						<h:li>-	Domain Parameters for elliptic curves [curve25519, curve448]</h:li></h:ul><h:p/>
						<h:br/><h:i><h:b>Algorithm Functional Test</h:b></h:i><h:br/>
						For each supported set of domain parameters, the evaluator shall generate 10 
						test cases by generating the initiator and responder secret keys using random 
						data, calculating the responder public key, and creating the shared secret. The 
						resulting shared secrets shall be compared with those generated by a known-good
						implementation using the same inputs<h:p/>
						<h:br/><h:i><h:b>Validation Test</h:b></h:i><h:br/>
						For each supported combination of the above parameters the evaluator shall
						generate 15 Diffie Hellman initiator/responder key pairs using the key 
						generation function of a known-good implementation. For each set of key pairs,
						modify five initiator private keys values. The remaining key values are left
						unchanged (i.e., correct). To determine correctness, the evaluator shall confirm
						that the 15 shared secrets correspond as expected for the modified and unmodified
						values.<h:p/>

					</Tests>
				</aactivity>
			</f-element>
						<audit-event/>
					</f-component>
				</section>  <!-- FCS_CKM_EXT.7 -->

				<section title="FCS_CKM_EXT.8 Password-Based Key Derivation " id="catsec-fcs-ckm-ext-8">

					<h:b>Catalog Guidance Notes</h:b><h:p/>
						Password-based key derivation is different from regular key derivation in that passwords have
						very limited entropy. As a result, one must add additional constraints, work, or entropy to
						achieve acceptable levels of security when using password-based key derivation algorithms.
						This component only adds work through increased iterations and use of salts; it does not
						consider additional constraints or entropy.  <h:p/>
						This component may also be used to condition passwords in the context of password-based
						authentication. The output of the password-based key derivation function is not directly used as a
						cryptographic key, but only stored as a reference value (commonly called "password hash") to
						compare against when performing authentication. The "cryptographic key size" selected in this
						element must correspond to the length of the password hash. <h:p/>
						See Annex B <!-- xref --> of this catalog for additional guidance regarding the security of password-based
						derived keys. 

					<!-- FCS_CKM_EXT.8 Password-Based Key Derivation -->
					<f-component id="sfr-fcs-ckm-ext-8" cc-id="fcs_ckm_ext.8" name="Password-Based Key Derivation">

						<ecd-info>
							<comp-lev> requires cryptographic keys to be derived from low-entropy password
								input using specified cryptographic primitives which can be based on an assigned
								standard. 
							</comp-lev>
							<manageable-actions/>
							<auditable-actions>
								<action-descr>minimal: Success and failure of the activity;</action-descr>
								<action-descr>basic: The object attribute(s), and object value(s) excluding 
									any sensitive information.</action-descr>
							</auditable-actions>
						</ecd-info>

						<comp-rel>
							<hierarchical-to/>
							<dependencies-to>
								<or-dep>
									<comp-ref>FCS_CKM.2 Cryptographic key distribution</comp-ref> 
									<comp-ref>FCS_COP.1 Cryptographic operation</comp-ref> 
									<comp-ref>FCS_CKM_EXT.7 Cryptographic Key Agreement</comp-ref> 
								</or-dep>
								<comp-ref>FCS_CKM.6 Timing and event of cryptographic key destruction</comp-ref> 
								<comp-ref>FCS_OTV_EXT.1 One-Time Value Generation</comp-ref> 
							</dependencies-to>
						</comp-rel>

			<f-element id="fcs-ckm-ext-8-1">
				<title>
					The TSF shall perform password-based key derivation functions in accordance with a specified 
					cryptographic algorithm [HMAC-<selectables>
						<selectable>SHA-256</selectable>
						<selectable>SHA-384</selectable>
						<selectable>SHA-512</selectable>
						<selectable>SHA3-256</selectable>
						<selectable>SHA3-384</selectable>
						<selectable>SHA3-512</selectable>
						</selectables>, with iteration count of 
						<assignable>number of iterations</assignable>
						using a randomly generated salt of length
						<assignable>equal to or greater than 128</assignable>
						and output cryptographic key sizes <selectables>
						<selectable>128</selectable>
						<selectable>192</selectable>
						<selectable>256</selectable>
						<selectable>512</selectable></selectables>
						bits that meet the following standard: [NIST SP 800-132 (Section 5.3) [PBKDF2]].
				</title>
				<note role="application">
					NIST recommends a minimum “number of iterations” of 1000 but prefers the largest number feasible
					given performance constraints.<h:p/>
					NIST recommends that the randomly generated portion of the salt have length of at least 128 bits 
					and must be derived from a Random Bit Generation.  Therefore FCS_OTV_EXT.1 must be claimed.
				</note>
				<aactivity>
					<TSS>TBD<comment>Extract words from catalog appendix about mitigations.</comment></TSS>
					<Guidance>TBD</Guidance>
					<Tests>
						The following tests are conditional based upon the selections made in the SFR.
						The evaluator shall perform the following test or witness respective tests
						executed by the developer. The tests must be executed on a platform that is as 
						close as practically possible to the operational platform (but which may be 
						instrumented in terms of, for example, use of a debug mode). Where the test is 
						not carried out on the TOE itself, the test platform shall be identified and the 
						differences between test environment and TOE execution environment shall be 
						described.<h:p/>

						To test the TOE’s ability to derive cryptographic keys from a password using PBKDF2 the
						evaluator shall perform the Algorithm Functional Test using the following input 
						parameters:<h:ul>
						<h:li>HMAC algorithms [SHA-256, SHA-384, SHA-512, SHA3-256, SHA3-384, SHA3-512]</h:li>
						<h:li>Iteration count [1-10000000]</h:li>
						<h:li>Derived Key size [128, 192, 256, 512] bits</h:li>
						<h:li>Password length [8-128] bytes</h:li>
						<h:li>Salt length [128-4096] bits in multiples of 8.</h:li></h:ul><h:p/>

						<h:br/><h:b>Algorithm Functional Test</h:b><h:p/>
						For each supported HMAC algorithm, the evaluator shall generate 50 test cases using 
						supported values for the above parameters such that<h:ul>
						<h:li>All supported derived key sizes are tested at least 10 times, </h:li>
						<h:li>Iteration counts are random values between the supported minimum and maximum
						values, with the supported minimum and maximum tested at least once each, </h:li>
						<h:li>Passwords are random byte strings representing upper- and lower-case letters of random
						supported lengths such that the minimum and maximum lengths are tested at least once, and </h:li>
						<h:li>Salts are random values between the supported minimum and maximum lengths such that
						the supported minimum and maximum lengths are both tested at least once. </h:li></h:ul><h:p/>
						The evaluator shall compare the resulting keys from each test case with keys derived using a
						known-good implementation with the same input parameters.
					</Tests>
				</aactivity>
			</f-element>
						<audit-event/>
					</f-component>
				</section>   <!-- FCS_CKM_EXT.8 -->
				
			</section> <!-- FCS_CKM -->
			
			<section id="sec-fcs-cop-1" title="FCS_COP.1: Cryptographic Operations">
			
				<section id="sec-fcs-cop-1-cg" title="Catalog Guidance Notes for Family FCS_COP">
					SFRs under FCS_COP pertain to cryptographic operations. Such operations generally involve
					ensuring the authenticity or confidentiality of data. Typical cryptographic operations include
					encryption/decryption, digital signature generation/verification, and hashing. In this catalog,
					these operations are specified in eleven iterations of FCS_COP.1. 
					
					<h:b>Data Encryption and Authentication</h:b><h:p/>
						For data encryption without built-in authentication, include FCS_COP.1/SKC: Symmetric-Key
						Encryption. This SFR covers the CBC, CTR, XTS, CFB, OFB modes of symmetric-key
						cryptographic algorithms.<h:p/>
						For authenticated encryption, include FCS_COP.1/AEAD: Authenticated Encryption with
						Associated Data. This SFR covers CCM and GCM modes of symmetric-key cryptographic
						algorithms. Alternatively use FCS_COP.1/SKC with FCS_COP.1/CMAC or
						FCS_COP.1/KeyedHash.<h:p/>
						For authentication without encryption, include FCS_COP1/CMAC. This SFR covers the CMAC
						mode of symmetric-key cryptographic algorithms. 
					<h:p/>

					<h:b>Key Encryption</h:b><h:p/>
						For key encryption using asymmetric algorithms such as RSA, include FCS_COP.1/KeyEncap.<h:p/>
						For key encryption using symmetric algorithms, include FCS_COP.1/KeyWrap. This SFR
						covers KW and KWP modes of symmetric cryptographic algorithms, as well as CCM and GCM
						modes when used for key encryption. 
					<h:p/>

					<h:b>Hashing</h:b><h:p/>
						For SHA and SHA3 hashes, include FCS_COP.1/Hash.<h:p/>
						For Keyed Hashes, include FCS_COP.1/KeyedHash. This SFR covers HMAC and KMAC.<h:p/>
						For extended hash output, include FCS_COP.1/XOF: Extendable-Output Functions. This SFR
						covers the SHAKE and KMACXOF algorithms. 
					<h:p/>

					<h:b>Digital Signature Generation/Verification</h:b><h:p/>
						For digital signature operations, include FCS_COP.1/SigGen and FCS_COP.1/SigVer.  
					<h:p/>
				</section>	

				<section title="FCS_COP.1/AEAD Cryptograpic Operation - Authenticated Encryption with Associated Data " id="catsec-fcs-cop-1-aead">

					<h:b>Catalog Guidance Notes</h:b><h:p/>
						For authenticated encryption, include FCS_COP.1/AEAD: Authenticated Encryption with
						Associated Data.  


					<!-- FCS_COP.1/AEAD Cryptographic Operation – Authenticated Encryption with Associated Data -->	
					<f-component id="sfr-fcs-cop-1-aead" cc-id="fcs_cop.1" iteration="AEAD" name="Cryptographic Operation – Authenticated Encryption with Associated Data">

						<comp-rel>
							<hierarchical-to/>
							<dependencies-to>
								<or-dep>
									<comp-ref>FDP_ITC.1 Import of user data without security attributes</comp-ref> 
									<comp-ref>FDP_ITC.2 Import of user data with security attributes</comp-ref> 
									<comp-ref>FCS_CKM.1 Cryptographic key generation</comp-ref>
									<comp-ref>FCS_CKM.5 Cryptographic key derivation</comp-ref>
									<comp-ref>FCS_CKM_EXT.7 Cryptographic key agreement</comp-ref>
									<comp-ref>FCS_CKM_EXT.8 Password-based key derivation</comp-ref>
								</or-dep>
								<comp-ref>FCS_CKM.6 Timing and event of cryptographic key destruction</comp-ref> 
								<comp-ref>FCS_OTV_EXT.1 One-Time Value Generation</comp-ref> 
							</dependencies-to>
						</comp-rel>

			<f-element id="fcs-cop-1e1-aead">
				<title>
				The TSF shall perform [authenticated encryption with associated data] in accordance with a specified 
					cryptographic algorithm 
					<selectables>
						<tabularize id="fcs-cop-aead-sels" title="Recommended choices for FCS_COP.1/AEAD">
							<textcol>Identifier</textcol>
							<reqtext></reqtext>
							<selectcol>Cryptographic algorithm</selectcol>
							<reqtext>and cryptographic key sizes</reqtext>
							<selectcol>Cryptographic key sizes</selectcol>
							<reqtext>that meet the following:</reqtext>
							<selectcol>List of standards</selectcol>
							<reqtext><h:p/><h:p/>The following table provides the recommended choices for
										completion of the selection operations of FCS_COP.1/AEAD.</reqtext>
						</tabularize>
						
						<selectable id="sel-fcs-cop-aead-aes-ccm">
						<col>AES-CCM</col>
						<col>AES in CCM mode with unpredictable, non-repeating nonce, minimum size of 64 bits</col>
						<col><selectables>
							<selectable>128 bits</selectable>
							<selectable>192 bits</selectable>
							<selectable>256 bits</selectable>
						</selectables></col>
						<col><selectables>
							<selectable>ISO/IEC 18033-3:2010 (Subclause 5.2)</selectable>
							<selectable>FIPS PUB 197</selectable></selectables> [AES]<h:p/>
							<selectables>
							<selectable>ISO/IEC 19772:2020 (Clause 7)</selectable> 
							<selectable>NIST SP 800-38C</selectable></selectables> [CCM]
						</col></selectable>

						<selectable id="sel-fcs-cop-aead-aes-gcm">
						<col>AES-GCM</col>
						<col>AES in GCM mode with non-repeating IVs using <selectables>
							<selectable>deterministic</selectable>
							<selectable>RBG-based</selectable></selectables>,
							IV construction; the tag must be of length
							<selectables>
								<selectable>96</selectable>
								<selectable>104</selectable>
								<selectable>112</selectable>
								<selectable>120</selectable>
								<selectable>128</selectable>
							</selectables> bits.
						</col>
						<col><selectables>
								<selectable>128 bits</selectable>
								<selectable>192 bits</selectable>
								<selectable>256 bits</selectable>
							</selectables></col>
						<col><selectables>
							<selectable>ISO/IEC 18033-3:2010 (Subclause 5.2)</selectable>
							<selectable>FIPS PUB 197</selectable></selectables> [AES]<h:p/>
							<selectables>
							<selectable>ISO/IEC 19772:2020 (Clause 10)</selectable> 
							<selectable>NIST SP 800-38D</selectable></selectables> [GCM]
						</col></selectable>

						<selectable id="sel-fcs-cop-aead-cam-ccm">
						<col>CAM-CCM</col>
						<col>Camellia in CCM mode with non-repeating nonce, minimum size of 64 bits</col>
						<col><selectables>
							<selectable>128 bits</selectable>
							<selectable>192 bits</selectable>
							<selectable>256 bits</selectable>
						</selectables></col>
						<col>ISO/IEC 18033-3:2010 (Subclause 5.3) [Camellia]<h:p/>
							<selectables>
							<selectable>ISO/IEC 19772:2020 (Clause 7)</selectable> 
							<selectable>NIST SP 800-38C</selectable></selectables> [CCM]
						</col></selectable>

						<selectable id="sel-fcs-cop-aead-cam-gcm">
						<col>CAM-GCM</col>
						<col>Camillia in GCM mode with non-repeating IVs using <selectables>
							<selectable>deterministic</selectable>
							<selectable>RBG-based</selectable></selectables>,
							IV construction; the tag must be of length
							<selectables>
								<selectable>96</selectable>
								<selectable>104</selectable>
								<selectable>112</selectable>
								<selectable>120</selectable>
								<selectable>128</selectable>
							</selectables> bits.
						</col>
						<col><selectables>
								<selectable>128 bits</selectable>
								<selectable>192 bits</selectable>
								<selectable>256 bits</selectable>
							</selectables></col>
						<col>ISO/IEC 18033-3:2010 (Subclause 5.3) [Camellia]<h:p/>
							<selectables>
							<selectable>ISO/IEC 19772:2020 (Clause 10)</selectable> 
							<selectable>NIST SP 800-38D</selectable></selectables> [GCM]
						</col></selectable>

						<selectable id="sel-fcs-cop-aead-seed-ccm">
						<col>SEED-CCM</col>
						<col>SEED in CCM mode with non-repeating nonce, minimum size of 64 bits</col>
						<col>128 bits</col>
						<col>ISO/IEC 18033-3:2010 (Subclause 5.4) [SEED]<h:p/>
							<selectables>
							<selectable>ISO/IEC 19772:2020 (Clause 7)</selectable> 
							<selectable>NIST SP 800-38C</selectable></selectables> [CCM]
						</col></selectable>

						<selectable id="sel-fcs-cop-aead-seed-gcm">
						<col>SEED-GCM</col>
						<col>SEED in GCM mode with non-repeating IVs using <selectables>
							<selectable>deterministic</selectable>
							<selectable>RBG-based</selectable></selectables>,
							IV construction; the tag must be of length
							<selectables>
								<selectable>96</selectable>
								<selectable>104</selectable>
								<selectable>112</selectable>
								<selectable>120</selectable>
								<selectable>128</selectable>
							</selectables> bits.
						</col>
						<col>128 bits</col>
						<col>ISO/IEC 18033-3:2010 (Subclause 5.4) [SEED] <h:p/>
							<selectables>
							<selectable>ISO/IEC 19772:2020 (Clause 10)</selectable> 
							<selectable>NIST SP 800-38D</selectable></selectables> [GCM]
						</col></selectable>

						<selectable id="sel-fcs-cop-aead-lea-ccm">
						<col>LEA-CCM</col>
						<col>LEA in CCM mode with non-repeating nonce, minimum size of 64 bits</col>
						<col><selectables>
							<selectable>128 bits</selectable>
							<selectable>192 bits</selectable>
							<selectable>256 bits</selectable>
						</selectables></col>
						<col>ISO/IEC 29192-2:2019 (Subclause 6.3 [LEA]<h:p/>
							<selectables>
							<selectable>ISO/IEC 19772:2020 (Clause 7)</selectable> 
							<selectable>NIST SP 800-38C</selectable></selectables> [CCM]
						</col></selectable>

						<selectable id="sel-fcs-cop-aead-lea-gcm">
						<col>LEA-GCM</col>
						<col>LEA in GCM mode with non-repeating IVs using <selectables>
							<selectable>deterministic</selectable>
							<selectable>RBG-based</selectable></selectables>,
							IV construction; the tag must be of length
							<selectables>
								<selectable>96</selectable>
								<selectable>104</selectable>
								<selectable>112</selectable>
								<selectable>120</selectable>
								<selectable>128</selectable>
							</selectables> bits.
						</col>
						<col><selectables>
								<selectable>128 bits</selectable>
								<selectable>192 bits</selectable>
								<selectable>256 bits</selectable>
							</selectables></col>
						<col>ISO/IEC 29192-2:2019 (Subclause 6.3 [LEA]<h:p/>
							<selectables>
							<selectable>ISO/IEC 19772:2020 (Clause 10)</selectable> 
							<selectable>NIST SP 800-38D</selectable></selectables> [GCM]
						</col></selectable>
					</selectables>
				</title>
				<note role="application">
					If the selected cryptographic algorithm requires an IV or nonce, then FCS_OTV_EXT.1 must be claimed.
				</note>
				<aactivity>
					<TSS>
						TBD
					</TSS>
					<Guidance>
						TBD
					</Guidance>
					<Tests>
						The following tests require the developer to provide access to a test platform that
						provides the evaluator with tools that are typically not found on factory products.<h:p/>
						The following tests are conditional based upon the selections made in the SFR. The
						evaluator shall perform the following test or witness respective tests executed by
						the developer. The tests must be executed on a platform that is as close as practically
						possible to the operational platform (but which may be instrumented in terms of,
						for example, use of a debug mode). Where the test is not carried out on the TOE
						itself, the test platform shall be identified and the differences between test
						environment and TOE execution environment shall be described.<h:p/>

						<!-- AES-CCM -->
						<h:br/><h:b>AES-CCM</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">AES-CCM </h:td>
								<h:td valign="top">AES in CCM mode with nonrepeating nonce, minimum size
									of 64 bits</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> 128, 192, 256] bits</h:td>
								<h:td valign="top">
									[<h:b>selection:</h:b> ISO/IEC 18033-3:2010 (Subclause 5.2),
									FIPS PUB 197] [AES]<h:p/>
									[<h:b>selection:</h:b>  ISO/IEC 19772:2020 (Clause 7), NIST SP 800-38C] [CCM]</h:td>
							</h:tr>
						</h:table><h:p/>	
						To test the TOE’s implementation of AES-CCM authenticated encryption functionality the
						evaluator shall perform the Algorithm Functional Tests described below using the following
						input parameters:<h:ul>
						<h:li>Key Size [128, 192, 256] bits</h:li>
						<h:li>Associated data size [0-65536] bits in increments of 8</h:li>
						<h:li>Payload size [0-256] bits in increments of 8</h:li>
						<h:li>IV/Nonce size [64-104] bits in increments of 8</h:li>
						<h:li>Tag size [32-128] bits in increments of 16</h:li></h:ul><h:p/>
						<h:br/><h:b>Algorithm Functional Tests</h:b><h:p/>
						Unless otherwise specified, the following tests should use random data, a tag size of 128 bits,
						IV/Nonce size of 104 bits, payload size of 256 bits, and associated data size of 256 bits. If any of
						these values are not supported, any supported value may be used. The evaluator shall compare
						the output from each test case against results generated by a known-good implementation with
						the same input parameters.<h:p/>
						<h:br/><h:b><h:i>Variable Associated Data Test</h:i></h:b><h:p/>
						For each claimed key size, and for each supported associated data size from 0 through 256 bits in
						increments of 8 bits, the TOE must be tested by encrypting 10 test cases using all random data.
						In addition, for each key size, the TOE must be tested by encrypting 10 cases with associated
						data lengths of 65536 bits, if supported.<h:p/>				
						<h:br/><h:b><h:i>Variable Payload Test</h:i></h:b><h:p/>
						For each claimed key size, and for each supported payload size from 0 through 256 bits in
						increments of 8 bits, the TOE must be tested by encrypting 10 test cases using all random data.<h:p/>
						<h:br/><h:b><h:i>Variable Nonce Test</h:i></h:b><h:p/>
						For each claimed key size, and for each supported IV/Nonce size from 64 through 104 bits in
						increments of 8 bits, the TOE must be tested by encrypting 10 test cases using all random data.<h:p/>
						<h:br/><h:b><h:i>Variable Tag Test</h:i></h:b><h:p/>
						For each claimed key size, and for each supported tag size from 32 through 128 bits in
						increments of 16 bits, the TOE must be tested by encrypting 10 test cases using all random data.<h:p/>
						<h:br/><h:b><h:i>Decryption Verification Test</h:i></h:b><h:p/>
						For each claimed key size, for each supported associated data size from 0 through 256 bits in
						increments of 8 bits, for each supported payload size from 0 through 256 bits in increments of 8
						bits, for each supported IV/Nonce size from 64 through 104 bits in increments of 8 bits, and for
						each supported tag size from 32 through 128 bits in increments of 16 bits, the TOE must be
						tested by decrypting 10 test cases using all random data.<h:p/>					
						
						<!-- AES-GCM -->
						<h:br/><h:b>AES-GCM</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">AES-GCM </h:td>
								<h:td valign="top">AES in GCM mode with nonrepeating IVs using 
									[<h:b>selection:</h:b> deterministic, RBG-based] IV construction; 
									the tag must be of length [<h:b>selection:</h:b> 96, 104, 112, 120, or 128] bits.</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> 128, 192, 256] bits</h:td>
								<h:td valign="top">
									[<h:b>selection:</h:b> ISO/IEC 18033-3:2010 (Subclause 5.2),
									FIPS PUB 197] [AES]<h:p/>
									[<h:b>selection:</h:b>  ISO/IEC 19772:2020 (Clause 10), NIST SP 800-38D] [GCM]</h:td>
							</h:tr>
						</h:table><h:p/>	
						To test the TOE’s implementation of AES-GCM authenticated encryption functionality the
						evaluator shall perform the Encryption Algorithm Functional Tests and Decryption Algorithm
						Functional Tests as described below using the following input parameters:<h:ul>
						<h:li>Key Size [128, 192, 256] bits</h:li>
						<h:li>Associated data size [0-65536] bits</h:li>
						<h:li>Payload size [0-65536] bits</h:li>
						<h:li>IV size [96] bits</h:li>
						<h:li>Tag size [96, 104, 112, 120, 128] bits</h:li></h:ul><h:p/>
						<h:br/><h:b>Encryption Algorithm Functional Tests</h:b><h:p/>
						The evaluator shall generate 15 test cases using random data for each combination of
						the above parameters as follows:<h:p/><h:ul>
						<h:li>Each claimed key size,</h:li>
						<h:li>Each supported tag size,</h:li>
						<h:li>Four supported non-zero payload sizes, such that two are multiples of 128 bits
							and two are not multiples of 128 bits,</h:li>
						<h:li>Four supported non-zero associated data sizes, such that two are multiples of 
							128 bits and two are not multiples of 128 bits, and</h:li>
						<h:li>An associated data size of zero, if supported.</h:li></h:ul><h:p/>
						Note that the IV size is always 96 bits.<h:p/>
						The evaluator shall compare the output from each test case against results generated by a known-
						good implementation with the same input parameters.<h:p/>
						<h:br/><h:b><h:i>Decryption Algorithm Functional Tests</h:i></h:b><h:p/>
						The evaluator shall test the authenticated decrypt functionality of AES-GCM by supplying 15
						test cases for the supported combinations of the parameters as described above. For each
						parameter combination the evaluator shall introduce an error into either the Ciphertext or the Tag
						such that approximately half of the cases are correct and half the cases contain errors.

						<!-- CAM-CCM -->
						<h:br/><h:b>CAM-CCM</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">CAM-CCM </h:td>
								<h:td valign="top">Camellia in CCM mode with nonrepeating nonce, minimum 
									size of 64 bits</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> 128, 192, 256] bits</h:td>
								<h:td valign="top">
									ISO/IEC 18033-3:2010 (Subclause 5.3) [Camellia] <h:p/>
									[<h:b>selection:</h:b>  ISO/IEC 19772:2020 (Clause 7), NIST SP 800-38C] [CCM]</h:td>
							</h:tr>
						</h:table><h:p/>	

						<!-- CAM-GCM -->
						<h:br/><h:b>CAM-GCM</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">CAM-GCM </h:td>
								<h:td valign="top">CAM in GCM mode with nonrepeating IVs using 
									[<h:b>selection:</h:b> deterministic, RBG-based] IV construction; 
									the tag must be of length [<h:b>selection:</h:b> 96, 104, 112, 120, or 128] bits.</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> 128, 192, 256] bits</h:td>
								<h:td valign="top">
									ISO/IEC 18033-3:2010 (Subclause 5.3) [Camellia] <h:p/>
									[<h:b>selection:</h:b>  ISO/IEC 19772:2020 (Clause 10), NIST SP 800-38D] [GCM]</h:td>
							</h:tr>
						</h:table><h:p/>	

						<!-- SEED-CCM -->
						<h:br/><h:b>SEED-CCM</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">SEED-CCM </h:td>
								<h:td valign="top">SEED in CCM mode with nonrepeating nonce, minimum 
									size of 64 bits</h:td>
								<h:td valign="top">128 bits</h:td>
								<h:td valign="top">
									ISO/IEC 18033-3:2010 (Subclause 5.4) [SEED]  <h:p/>
									[<h:b>selection:</h:b>  ISO/IEC 19772:2020 (Clause 7), NIST SP 800-38C] [CCM]</h:td>
							</h:tr>
						</h:table><h:p/>	
						To test the TOE’s implementation of SEED-CCM authenticated encryption functionality the
						evaluator shall perform the Algorithm Functional Tests described below using the following
						input parameters:<h:ul>
						<h:li>Key Size [128] bits</h:li>
						<h:li>Associated data size [0-65536] bits in increments of 8</h:li>
						<h:li>Payload size [0-256] bits in increments of 8</h:li>
						<h:li>IV/Nonce size [64-104] bits in increments of 8</h:li>
						<h:li>Tag size [32-128] bits in increments of 16</h:li></h:ul><h:p/>
						<h:br/><h:b>Algorithm Functional Tests</h:b><h:p/>
						Unless otherwise specified, the following tests should use random data, a tag size of 128 bits,
						IV/Nonce size of 104 bits, payload size of 256 bits, and associated data size of 256 bits. If any of
						these values are not supported, any supported value may be used. The evaluator shall compare
						the output from each test case against results generated by a known-good implementation with
						the same input parameters.<h:p/>
						<h:br/><h:b><h:i>Variable Associated Data Test</h:i></h:b><h:p/>
						For each supported associated data size from 0 through 256 bits in increments of 8 bits, the TOE
						must be tested by encrypting 10 test cases using all random data. In addition, the TOE must be
						tested by encrypting 10 cases with associated data lengths of 65536 bits, if supported.<h:p/>				
						<h:br/><h:b><h:i>Variable Payload Test</h:i></h:b><h:p/>
						For each supported payload size from 0 through 256 bits in increments of 8 bits, the TOE must
						be tested by encrypting 10 test cases using all random data.<h:p/>
						<h:br/><h:b><h:i>Variable Nonce Test</h:i></h:b><h:p/>
						For each supported IV/Nonce size from 64 through 104 bits in increments of 8 bits, the TOE
						must be tested by encrypting 10 test cases using all random data.<h:p/>
						<h:br/><h:b><h:i>Variable Tag Test</h:i></h:b><h:p/>
						For each supported tag size from 32 through 128 bits in increments of 16 bits, the TOE must be
						tested by encrypting 10 test cases using all random data.<h:p/>
						<h:br/><h:b><h:i>Decryption Verification Test</h:i></h:b><h:p/>
						For each supported associated data size from 0 through 256 bits in increments of 8 bits, for each
						supported payload size from 0 through 256 bits in increments of 8 bits, for each supported
						IV/Nonce size from 64 through 104 bits in increments of 8 bits, and for each supported tag size
						from 32 through 128 bits in increments of 16 bits, the TOE must be tested by decrypting 10 test
						cases using all random data.<h:p/>					

						<!-- SEED-GCM -->
						<h:br/><h:b>SEED-GCM</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">SEED-GCM </h:td>
								<h:td valign="top">SEED in GCM mode with nonrepeating IVs using 
									[<h:b>selection:</h:b> deterministic, RBG-based] IV construction; 
									the tag must be of length [<h:b>selection:</h:b> 96, 104, 112, 120, or 128] bits.</h:td>
								<h:td valign="top">128 bits</h:td>
								<h:td valign="top">
									ISO/IEC 18033-3:2010 (Subclause 5.4) [SEED] <h:p/>
									[<h:b>selection:</h:b>  ISO/IEC 19772:2020 (Clause 10), NIST SP 800-38D] [GCM]</h:td>
							</h:tr>
						</h:table><h:p/>	
						To test the TOE’s implementation of SEED-GCM authenticated encryption functionality the
						evaluator shall perform the Encryption Algorithm Functional Tests and Decryption Algorithm
						Functional Tests as described below using the following input parameters:<h:ul>
						<h:li>Key Size [128] bits</h:li>
						<h:li>Associated data size [0-65536] bits</h:li>
						<h:li>Payload size [0-65536] bits</h:li>
						<h:li>IV size [96] bits</h:li>
						<h:li>Tag size [96, 104, 112, 120, 128] bits</h:li></h:ul><h:p/>
						<h:br/><h:b>Encryption Algorithm Functional Tests</h:b><h:p/>
						The evaluator shall generate 15 test cases using random data for each combination of
						the above parameters as follows:<h:p/><h:ul>
						<h:li>Each supported tag size,</h:li>
						<h:li>Four supported non-zero payload sizes, such that two are multiples of 128 bits
							and two are not multiples of 128 bits,</h:li>
						<h:li>Four supported non-zero associated data sizes, such that two are multiples of 
							128 bits and two are not multiples of 128 bits, and</h:li>
						<h:li>An associated data size of zero, if supported.</h:li></h:ul><h:p/>
						Note that the IV size is always 96 bits and the key size is always 128 bits.<h:p/>
						The evaluator shall compare the output from each test case against results generated by a known-
						good implementation with the same input parameters.<h:p/>
						<h:br/><h:b><h:i>Decryption Algorithm Functional Tests</h:i></h:b><h:p/>
						The evaluator shall test the authenticated decrypt functionality of SEED-GCM by supplying 15
						test cases for the supported combinations of the parameters as described above.. For each
						parameter combination the evaluator shall introduce an error into either the Ciphertext or the Tag
						such that approximately half of the cases are correct and half the cases contain errors.
						
						<!-- LEA-CCM -->
						<h:br/><h:b>LEA-CCM</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">LEA-CCM </h:td>
								<h:td valign="top">LEA in CCM mode with nonrepeating nonce, minimum 
									size of 64 bits</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> 128, 192, 256] bits</h:td>
								<h:td valign="top">
									ISO/IEC 29192-2:2019 (Subclause 6.3 [LEA] <h:p/>
									[<h:b>selection:</h:b>  ISO/IEC 19772:2020 (Clause 7), NIST SP 800-38C] [CCM]</h:td>
							</h:tr>
						</h:table><h:p/>	
						To test the TOE’s implementation of LEA-CCM authenticated encryption functionality the
						evaluator shall perform the Algorithm Functional Tests described below using the following
						input parameters:<h:ul>
						<h:li>Key Size [128, 192, 256] bits</h:li>
						<h:li>Associated data size [0-65536] bits in increments of 8</h:li>
						<h:li>Payload size [0-256] bits in increments of 8</h:li>
						<h:li>IV/Nonce size [64-104] bits in increments of 8</h:li>
						<h:li>Tag size [32-128] bits in increments of 16</h:li></h:ul><h:p/>
						<h:br/><h:b>Algorithm Functional Tests</h:b><h:p/>
						Unless otherwise specified, the following tests should use random data, a tag size of 128 bits,
						IV/Nonce size of 104 bits, payload size of 256 bits, and associated data size of 256 bits. If any of
						these values are not supported, any supported value may be used. The evaluator shall compare
						the output from each test case against results generated by a known-good implementation with
						the same input parameters.<h:p/>
						<h:br/><h:b><h:i>Variable Associated Data Test</h:i></h:b><h:p/>
						For each claimed key size, and for each supported associated data size from 0 through 256 bits in
						increments of 8 bits, the TOE must be tested by encrypting 10 test cases using all random data.
						In addition, for each key size, the TOE must be tested by encrypting 10 cases with associated
						data lengths of 65536 bits, if supported.<h:p/>				
						<h:br/><h:b><h:i>Variable Payload Test</h:i></h:b><h:p/>
						For each claimed key size, and for each supported payload size from 0 through 256 bits in
						increments of 8 bits, the TOE must be tested by encrypting 10 test cases using all random data.<h:p/>
						<h:br/><h:b><h:i>Variable Nonce Test</h:i></h:b><h:p/>
						For each claimed key size, and for each supported IV/Nonce size from 64 through 104 bits in
						increments of 8 bits, the TOE must be tested by encrypting 10 test cases using all random data.<h:p/>
						<h:br/><h:b><h:i>Variable Tag Test</h:i></h:b><h:p/>
						For each claimed key size, and for each supported tag size from 32 through 128 bits in
						increments of 16 bits, the TOE must be tested by encrypting 10 test cases using all random data.<h:p/>
						<h:br/><h:b><h:i>Decryption Verification Test</h:i></h:b><h:p/>
						For each claimed key size, for each supported associated data size from 0 through 256 bits in
						increments of 8 bits, for each supported payload size from 0 through 256 bits in increments of 8
						bits, for each supported IV/Nonce size from 64 through 104 bits in increments of 8 bits, and for
						each supported tag size from 32 through 128 bits in increments of 16 bits, the TOE must be
						tested by decrypting 10 test cases using all random data.<h:p/>					


						<!-- LEA-GCM -->
						<h:br/><h:b>LEA-GCM</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">LEA-GCM </h:td>
								<h:td valign="top">LEA in GCM mode with nonrepeating IVs using 
									[<h:b>selection:</h:b> deterministic, RBG-based] IV construction; 
									the tag must be of length [<h:b>selection:</h:b> 96, 104, 112, 120, or 128] bits.</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> 128, 192, 256] bits</h:td>
								<h:td valign="top">
									ISO/IEC 29192-2:2019 (Subclause 6.3 [LEA] <h:p/>
									[<h:b>selection:</h:b>  ISO/IEC 19772:2020 (Clause 10), NIST SP 800-38D] [GCM]</h:td>
							</h:tr>
						</h:table><h:p/>	
						To test the TOE’s implementation of LEA-GCM authenticated encryption functionality the
						evaluator shall perform the Encryption Algorithm Functional Tests and Decryption Algorithm
						Functional Tests as described below using the following input parameters:<h:ul>
						<h:li>Key Size [128, 192, 256] bits</h:li>
						<h:li>Associated data size [0-65536] bits</h:li>
						<h:li>Payload size [0-65536] bits</h:li>
						<h:li>IV size [96] bits</h:li>
						<h:li>Tag size [96, 104, 112, 120, 128] bits</h:li></h:ul><h:p/>
						<h:br/><h:b>Encryption Algorithm Functional Tests</h:b><h:p/>
						The evaluator shall generate 15 test cases using random data for each combination of
						the above parameters as follows:<h:p/><h:ul>
						<h:li>Each claimed key size,</h:li>
						<h:li>Each supported tag size,</h:li>
						<h:li>Four supported non-zero payload sizes, such that two are multiples of 128 bits
							and two are not multiples of 128 bits,</h:li>
						<h:li>Four supported non-zero associated data sizes, such that two are multiples of 
							128 bits and two are not multiples of 128 bits, and</h:li>
						<h:li>An associated data size of zero, if supported.</h:li></h:ul><h:p/>
						Note that the IV size is always 96 bits.<h:p/>
						The evaluator shall compare the output from each test case against results generated by a known-
						good implementation with the same input parameters.<h:p/>
						<h:br/><h:b><h:i>Decryption Algorithm Functional Tests</h:i></h:b><h:p/>
						The evaluator shall test the authenticated decrypt functionality of AES-GCM by supplying 15
						test cases for the supported combinations of the parameters as described above. For each
						parameter combination the evaluator shall introduce an error into either the Ciphertext or the Tag
						such that approximately half of the cases are correct and half the cases contain errors.
					</Tests>
				</aactivity>
			</f-element>
						<audit-event/>
					</f-component>
					
				</section>   <!-- FCS_COP.1/AEAD -->

				<section title="FCS_COP.1/CMAC Cryptographic Operation - CMAC" id="catsec-fcs-cop-1-cmac">

					<!-- FCS_COP.1/CMAC Cryptographic Operation - CMAC -->
					<f-component id="sfr-fcs-cop-1-cmac" cc-id="fcs_cop.1" iteration="CMAC" name="Cryptographic Operation - CMAC">

						<comp-rel>
							<hierarchical-to/>
							<dependencies-to>
								<or-dep>
									<comp-ref>FDP_ITC.1 Import of user data without security attributes</comp-ref> 
									<comp-ref>FDP_ITC.2 Import of user data with security attributes</comp-ref> 
									<comp-ref>FCS_CKM.1 Cryptographic key generation</comp-ref>
									<comp-ref>FCS_CKM.5 Cryptographic key derivation</comp-ref>
									<comp-ref>FCS_CKM_EXT.7 Cryptographic key agreement</comp-ref>
									<comp-ref>FCS_CKM_EXT.8 Password-based key derivation</comp-ref>
								</or-dep>
								<comp-ref>FCS_CKM.6 Timing and event of cryptographic key destruction</comp-ref> 
							</dependencies-to>
						</comp-rel>

			<f-element id="fcs-cop-1e1-cmac">
				<title> The TSF shall perform [CMAC] in accordance with a specified cryptographic algorithm 
					<selectables>
						<tabularize id="tab-fcs-cop-cmac-sels" title="Recommended choices for FCS_COP.1/CMAC">
							<textcol>Identifier</textcol>
							<reqtext></reqtext>
							<selectcol>Cryptographic algorithm</selectcol>
							<reqtext>and cryptographic key sizes</reqtext>
							<selectcol>Cryptographic key sizes</selectcol>
							<reqtext>that meet the following:</reqtext>
							<selectcol>List of standards</selectcol>
							<reqtext><h:p/><h:p/>The following table provides the recommended choices for
										completion of the selection operations of FCS_COP.1/CMAC.</reqtext>
						</tabularize>
						
						<selectable id="sel-fcs-cop-cmac-aes">
							<col>AES-CMAC</col>
							<col>AES using CMAC mode</col>
						<col><selectables>
								<selectable>128 bits</selectable>
								<selectable>192 bits</selectable>
								<selectable>256 bits</selectable>
							</selectables></col>
						<col><selectables>
							<selectable>ISO/IEC 18033-3:2010 (Subclause 5.2)</selectable>
							<selectable>FIPS PUB 197</selectable></selectables> [AES]<h:p/>
							<selectables>
							<selectable>: ISO/IEC 9797-1:2011 Subclause 7.6</selectable> 
							<selectable>NIST SP 800-38B</selectable></selectables> [CMAC]
						</col></selectable>

						<selectable id="sel-fcs-cop-cmac-cam">
							<col>CAM-CMAC</col>
							<col>Camillia using CMAC mode</col>
						<col><selectables>
								<selectable>128 bits</selectable>
								<selectable>192 bits</selectable>
								<selectable>256 bits</selectable>
							</selectables></col>
						<col>ISO/IEC 18033-3:2010 Subclause 5.3 [Camellia]<h:p/>
							<selectables>
							<selectable>: ISO/IEC 9797-1:2011 Subclause 7.6</selectable> 
							<selectable>NIST SP 800-38B</selectable></selectables> [CMAC]
						</col></selectable>
					</selectables>
				</title>
				<aactivity>
					<TSS> TBD </TSS>
					<Guidance>TBD</Guidance>
					<Tests>
						The following tests require the developer to provide access to a test platform that
						provides the evaluator with tools that are typically not found on factory products.<h:p/>
						The following tests are conditional based upon the selections made in the SFR. The
						evaluator shall perform the following test or witness respective tests executed by
						the developer. The tests must be executed on a platform that is as close as practically
						possible to the operational platform (but which may be instrumented in terms of,
						for example, use of a debug mode). Where the test is not carried out on the TOE
						itself, the test platform shall be identified and the differences between test
						environment and TOE execution environment shall be described.<h:p/>

						<!-- AES-CMAC -->
						<h:br/><h:b>AES-CMAC</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">AES-CMAC </h:td>
								<h:td valign="top">AES using CMAC mode</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> 128, 192, 256] bits</h:td>
								<h:td valign="top">
									[<h:b>selection:</h:b> ISO/IEC 18033-3:2010 (Subclause 5.2),
									FIPS PUB 197] [AES]<h:p/>
									[<h:b>selection:</h:b>  ISO/IEC 9797-1:2011 (Subclause 7.6), NIST SP 800-38B] [CMAC]</h:td>
							</h:tr>
						</h:table><h:p/>	
						To test the TOE’s ability to generate MAC values using AES in CMAC mode the evaluator shall
						perform the CMAC Generation Test and CMAC Verification Test using the following input
						parameters:<h:ul>
						<h:li>Key Size [128, 192, 256] bits</h:li>
						<h:li>Message size [0-524288] bits in increments of 8</h:li>
						<h:li>MAC sizes [1-128] bits</h:li></h:ul><h:p/>
						<h:br/><h:b>CMAC Generation Test</h:b><h:p/>
						The evaluator shall generate eight test cases using random keys and data for each combination of
						the above parameters as follows:<h:p/><h:ul>
						<h:li>For each claimed key size,</h:li>
						<h:li>For four message sizes as follows:<h:ul>
							<h:li>The smallest supported message size,</h:li>
							<h:li>The largest supported message size,</h:li>
							<h:li>Two sizes that are divisible by the block size, and</h:li>
							<h:li>Two sizes that are not divisible by the block size</h:li></h:ul></h:li>
						<h:li>For three MAC sizes as follows:<h:ul>
							<h:li>The smallest supported MAC size,</h:li>
							<h:li>The largest supported MAC size, and</h:li>
							<h:li>Some other supported MAC size</h:li></h:ul></h:li></h:ul><h:p/>
						The evaluator shall compare the output from each test case against results generated by a known-
						good implementation with the same input parameters.
						<h:br/><h:b>CMAC Verification Test</h:b><h:p/>
						The evaluator shall generate 20 test cases using random keys and data for each combination of
						the above parameters as follows:<h:ul>
						<h:li>For each claimed key size,</h:li>
						<h:li>For four message sizes as follows:<h:ul>
							<h:li>The smallest supported message size,</h:li>
							<h:li>The largest supported message size,</h:li>
							<h:li>Two sizes that are divisible by the block size, and</h:li>
							<h:li>Two sizes that are not divisible by the block size</h:li></h:ul></h:li>
						<h:li>For three MAC sizes as follows:<h:ul>
							<h:li>The smallest supported MAC size,</h:li>
							<h:li>The largest supported MAC size, and</h:li>
							<h:li>Some other supported MAC size</h:li></h:ul></h:li></h:ul><h:p/>
						The evaluator shall modify the tag such that 25% of the test cases in each group of 20 test
						cases should fail.<h:p/>
						The evaluator shall determine that the verification fails for the test cases with modified inputs,
						and succeeds for those with unmodified inputs.

						<!-- CAM-CMAC -->
						<h:br/><h:b>CAM-CMAC</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">CAM-CMAC </h:td>
								<h:td valign="top">CAM using CMAC mode</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> 128, 192, 256] bits</h:td>
								<h:td valign="top">
									ISO/IEC 18033-3:2010 (Subclause 5.3) [Camellia] <h:p/>
									[<h:b>selection:</h:b>  ISO/IEC 9797-1:2011 (Subclause 7.6), NIST SP 800-38B] [CMAC]</h:td>
							</h:tr>
						</h:table><h:p/>	
					</Tests>
				</aactivity>
			</f-element>
						<audit-event/>
					</f-component>
				</section>    <!-- FCS_COP.1/CMAC -->
				
				
				<section title="FCS_COP.1/Hash Cryptographic Operation - Hashing" id="catsec-fcs-cop-1-hash">

					<!-- FCS_COP.1/Hash Cryptographic Operation - Hashing -->
					<f-component id="sfr-fcs-cop-1-hash" cc-id="fcs_cop.1" iteration="Hash" name="Cryptographic Operation - Hashing)">

						<comp-rel>
							<hierarchical-to/>
							<dependencies-to/>
						</comp-rel>

            <f-element id="fcs-cop-1e1-hash">
                <title>
				The TSF shall perform [<h:i>cryptographic hashing</h:i>] in accordance with a specified 
				cryptographic algorithm 
                    <selectables>
                        <selectable id="sel-cop1-sha1">SHA-1</selectable>
                        <selectable id="sel-cop1-sha224">SHA-224</selectable>
                        <selectable id="sel-cop1-sha256">SHA-256</selectable>
                        <selectable id="sel-cop1-sha384">SHA-384</selectable>
                        <selectable id="sel-cop1-sha512">SHA-512</selectable>
                        <selectable id="sel-cop1-sha512224">SHA-512/224</selectable>
                        <selectable id="sel-cop1-sha512256">SHA-512/256</selectable>
						<selectable id="sel-cop1-sha3-224">SHA-3-224</selectable>
						<selectable id="sel-cop1-sha3-256">SHA-3-256</selectable>
						<selectable id="sel-cop1-sha3-384">SHA-3-384</selectable>
						<selectable id="sel-cop1-sha3-512">SHA-3-512</selectable>		    
                    </selectables> that meet the following:
					<selectables>
						<selectable>ISO/IEC 10118-3:2018 [SHA, SHA3]</selectable>
						<selectable>FIPS PUB 180-4 [SHA]</selectable>
						<selectable>FIPS PUB 202 [SHA3]</selectable>
					</selectables>.   
                </title>
                <note role="application">
					The hash selection should be consistent with the overall strength of the 
					algorithm used for signature generation. For example, the TOE should choose SHA-256 for 2048-bit RSA or
					ECC with P-256; SHA-384 for 3072-bit RSA, 4096-bit RSA, or ECC with P-384; and SHA-512 for ECC with
					P-521. The ST author selects the standard based on the algorithms selected.  <h:p/>
					SHA-1 may be used as a general hash function and for the following applications: generating and 
					verifying hash-based message authentication codes (HMACs), key derivation functions (KDFs), and random
					bit/number generation.  SHA-1 may also be used for verifying old digital signatures and time stamps,
					if this is explicitly allowed by the application domain.  SHA-1 should not be used in applications in 
					which collision resistance is needed.
                </note>
                <aactivity> 
                    <TSS>TBD
					</TSS>
                    <Guidance>TBD
                    </Guidance>
                    <Tests>
						The following tests require the developer to provide access to a test platform that
						provides the evaluator with tools that are typically not found on factory products.<h:p/>
						The following tests are conditional based upon the selections made in the SFR. The
						evaluator shall perform the following test or witness respective tests executed by
						the developer. The tests must be executed on a platform that is as close as practically
						possible to the operational platform (but which may be instrumented in terms of,
						for example, use of a debug mode). Where the test is not carried out on the TOE
						itself, the test platform shall be identified and the differences between test
						environment and TOE execution environment shall be described.<h:p/>

						<h:br/><h:b>SHA-1, SHA2-224, SHA2-256, SHA2-384, SHA2-512, SHA2-512/224, SHA2-512/256</h:b><h:p/> 
						To test the TOE’s ability to generate hash digests using SHA-1 and SHA2 the evaluator shall
						perform the Algorithm Functional Test, Monte Carlo Test, and Large Data Test for each claimed
						SHA-1 and SHA2 algorithm.<h:p/>
						<h:br/><h:b>Algorithm Functional Test</h:b><h:p/>
						The evaluator shall generate a number of test cases equal to the block size of the hash (512 for SHA-1, SHA2-224,
						and SHA2-256; 1024 for the other SHA2 algorithms).<h:p/>
						Each test case is to consist of random data of a random length between 0 and 65536 bits, or the
						largest size supported.<h:p/>
						Each test case is to consist of random data of a random length between 0 and 65536 bits, or the
						largest size supported.<h:p/>
						<h:br/><h:b>Monte Carlo Test</h:b><h:p/>
						Monte Carlo tests begin with a single seed and run 100 iterations of the chained computation.<h:p/>
						There are two versions of the Monte Carlo test for SHA-1 and SHA-2. Either one is acceptable.
						For the Standard Monte Carlo test the message hashed is always three times the length of the
						initial seed.<h:p/>
						<h:pre>
						For j = 0 to 99
							A = B = C = SEED
							For i = 0 to 999
								MSG = A || B || C
								MD = SHA(MSG)
								A = B
								B = C
								C = MD
							Output MD
							SEED = MD
						</h:pre><h:p/>
						For the alternate version of the Monte Carlo Test, the hashed message is always the same length as
						the seed.<h:p/>
						<h:pre>
						INITIAL_SEED_LENGTH = LEN(SEED)
						For j = 0 to 99
							A = B = C = SEED
							For i = 0 to 999
								MSG = A || B || C
								if LEN(MSG) &gt;= INITIAL_SEED_LENGTH:
									MSG = leftmost INITIAL_SEED_LENGTH bits of MSG
								else:
									MSG = MSG || INITIAL_SEED_LENGTH - LEN(MSG) 0 bits
								MD = SHA(MSG)

								A = B
								B = C
								C = MD
							Output MD
							SEED = MD	
						</h:pre><h:p/>
						The evaluator shall compare the output against results generated by a known-good
						implementation with the same input.<h:p/>
						<h:br/><h:b>Large Data Test</h:b><h:p/>
						The implementation must be tested against one test case each on large data messages of 1GB,
						2GB, 4GB, and 8GB of data as supported. The data need not be random. It may, for example,
						consist of a repeated pattern of 64 bits.<h:p/>
						The evaluator shall compare the output against results generated by a known-good
						implementation with the same input.<h:p/>
						
						<h:br/><h:b>SHA3-224, SHA3-256, SHA3-384, SHA3-512</h:b> 
						To test the TOE’s ability to generate hash digests using SHA3 the evaluator shall perform the
						Algorithm Functional Test, Monte Carlo Test, and Large Data Tests for each claimed SHA3
						algorithm.
						<h:br/><h:b>Algorithm Functional Test</h:b><h:p/>
						Generate a test case consisting of random data for every message length from 0 bits (or the
						smallest supported message size) to rate bits, where rate equals<h:ul>
						<h:li>1152 for SHA3-224,</h:li>
						<h:li>1088 for SHA3-256,</h:li>
						<h:li>832 for SHA3-384, and</h:li>
						<h:li>576 for SHA3-512.</h:li></h:ul><h:p/>
						Additionally, generate tests cases of random data for messages of every multiple of (rate+1) bits
						starting at length rate, and continuing until 65535 is exceeded.<h:p/>
						The evaluator shall compare the output against results generated by a known-good
						implementation with the same input.<h:p/>
						<h:br/><h:b>Monte Carlo Test</h:b><h:p/>
						Monte Carlo tests begin with a single seed and run 100 iterations of the chained computation.<h:p/>
						For this Monte Carlo Test, the hashed message is always the same length as the seed.<h:p/>
						<h:pre>
						MD[0] = SEED
						INITIAL_SEED_LENGTH = LEN(SEED)
						For 100 iterations
							For i = 1 to 1000
								MSG = MD[i-1];
								if LEN(MSG) &gt;= INITIAL_SEED_LENGTH:
									MSG = leftmost INITIAL_SEED_LENGTH bits of MSG
								else:
									MSG = MSG || INITIAL_SEED_LENGTH - LEN(MSG) 0 bits
								MD[i] = SHA3(MSG)
							MD[0] = MD[1000]
							Output MD[0]
						</h:pre><h:p/>
						The evaluator shall compare the output against results generated by a known-good
						implementation with the same input.<h:p/>
						<h:br/><h:b>Large Data Test</h:b><h:p/>
						The implementation must be tested against one test case each on large data messages of 1GB,
						2GB, 4GB, and 8GB of data as supported. The data need not be random. It may, for example,
						consist of a repeated pattern of 64 bits.<h:p/>
						The evaluator shall compare the output against results generated by a known-good
						implementation with the same input.<h:p/>
                    </Tests>
                </aactivity>
            </f-element>
						<audit-event />
					</f-component>
				</section>   <!-- FCS_COP.1/Hash -->
				
				<section title="FCS_COP.1/KeyedHash Cryptographic Operation - Keyed Hash" id="catsec-fcs-cop-1-keyedhash">

					<!-- FCS_COP.1/KeyedHash Cryptographic Operation - Keyed Hash -->
					<f-component id="sfr-fcs-cop-1-keyedhash" cc-id="fcs_cop.1" iteration="KeyedHash" name="Cryptographic Operation - Keyed Hash">

						<comp-rel>
							<hierarchical-to/>
							<dependencies-to>
								<or-dep>
									<comp-ref>FDP_ITC.1 Import of user data without security attributes</comp-ref> 
									<comp-ref>FDP_ITC.2 Import of user data with security attributes</comp-ref> 
									<comp-ref>FCS_CKM.1 Cryptographic key generation</comp-ref>
									<comp-ref>FCS_CKM.5 Cryptographic key derivation</comp-ref>
									<comp-ref>FCS_CKM_EXT.7 Cryptographic key agreement</comp-ref>
									<comp-ref>FCS_CKM_EXT.8 Password-based key derivation</comp-ref>
								</or-dep>
								<comp-ref>FCS_CKM.6 Timing and event of cryptographic key destruction</comp-ref> 
								<or-dep>
									<comp-ref>FCS_COP.1/Hash Hashing</comp-ref>
									<comp-ref>FCS_COP.1/XOF Extendable-Output Function</comp-ref>
								</or-dep>
							</dependencies-to>
						</comp-rel>
				
			<f-element id="fcs-cop-1e1-keyedhash">
				<title>The TSF shall perform [keyed hash message authentication] in accordance
					with a specified cryptographic algorithm 
					<selectables>
						<tabularize id="tab-fcs-cop-keyedhash-sels" title="Recommended choices for FCS_COP.1/KeyedHash">
							<selectcol>Keyed Hash Algorithm</selectcol>
							<reqtext>and cryptographic key sizes</reqtext>
							<selectcol>Cryptographic key sizes</selectcol>
							<reqtext>that meet the following:</reqtext>
							<selectcol>List of standards</selectcol>
							<reqtext><h:p/><h:p/>The following table provides the recommended choices for
										completion of the selection operations of FCS_COP.1/KeyedHash.</reqtext>
						</tabularize>
						
						<selectable id="sel-fcs-cop-keyedhash-hmac-sha-1">
							<col>HMAC-SHA-1</col>
							<col><selectables>
								<selectable>(ISO, FIPS) 160</selectable>
								<selectable>(FIPS) 128</selectable></selectables> bits
							</col>
							<col><selectables>
								<selectable>ISO/IEC 9797-2:2021 (Section 7 “MAC Algorithm 2”)</selectable>
								<selectable>FIPS PUB 198-1</selectable></selectables>
							</col>
						</selectable>
					
						<selectable id="sel-fcs-cop-keyedhash-hmac-sha-224">
							<col>HMAC-SHA-224</col>
							<col><selectables>
								<selectable>224 (ISO, FIPS)</selectable>
								<selectable>192 (FIPS)</selectable>
								<selectable>128 (FIPS)</selectable></selectables> bits
							</col>
							<col><selectables>
								<selectable>ISO/IEC 9797-2:2021 (Section 7 “MAC Algorithm 2”)</selectable>
								<selectable>FIPS PUB 198-1</selectable></selectables>
							</col>
						</selectable>
					
						<selectable id="sel-fcs-cop-keyedhash-hmac-sha-256">
							<col>HMAC-SHA-256</col>
							<col><selectables>
								<selectable>256 (ISO, FIPS)</selectable>
								<selectable>192 (FIPS)</selectable>
								<selectable>128 (FIPS)</selectable></selectables> bits
							</col>
							<col><selectables>
								<selectable>ISO/IEC 9797-2:2021 (Section 7 “MAC Algorithm 2”)</selectable>
								<selectable>FIPS PUB 198-1</selectable></selectables>
							</col>
						</selectable>

						<selectable id="sel-fcs-cop-keyedhash-hmac-sha-384">
							<col>HMAC-SHA-384</col>
							<col><selectables>
								<selectable>384 (ISO, FIPS)</selectable>
								<selectable>256 (FIPS)</selectable>
								<selectable>192 (FIPS)</selectable>
								<selectable>128 (FIPS)</selectable></selectables> bits
							</col>
							<col><selectables>
								<selectable>ISO/IEC 9797-2:2021 (Section 7 “MAC Algorithm 2”)</selectable>
								<selectable>FIPS PUB 198-1</selectable></selectables>
							</col>
						</selectable>

						<selectable id="sel-fcs-cop-keyedhash-hmac-sha-512">
							<col>HMAC-SHA-512</col>
							<col><selectables>
								<selectable>512 (ISO, FIPS)</selectable>
								<selectable>384 (FIPS)</selectable>
								<selectable>256 (FIPS)</selectable>
								<selectable>192 (FIPS)</selectable>
								<selectable>128 (FIPS)</selectable></selectables> bits
							</col>
							<col><selectables>
								<selectable>ISO/IEC 9797-2:2021 (Section 7 “MAC Algorithm 2”)</selectable>
								<selectable>FIPS PUB 198-1</selectable></selectables>
							</col>
						</selectable>

						<selectable id="sel-fcs-cop-keyedhash-kmac-128">
							<col>KMAC128</col>
							<col>128 bits</col>
							<col><selectables>
								<selectable>ISO/IEC 9797-2:2021 (Section 9 “MAC Algorithm 4”)</selectable>
								<selectable>NIST SP 800-185 (Section 4 “KMAC”)</selectable></selectables>
							</col>
						</selectable>

						<selectable id="sel-fcs-cop-keyedhash-kmac-256">
							<col>KMAC256</col>
							<col>256 bits</col>
							<col><selectables>
								<selectable>ISO/IEC 9797-2:2021 (Section 9 “MAC Algorithm 4”)</selectable>
								<selectable>NIST SP 800-185 (Section 4 “KMAC”)</selectable></selectables>
							</col>
						</selectable>

						<selectable id="sel-fcs-cop-keyedhash-kmacxof-128">
							<col>KMACXOF128</col>
							<col><assignable>integer 256 le Lk lt 2^2040</assignable></col>
							<col><selectables>
								<selectable>ISO/IEC 9797-2:2021 (Section 9 “MAC Algorithm 4”)</selectable>
								<selectable>NIST SP 800-185 (Section 4 “KMAC”)</selectable></selectables>
							</col>
						</selectable>

						<selectable id="sel-fcs-cop-keyedhash-kmacxof-256">
							<col>KMACXOF256</col>
							<col><assignable>integer 256 le Lk lt 2^2040</assignable></col>
							<col><selectables>
								<selectable>ISO/IEC 9797-2:2021 (Section 9 “MAC Algorithm 4”)</selectable>
								<selectable>NIST SP 800-185 (Section 4 “KMAC”)</selectable></selectables>
							</col>
						</selectable>
					</selectables>
				</title>	
				<note role="application">
					The HMAC minimum key sizes in the table are specified in ISO/IEC 9797-2:2021, which requires that the
					minimum key size be equal to the digest size. The FIPS standard specifies no minimum or maximum 
					key sizes, so if FIPS PUB 198-1 is selected, larger or smaller key sizes may be used. This is 
					indicated by the parenthesized annotations in the Cryptographic Key Sizes column.  <h:p/>
					If “KMACXOF128” or “KMACXOF256” is selected as Keyed Hash Algorithm, then FCS_COP.1/XOF must be claimed.
				</note>
				<aactivity>
					<TSS>TBD
					</TSS>
					<Guidance/>
					<Tests>
						The following tests are conditional based upon the selections made in the SFR. The evaluator
						shall perform the following test or witness respective tests executed by the developer. The tests
						must be executed on a platform that is as close as practically possible to the operational platform
						(but which may be instrumented in terms of, for example, use of a debug mode). Where the test
						is not carried out on the TOE itself, the test platform shall be identified and the differences
						between test environment and TOE execution environment shall be described.<h:p/>

						<!-- HMAC -->
						<h:br/><h:b>HMAC</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Keyed Hash Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">HMAC-SHA-1</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> (ISO, FIPS) 160, (FIPS) 128] bits</h:td>
								<h:td valign="top">
									[<h:b>selection:</h:b> ISO/IEC 9797-2:2021 (Section 7 “MAC Algorithm 2”), FIPS PUB 198-1] </h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">HMAC-SHA-224</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> (ISO, FIPS) 224, (FIPS) 192, 128] bits</h:td>
								<h:td valign="top">
									[<h:b>selection:</h:b> ISO/IEC 9797-2:2021 (Section 7 “MAC Algorithm 2”), FIPS PUB 198-1] </h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">HMAC-SHA-256</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> (ISO, FIPS) 256, (FIPS) 192, 128] bits</h:td>
								<h:td valign="top">
									[<h:b>selection:</h:b> ISO/IEC 9797-2:2021 (Section 7 “MAC Algorithm 2”), FIPS PUB 198-1] </h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">HMAC-SHA-384</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> (ISO, FIPS) 384, (FIPS) 256, 192, 128] bits</h:td>
								<h:td valign="top">
									[<h:b>selection:</h:b> ISO/IEC 9797-2:2021 (Section 7 “MAC Algorithm 2”), FIPS PUB 198-1] </h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">HMAC-SHA-512</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> (ISO, FIPS) 512, (FIPS) 384, 256, 192, 128] bits</h:td>
								<h:td valign="top">
									[<h:b>selection:</h:b> ISO/IEC 9797-2:2021 (Section 7 “MAC Algorithm 2”), FIPS PUB 198-1] </h:td>
							</h:tr>
						</h:table><h:p/>
						To test the TOE’s ability to generate keyed hashes using HMAC the evaluator shall perform the
						Algorithm Functional Test for each combination of claimed HMAC algorithm and key size.<h:p/>
						<h:br/><h:b>Algorithm Functional Test</h:b><h:p/>
						The evaluator shall generate 75 test cases using random data such that the message sizes are
						equally divided between:<h:ul>
						<h:li>Messages that are less than the maximum supported MAC length</h:li>
						<h:li>Messages that are equal to the maximum supported MAC length</h:li>
						<h:li>Messages that are equal to the maximum supported MAC length</h:li></h:ul><h:p/>
						The evaluator shall compare the output against results generated by a known-good
						implementation with the same input.	<h:p/>
						

						<!-- KMAC -->
						<h:br/><h:b>KMAC</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Keyed Hash Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">KMAC128</h:td>
								<h:td valign="top">128 bits</h:td>
								<h:td valign="top">
									[<h:b>selection:</h:b> ISO/IEC 9797-2:2021 (Section 9 “MAC Algorithm 4”),
										NIST SP 800-185 (Section 4 “KMAC”)]  </h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">KMAC256</h:td>
								<h:td valign="top">256 bits</h:td>
								<h:td valign="top">
									[<h:b>selection:</h:b> ISO/IEC 9797-2:2021 (Section 9 “MAC Algorithm 4”),
										NIST SP 800-185 (Section 4 “KMAC”)]  </h:td>
							</h:tr>
						</h:table><h:p/>	
						To test the TOE’s ability to generate keyed hashes using KMAC the evaluator shall perform the
						Algorithm Functional Test and MAC Verification Test for each claimed KMAC algorithm using
						the following input parameters:<h:ul>
						<h:li>Input message length [0-65536] bits</h:li>
						<h:li>Key length [128, 256] bits</h:li>						
						<h:li>Customization bit string length [no range?]</h:li></h:ul><h:p/>
						<h:br/><h:b>Algorithm Functional Test</h:b><h:p/>
						The evaluator shall generate 75 test cases using random data such that the message sizes are
						For each key size, the evaluator shall generate 100 test cases using random data and random
						values for input message length, customization string length, and customization string.<h:p/>
						At least one test case should include minimum supported values for input message length and
						customization string length. Test cases should also include the maximum supported values for
						input message length.<h:p/>
						The evaluator shall compare the output against results generated by a known-good
						implementation with the same input.<h:p/>
						<h:br/><h:b>MAC Verification Tests</h:b><h:p/>
						For each key size, the evaluator shall generate 100 test cases as above. In half of the test cases,
						the evaluator shall modify the MAC so that verification fails.<h:p/>
						The evaluator shall determine that the results are as expected.<h:p/>


						<!-- KMACXOF -->
						<h:br/><h:b>KMACXOF</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Keyed Hash Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">KMACXOF128</h:td>
								<h:td valign="top">[<h:b>assignment:</h:b> integer 256 &#8804; Lk &lt; s<h:sup>2040</h:sup> bits]</h:td>
								<h:td valign="top">
									[<h:b>selection:</h:b> ISO/IEC 9797-2:2021 (Section 9 “MAC Algorithm 4”),
										NIST SP 800-185 (Section 4 “KMAC”)]  </h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">KMACXOF256</h:td>
								<h:td valign="top">[<h:b>assignment:</h:b> integer 256 &#8804; Lk &lt; s<h:sup>2040</h:sup> bits]</h:td>
								<h:td valign="top">
									[<h:b>selection:</h:b> ISO/IEC 9797-2:2021 (Section 9 “MAC Algorithm 4”),
										NIST SP 800-185 (Section 4 “KMAC”)]  </h:td>
							</h:tr>
						</h:table><h:p/>	
						To test the TOE’s ability to generate keyed hashes using KMACXOF the evaluator shall perform
						the Algorithm Functional Test and MAC Verification Test for each claimed KMACXOF
						algorithm using the following input parameters:<h:ul>
						<h:li>Input message length [0-65536] bits</h:li>
						<h:li>Key length [256-524288] bits in increments of 8</h:li>
						<h:li>Customization bit string length [range?]</h:li>
						<h:li>MAC output length [16-65536] bits</h:li></h:ul><h:p/>
						<h:br/><h:b>Algorithm Functional Test</h:b><h:p/>
						For each key size, the evaluator shall generate 100 test cases using random data and random
						values for input message length, key length, customization string length, customization string,
						and MAC output length.<h:p/>
						At least one test case should include minimum suipported values for input message length, key
						length, customization string length, and output MAC length. Test cases should also include the
						maximum supported values for input message length and output MAC length.<h:p/>
						<comment>Should there be one test with all the minimum lengths? Or just make sure they show up
						somewhere among all the tests?</comment>
						The evaluator shall compare the output against results generated by a known-good
						implementation with the same input.<h:p/>
						<h:br/><h:b>MAC Verification Tests</h:b><h:p/>
						For each key size, the evaluator shall generate 100 test cases as above. In half of the test cases,
						the evaluator shall modify the MAC so that verification fails.<h:p/>
						The evaluator shall determine that the results are as expected.<h:p/>

					</Tests>
				</aactivity>
			</f-element>
						<audit-event/>
					</f-component>
				</section>    <!-- FCS_COP.1/KeyedHash -->
				
				<section title="FCS_COP.1/KeyEncap Cryptographic Operation - Key Encapsulation" id="catsec-fcs-cop-1-keyencap">

					<!-- FCS_COP.1/KeyEncap Cryptographic Operation - Key Encapsulation -->
					<f-component id="sfr-fcs-cop-1-keyencap" cc-id="fcs_cop.1" iteration="KeyEncap" name="Cryptographic Operation - Key Encapsulation">

						<comp-rel>
							<hierarchical-to/>
							<dependencies-to>
								<or-dep>
									<comp-ref>FDP_ITC.1 Import of user data without security attributes</comp-ref> 
									<comp-ref>FDP_ITC.2 Import of user data with security attributes</comp-ref> 
									<comp-ref>FCS_CKM.1 Cryptographic key generation</comp-ref>
									<comp-ref>FCS_CKM.5 Cryptographic key derivation</comp-ref>
									<comp-ref>FCS_CKM_EXT.7 Cryptographic key agreement</comp-ref>
									<comp-ref>FCS_CKM_EXT.8 Password-based key derivation</comp-ref>
								</or-dep>
								<comp-ref>FCS_CKM.6 Timing and event of cryptographic key destruction</comp-ref> 
								<or-dep>
									<comp-ref>FCS_COP.1/Hash Hashing</comp-ref>
									<comp-ref>FCS_COP.1/XOF Extendable-Output Function</comp-ref>
								</or-dep>
							</dependencies-to>
						</comp-rel>
				
			<f-element id="fcs-cop-1e1-keyencap">
				<title> The TSF shall perform [key encapsulation] in accordance with a specified cryptographic algorithm 
					<selectables>
						<tabularize id="tab-fcs-cop-keyencap-sels" title="Recommended choices for FCS_COP.1/KeyEncap">
							<textcol>Identifier</textcol>
							<reqtext></reqtext>
							<selectcol>Cryptographic algorithm</selectcol>
							<reqtext>and cryptographic key sizes</reqtext>
							<selectcol>Cryptographic key sizes</selectcol>
							<reqtext>that meet the following:</reqtext>
							<selectcol>List of standards</selectcol>
							<reqtext><h:p/><h:p/>The following table provides the recommended choices for
										completion of the selection operations of FCS_COP.1/KeyEncap.</reqtext>

						</tabularize>
						
						<selectable id="sel-fcs-cop-keyencap-kas1">
							<col>KAS1</col>
							<col>KAS1 [RSA-single party]</col>
						<col><selectables>
							<selectable>2048 bit</selectable>
							<selectable>3072 bit</selectable>
							<selectable>4096 bit</selectable>
							<selectable>8192 bit</selectable>
						</selectables></col>
						<col>NIST SP 800-56B Revision  2 (Sections 6.3 and 8.2)</col>
						</selectable>
						
						<selectable id="sel-fcs-cop-keyencap-kts">
							<col>KTS-OAEP</col>
							<col>KTS-OAEP [RSA-OAEP]</col>
						<col><selectables>
							<selectable>2048 bit</selectable>
							<selectable>3072 bit</selectable>
							<selectable>4096 bit</selectable>
							<selectable>8192 bit</selectable>
						</selectables></col>
						<col>NIST SP 800-56B Revision 2 (Sections 6.3 and 9)</col>
						</selectable>
						
						<selectable id="sel-fcs-cop-keyencap-mlkem">
							<col>ML-KEM</col>
							<col>ML-KEM Key Encapsulation</col>
							<col>Parameter set = <selectables>
								<selectable>ML-KEM-512</selectable>
								<selectable>ML-KEM-768</selectable>
								<selectable>ML-KEM-1024</selectable></selectables>
							</col>
							<col>NIST FIPS 203 (Section 7.2)</col>
						</selectable>			
						
					</selectables>
				</title>
				<note role="application">
					NIST SP 800-57 Part 1 Revision 5 Section 5.6.2 specifies that the size of key used to protect the
					key being transported should be at least the security strength of the key it is protecting.
				</note>
				<aactivity>
					<TSS>TBD</TSS>
					<Guidance>TBD</Guidance>
					<Tests>
						The following tests require the developer to provide access to a test platform that
						provides the evaluator with tools that are typically not found on factory products.<h:p/>
						The following tests are conditional based upon the selections made in the SFR. The
						evaluator shall perform the following test or witness respective tests executed by
						the developer. The tests must be executed on a platform that is as close as practically
						possible to the operational platform (but which may be instrumented in terms of,
						for example, use of a debug mode). Where the test is not carried out on the TOE
						itself, the test platform shall be identified and the differences between test
						environment and TOE execution environment shall be described.<h:p/>

						<!-- KAS1 -->
						<h:br/><h:b>KAS1 [RSA-single party]</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptogrphic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">KAS1</h:td>
								<h:td valign="top">KAS1 [RSA-single party]</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> 2048, 3072, 4096, 8192] bits</h:td>
								<h:td valign="top">NIST SP 800-56B Revision 2 (Sections 6.3 &amp; 8.2)</h:td>
							</h:tr>
						</h:table><h:p/>	
						To test the TOE’s implementation of the of KAS1 RSA Single-Party Key Encapsulation, the
						evaluator shall perform the Algorithm Functional Test and Validation Test using the following
						input parameters:<h:ul>
						<h:li>RSA Private key format [Basic with fixed public exponent, Prime Factor with fixed
							public exponent, Chinese Remainder Theorem with fixed public exponent, Basic with
							random public exponent, Prime Factor with random public exponent, Chinese
							Remainder Theorem with random public exponent] [not broken out by exponent in
							KAS2] (receiver only)??</h:li>
						<h:li>Modulo value [2048, 3072, 4096, 8192]</h:li>
						<h:li>Role [initiator, responder]</h:li>
						<h:li>Key confirmation supported [yes, no] [not included in KAS2]</h:li></h:ul><h:p/>
						The evaluator shall generate a test group (i.e. set of tests) for each parameter value of the above
						parameter type with the largest number of supported values. For example, if the TOE supports all
						six key formats, then the evaluator shall generate six test groups. Each of the above supported
						parameter values must be included in at least one test group.<h:p/>
						Regardless of how many parameter values are supported, there must be at least two test groups.<h:p/>
						Half of the test groups are designated as Algorithm Functional Tests (AFT) and the remainder
						are designated as Validation Tests (VAT). If there is an odd number of groups, then the extra
						group is designated randomly as either AFT or VAT.<h:p/>
						If there are only two test groups, in addition to the above, one shall act as an initiator, and the
						other as a responder, if supported.<h:p/>
						<h:br/><h:b>Algorithm Functional Test</h:b><h:p/>
						For each test group designated as AFT, the evaluator shall generate 10 test cases using random
						data (except for a fixed public exponent, if supported). The resulting shared secrets shall be
						compared with those generated by a known-good implementation using the same inputs.<h:p/>
						<h:br/><h:b>Validation Test</h:b><h:p/>
						For each test group designated as VAT, the evaluator shall generate 25 test cases are using
						random data (except for a fixed public exponent, if supported). Of the 25 test cases:<h:ul>
						<h:li>Two test cases must have a shared secret with a leading nibble of 0s,</h:li>
						<h:li>Two test cases have modified derived key material,</h:li>
						<h:li>Two test cases have modified tags, if key confirmation is supported,</h:li>
						<h:li>Two test cases have modified MACs, if key confirmation is supported, and</h:li>
						<h:li>The remaining test cases are not modified.</h:li></h:ul><h:p/>
						To determine correctness, the evaluator shall confirm that the resulting 25 shared secrets
						correspond as expected for both the modified and unmodified values.<h:p/>

						<!-- KTSOAEP  -->
						<h:br/><h:b>KTS-OAEP [RSAOAEP]</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptogrphic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">KTS-OAEP</h:td>
								<h:td valign="top">KTS-OAEP [RSA-OAEP]</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> 2048, 3072, 4096, 8192] bits</h:td>
								<h:td valign="top">NIST SP 800-56B Revision 2 (Sections 6.3 &amp; 9)</h:td>
							</h:tr>
						</h:table><h:p/>	
						To test the TOE’s implementation of the of KTS-OAEP, the evaluator shall perform the
						Algorithm Functional Test and Validation Test using the following input parameters:<h:ul>
						<h:li>Roles [initiator, receiver]</h:li>
						<h:li>Private Key format [Basic with fixed public exponent, Prime Factor with fixed public
							exponent, Chinese Remainder Theorem with fixed public exponent, Basic with
							random public exponent, Prime Factor with random public exponent, Chinese
							Remainder Theorem with random public exponent] (receiver only)</h:li>
						<h:li>Supported modulo values [2048, 3072, 4096, 8192]</h:li>
						<h:li>Key confirmation supported [yes, no]</h:li></h:ul><h:p/>
						The evaluator shall generate a test group (i.e. set of tests) for each parameter value of the above
						parameter type with the largest number of supported values. For example, if the TOE supports all
						six key formats, then the evaluator shall generate six test groups. Each of the above supported
						parameter values must be included in at least one test group.<h:p/>
						Regardless of how many parameter values are supported, there must be at least two test groups.<h:p/>
						Half of the test groups are designated as Algorithm Functional Tests (AFT) and the remainder
						are designated as Validation Tests (VAT). If there is an odd number of groups, then the extra
						group is designated randomly as either AFT or VAT.<h:p/>
						If there are only two test groups, in addition to the above, one shall act as an initiator, and the
						other as a responder, if supported.<h:p/>
						<h:br/><h:b>Algorithm Functional Test</h:b><h:p/>
						For each test group designated as AFT, the evaluator shall generate 10 test cases using random
						data (except for a fixed public exponent, if supported). The resulting shared secrets shall be
						compared with those generated by a known-good implementation using the same inputs.<h:p/>
						<h:br/><h:b>Validation Test</h:b><h:p/>
						For each test group designated as VAT, the evaluator shall generate 25 test cases are using
						random data (except for a fixed public exponent, if supported). Of the 25 test cases:<h:ul>
						<h:li>Two test cases must have a shared secret with a leading nibble of 0s,</h:li>
						<h:li>Two test cases have modified derived key material,</h:li>
						<h:li>Two test cases have modified tags, if key confirmation is supported,</h:li>
						<h:li>Two test cases have modified MACs, if key confirmation is supported, and</h:li>
						<h:li>The remaining test cases are not modified.</h:li></h:ul><h:p/>
						To determine correctness, the evaluator shall confirm that the resulting 25 shared secrets
						correspond as expected for both the modified and unmodified values.<h:p/>


						<!-- ML-KEM  -->
						<h:br/><h:b>ML-KEM Key Encapsulation</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptogrphic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">ML-KEM</h:td>
								<h:td valign="top">ML-KEM KeyEncap</h:td>
								<h:td valign="top">Parameter set = [<h:b>selection:</h:b> ML-KEM-512,
									ML-KEM-768, ML-KEM-1024]</h:td>
								<h:td valign="top">NIST FIPS PUB 203 (Section 7.2)</h:td>
							</h:tr>
						</h:table><h:p/>	
						To test the TOE’s implementation of ML-KEM key encapsulation/decapsulation, the evaluator
						shall perform the Encapsulation Test and the Decapsulation Test using the following input
						parameters:<h:ul>
						<h:li>Encapsulation Parameters:<h:ul>
							<h:li>Parameter set [ML-KEM-512, ML-KEM-768, ML-KEM-1024]</h:li>
							<h:li>Previously generated encapsulation key (<h:i>ek</h:i>)</h:li>
							<h:li>Random value (<h:i>m</h:i>) [32 bytes]</h:li></h:ul></h:li>
						<h:li>Decapsulation Parameters:<h:ul>
							<h:li>Parameter set [ML-KEM-512, ML-KEM-768, ML-KEM-1024]</h:li>
							<h:li>Previously generated decapsulation key (<h:i>dk</h:i>)</h:li>
							<h:li>Previously generated ciphertext (<h:i>c</h:i>) [32 bytes]</h:li></h:ul></h:li>
						</h:ul><h:p/>
						<h:br/><h:b>Encapsulation Test</h:b><h:p/>
						For each supported parameter set the evaluator shall generate 25 test cases consisting of an
						encapsulation key ek and random value m. For each test case the valuator shall require the
						implementation under test to generate the corresponding shared secret k and ciphertext c. To
						determine correctness, the evaluator shall compare the resulting values with those generated
						using a known-good implementation using the same inputs.<h:p/>
						<h:br/><h:b>Decapsulation Test</h:b><h:p/>
						For each supported parameter set the evaluator shall use a single previously generated
						decapsulation key dk and generate 10 test cases consisting of valid and invalid ciphertexts c. For
						each test case the evaluator shall require the implementation under test to generate the
						corresponding shared secret k whether or not the ciphertext is valid. To determine correctness,
						the evaluator shall compare the resulting values with those generated using a known-good
						implementation using the same inputs.<h:p/>						

					
					</Tests>
				</aactivity>
			</f-element>
						<audit-event/>
					</f-component>
				</section>   <!-- FCS_COP.1/KeyEncap -->
				
				
				<section title="FCS_COP.1/KeyWrap Cryptographic Operation - Key Wrapping" id="catsec-fcs-cop-1-keywrap">

					<h:b>Catalog Guidance Notes</h:b><h:p/>
						Key Wrapping is the encryption of keys with symmetric algorithms. 

					<!-- FCS_COP.1/KeyWrap Cryptographic Operation - Key Wrapping -->
					<f-component id="sfr-fcs-cop-1-kw" cc-id="fcs_cop.1" iteration="KeyWrap" name="Cryptographic Operation - Key Wrapping">

						<comp-rel>
							<hierarchical-to/>
							<dependencies-to>
								<or-dep>
									<comp-ref>FDP_ITC.1 Import of user data without security attributes</comp-ref> 
									<comp-ref>FDP_ITC.2 Import of user data with security attributes</comp-ref> 
									<comp-ref>FCS_CKM.1 Cryptographic key generation</comp-ref>
									<comp-ref>FCS_CKM.5 Cryptographic key derivation</comp-ref>
									<comp-ref>FCS_CKM_EXT.7 Cryptographic key agreement</comp-ref>
									<comp-ref>FCS_CKM_EXT.8 Password-based key derivation</comp-ref>
								</or-dep>
								<comp-ref>FCS_COP.1/Hash Hashing</comp-ref>
								<comp-ref>FCS_COP.1/SKC Symmetric key cryptography</comp-ref>
							</dependencies-to>
						</comp-rel>
			
			<f-element id="fcs-cop-1e1-kw">
				<title>
					The TSF shall perform [key wrapping] in accordance with a specified cryptographic algorithm 
					<selectables>
						<tabularize id="fcs-cop-kw-sels" title="Recommended choices for FCS_COP.1/KeyWrap">
							<textcol>Identifier</textcol>
							<reqtext></reqtext>
							<selectcol>Cryptographic algorithm</selectcol>
							<reqtext>and cryptographic key sizes</reqtext>
							<selectcol>Cryptographic key sizes</selectcol>
							<reqtext>that meet the following:</reqtext>
							<selectcol>List of standards</selectcol>
							<reqtext><h:p/><h:p/>The following table provides the recommended choices for
								completion of the selection operations of FCS_COP.1/KeyWrap.</reqtext>
						</tabularize>
						
						<!-- KW mode -->
						<selectable id="sel-fcs-cop-kw-kw">
							<col>KW</col>
							<col><selectables>
								<selectable>AES</selectable>
								<selectable>CAM</selectable>
								<selectable>SEED</selectable>
								<selectable>LEA</selectable></selectables> in KW mode
							</col>
							<col><selectables>
								<selectable>128 (AES, CAM, SEED, LEA)</selectable>
								<selectable>192 (AES, CAM, LEA)</selectable>
								<selectable>256 (AES, CAM, LEA)</selectable>
							</selectables> bits</col>
							<col><selectables>
								<selectable>ISO/IEC 19772:2020 (clause 6)</selectable>
								<selectable>NIST SP 800-38F (Section 6.2)</selectable> 
							</selectables> [KW mode]</col>
						</selectable>

						<!-- KWP mode -->
						<selectable id="sel-fcs-cop-kw-kwp">
							<col>KWP</col>
							<col><selectables>
								<selectable>AES</selectable>
								<selectable>CAM</selectable>
								<selectable>SEED</selectable>
								<selectable>LEA</selectable></selectables> in KWP mode
							</col>
							<col><selectables>
								<selectable>128 (AES, CAM, SEED, LEA)</selectable>
								<selectable>192 (AES, CAM, LEA)</selectable>
								<selectable>256 (AES, CAM, LEA)</selectable>
							</selectables> bits</col>
							<col>NIST SP 800-38F (Section 6.3) [KWP mode]</col>
						</selectable>

						<!-- CCM mode -->
						<selectable id="sel-fcs-cop-kw-ccm">
							<col>CCM</col>
							<col><selectables>
								<selectable>AES</selectable>
								<selectable>CAM</selectable>
								<selectable>SEED</selectable>
								<selectable>LEA</selectable></selectables> in CCM mode with non-repeating nonce, 
									minimum size of 64 bits
							</col>
							<col><selectables>
								<selectable>128 (AES, CAM, SEED, LEA)</selectable>
								<selectable>192 (AES, CAM, LEA)</selectable>
								<selectable>256 (AES, CAM, LEA)</selectable>
							</selectables> bits</col>
							<col><selectables>
								<selectable>ISO/IEC 19772:2020 (Clause 7)</selectable>
								<selectable>NIST SP 800-38C</selectable> 
							</selectables> [CCM mode]</col>
						</selectable>

						<!-- GCM mode -->
						<selectable id="sel-fcs-cop-kw-gcm">
							<col>GCM</col>
							<col><selectables>
								<selectable>AES</selectable>
								<selectable>CAM</selectable>
								<selectable>SEED</selectable>
								<selectable>LEA</selectable></selectables> in GCM mode with non-repeating IVs
									IV length must be equal to 96 bits; the deterministic IV construction 
									method [SP800-38D, Section 8.2.1] must be used; the MAC length t must be one 
									of the values 96, 104, 112, 120, and 128 bits.
							</col>
							<col><selectables>
								<selectable>128 (AES, CAM, SEED, LEA)</selectable>
								<selectable>192 (AES, CAM, LEA)</selectable>
								<selectable>256 (AES, CAM, LEA)</selectable>
							</selectables> bits</col>
							<col><selectables>
								<selectable>ISO/IEC 19772:2020 (Clause 10)</selectable>
								<selectable>NIST SP 800-38D</selectable> 
							</selectables> [GCM mode]</col>
						</selectable>
					</selectables>
				</title>
				<note role="application">
					NIST 800-57p1rev5 sec. 5.6.2 specifies that the size of key used to protect the key being 
					transported should be at least the security strength of the key it is protecting. <h:p/>
					The SEED algorithm supports keys only of size 128 bits.
				</note>
				<aactivity>
					<TSS>TBD</TSS>
					<Guidance>TBD</Guidance>
					<Tests>
						For tests of GCM modes, see testing for FCS_COP.1/AEAD.<h:p/>
						
						The following tests are conditional based upon the selections made in the SFR. The evaluator
						shall perform the following test or witness respective tests executed by the developer. The tests
						must be executed on a platform that is as close as practically possible to the operational platform
						(but which may be instrumented in terms of, for example, use of a debug mode). Where the test
						is not carried out on the TOE itself, the test platform shall be identified and the differences
						between test environment and TOE execution environment shall be described.<h:p/>
						
						<!-- AES-KW -->
						<h:br/><h:b>AES-KW</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptogrphic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">AES-KW</h:td>
								<h:td valign="top">AES in KW mode</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> 128, 192, 256] bits</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> ISO/IEC 18033-3:2010 (Subclause 5.2),
														FIPS PUB 197] [AES]<h:p/>
													[<h:b>selection:</h:b> ISO/IEC 19772:2020 (clause 6), 
														NIST SP 800-38F (Section 6.2)] [KW mode] </h:td>
							</h:tr>
						</h:table><h:p/>	
						To test the TOE’s ability to wrap keys using AES in Key Wrap mode the evaluator shall perform
						the Algorithm Functional Tests using the following input parameters:<h:ul>
						<h:li>Key size [128, 192, 256] bits</h:li>
						<h:li>Keyword cipher type [cipher, inverse]</h:li>
						<h:li>Payload sizes [832, 2880, 896, 2176, 128, 4096]</h:li></h:ul><h:p/>
						<h:br/><h:b>Algorithm Functional Test</h:b><h:p/>
						The evaluator shall generate 100 encryption test cases using random data for each combination
						of claimed key size, keyword cipher type, and supported payload size from the above set.<h:p/>
						The results shall be compared with those generated by a known-good implementation using the
						same inputs.<h:p/>
						The evaluator shall generate 100 decryption test cases using the same parameters as above, but
						with 15 of each 100 test cases modified to produce an incorrect result.<h:p/>
						To determine correctness, the evaluator shall confirm that the results correspond as expected for
						both the modified and unmodified values.<h:p/>

						<!-- AES-KWP -->
						<h:br/><h:b>AES-KWP</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptogrphic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">AES-KWP</h:td>
								<h:td valign="top">AES in KWP mode</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> 128, 192, 256] bits</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> ISO/IEC 18033-3:2010 (Subclause 5.2),
														FIPS PUB 197] [AES]<h:p/>
													NIST SP 800-38F (Section 6.3) [KWP mode] </h:td>
							</h:tr>
						</h:table><h:p/>	
						To test the TOE’s ability to wrap keys using AES in Key Wrap with Padding mode with padding
						the evaluator shall perform the Algorithm Functional Tests using the following input parameters:<h:ul>
						<h:li>Key size [128, 192, 256] bits</h:li>
						<h:li>Keyword cipher type [cipher, inverse]</h:li>
						<h:li>Payload sizes [656, 736, 8, 4096]</h:li></h:ul><h:p/>
						<h:br/><h:b>Algorithm Functional Test</h:b><h:p/>
						The evaluator shall generate 100 encryption test cases using random data for each combination
						of claimed key size, keyword cipher type, and supported payload size from the above set.<h:p/>
						The results shall be compared with those generated by a known-good implementation using the
						same inputs.<h:p/>
						The evaluator shall generate 100 decryption test cases using the same parameters as above, but
						with 15 of each 100 test cases modified to produce an incorrect result.<h:p/>
						To determine correctness, the evaluator shall confirm that the results correspond as expected for
						both the modified and unmodified values.<h:p/>

						<!-- CAM-KW -->
						<h:br/><h:b>CAM-KW</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptogrphic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">CAM-KW</h:td>
								<h:td valign="top">CAM in KW mode</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> 128, 192, 256] bits</h:td>
								<h:td valign="top">ISO/IEC 18033-3:2010 (Subclause 5.3) [Camellia]<h:p/>
													[<h:b>selection:</h:b> ISO/IEC 19772:2020 (clause 6), 
														NIST SP 800-38F (Section 6.2)] [KW mode] </h:td>
							</h:tr>
						</h:table><h:p/>	

						<!-- CAM-KWP -->
						<h:br/><h:b>CAM-KWP</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptogrphic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">CAM-KWP</h:td>
								<h:td valign="top">CAM in KWP mode</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> 128, 192, 256] bits</h:td>
								<h:td valign="top">ISO/IEC 18033-3:2010 (Subclause 5.3) [Camellia]<h:p/>
													NIST SP 800-38F (Section 6.3) [KWP mode] </h:td>
							</h:tr>
						</h:table><h:p/>	

						<!-- SEED-KW -->
						<h:br/><h:b>SEED-KW</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptogrphic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">SEED-KW</h:td>
								<h:td valign="top">SEED in KW mode</h:td>
								<h:td valign="top">128 bits</h:td>
								<h:td valign="top">ISO/IEC 18033-3:2010 (Subclause 5.4) [SEED]<h:p/>
													[<h:b>selection:</h:b> ISO/IEC 19772:2020 (clause 6), 
														NIST SP 800-38F (Section 6.2)] [KW mode] </h:td>
							</h:tr>
						</h:table><h:p/>	
						To test the TOE’s ability to wrap keys using SEED in Key Wrap mode the evaluator shall
						perform the Algorithm Functional Tests and Additional Negative Tests using the following input
						parameters:<h:ul>
						<h:li>Key size [128] bits</h:li>
						<h:li>Keyword cipher type [cipher, inverse]</h:li>
						<h:li>Payload sizes [<h:ul>
							<h:li>Two sizes that are non-zero multiples of 128 bits (two semi-block lengths)</h:li>
							<h:li>Two sizes that are odd multiples of the semi-block length (64 bits)</h:li>
							<h:li>The largest supported plaintext size less than or equal to 4096 bits]</h:li></h:ul>
						</h:li></h:ul><h:p/>
						<h:br/><h:b>Algorithm Functional Test</h:b><h:p/>
						The evaluator shall generate 100 encryption test cases using random data for each combination
						of claimed key size, keyword cipher type, and supported payload size from the above set.<h:p/>
						The results shall be compared with those generated by a known-good implementation using the
						same inputs.<h:p/>
						The evaluator shall generate 100 decryption test cases using the same parameters as above, but
						with 15 of each 100 test cases modified to produce an incorrect result.<h:p/>
						To determine correctness, the evaluator shall confirm that the results correspond as expected for
						both the modified and unmodified values.<h:p/>
						<h:br/><h:b>Additional Negative Tests</h:b><h:p/>
						In addition to the above, the evaluator shall perform the following tests:<h:p/>
						<h:br/><h:b>Invalid Plaintext Length Test</h:b><h:br/>
						The evaluator shall verify that the implementation rejects attempts to encrypt data with the
						following plaintext sizes:<h:ul>
						<h:li>Plaintext size of 0</h:li>
						<h:li>Plaintext size of 64 bits (one semi-block)</h:li>
						<h:li>Plaintext size not divisible by 64 bits</h:li>
						<h:li>Plaintext size greater than 64 semi-blocks (4096 bits)</h:li></h:ul><h:p/>
						<h:br/><h:b>Invalid Ciphertext Length Test</h:b><h:br/>
						The evaluator shall verify that the implementation rejects attempts to decrypt data with the
						following ciphertext sizes:<h:ul>
						<h:li>Ciphertext size of 0</h:li>
						<h:li>Ciphertext size of 64 bits (one semi-block)</h:li>
						<h:li>Ciphertext size of 128 bits (two semi-blocks)</h:li>						
						<h:li>Ciphertext size not divisible by 64 bits</h:li>
						<h:li>Ciphertext size greater than 65 semi-blocks (4160 bits)</h:li></h:ul><h:p/>
						<h:br/><h:b>Invalid ICV1 Test</h:b><h:br/>
						The evaluator shall verify that the implementation rejects attempts to encrypt data using invalid
						ICV1 values by encrypting any plaintext data eight times using different values for ICV1 as
						follows:<h:ul>
						<h:li>Start with ICV1 of 0xA6A6A6A6A6A6A6A6</h:li>
						<h:li>For each of the 8 tests, change one byte of the ICV1 so that each byte is changed once</h:li>
						<h:li>Verify that the encryption fails for all cases</h:li></h:ul><h:p/>


						<!-- SEED-KWP -->
						<h:br/><h:b>SEED-KWP</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptogrphic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">SEED-KWP</h:td>
								<h:td valign="top">SEED in KWP mode</h:td>
								<h:td valign="top">128 bits</h:td>
								<h:td valign="top">ISO/IEC 18033-3:2010 (Subclause 5.4) [SEED]<h:p/>
													NIST SP 800-38F (Section 6.3) [KWP mode] </h:td>
							</h:tr>
						</h:table><h:p/>	
						To test the TOE’s ability to wrap keys using SEED in Key Wrap with Padding mode the
						evaluator shall perform the Algorithm Functional Tests and Additional Negative Tests using the
						following input parameters:<h:ul>
						<h:li>Key size [128] bits</h:li>
						<h:li>Keyword cipher type [cipher, inverse]</h:li>
						<h:li>Payload sizes [<h:ul>
							<h:li>Four sizes that are non-zero multiples of 8 bits</h:li>
							<h:li>The largest supported plaintext length less than or equal to 4096 bits]</h:li></h:ul>
						</h:li></h:ul><h:p/>
						<h:br/><h:b>Algorithm Functional Test</h:b><h:p/>
						The evaluator shall generate 100 encryption test cases using random data for each combination
						of claimed key size, keyword cipher type, and supported payload size from the above set.<h:p/>
						The results shall be compared with those generated by a known-good implementation using the
						same inputs.<h:p/>
						The evaluator shall generate 100 decryption test cases using the same parameters as above, but
						with 15 of each 100 test cases modified to produce an incorrect result.<h:p/>
						To determine correctness, the evaluator shall confirm that the results correspond as expected for
						both the modified and unmodified values.<h:p/>
						<h:br/><h:b>Additional Negative Tests</h:b><h:p/>
						In addition to the above, the evaluator shall perform the following tests:<h:p/>
						<h:br/><h:b>Invalid Plaintext Length Test</h:b><h:br/>
						The evaluator shall verify that the implementation rejects attempts to encrypt data with the
						following plaintext sizes:<h:ul>
						<h:li>Plaintext size of 0</h:li>
						<h:li>Plaintext size not divisible by 8 bits</h:li>
						<h:li>Plaintext size greater than 64 semi-blocks (4096 bits)</h:li></h:ul><h:p/>
						<h:br/><h:b>Invalid Ciphertext Length Test</h:b><h:br/>
						The evaluator shall verify that the implementation rejects attempts to decrypt data with the
						following ciphertext sizes:<h:ul>
						<h:li>Ciphertext size of 0</h:li>
						<h:li>Ciphertext size of 64 bits (one semi-block)</h:li>
						<h:li>Ciphertext size not divisible by 64 bits</h:li>						
						<h:li>Ciphertext size greater than 65 semi-blocks (4160 bits)</h:li></h:ul><h:p/>
						<h:br/><h:b>Invalid ICV2 Test</h:b><h:br/>
						The evaluator shall verify that the implementation rejects attempts to encrypt data using invalid
						ICV2 values by encrypting any plaintext data eight times using different values for ICV2 as
						follows:<h:ul>
						<h:li>Start with ICV2 of 0xA65959A6</h:li>
						<h:li>For each of the four tests, change one byte of the ICV2 so that each byte is changed once</h:li>
						<h:li>Verify that the encryption fails for all cases</h:li></h:ul><h:p/>
						<h:br/><h:b>Invalid Padding Length Test</h:b><h:br/>
						The evaluator shall generate one ciphertext value with substring [len(P)/8]<h:sub>32</h:sub> of S replaced by each
						of the following 32-bit values, where len(P) is the length of P in bits and []<h:sub>32</h:sub> denotes
						representation of an integer in 32 bits:<h:ul>
						<h:li>[0]<h:sub>32</h:sub></h:li>
						<h:li>[len(P)/8 – 8]<h:sub>32</h:sub></h:li>
						<h:li>[len(P)/8 + 8]<h:sub>32</h:sub></h:li>
						<h:li>[513]<h:sub>32</h:sub></h:li></h:ul>
						The evaluator shall verify that the decrypt?? fails for each input????<h:p/>
						<h:br/><h:b>Invalid Padding Bits Test</h:b><h:br/>
						If the implementation supports plaintext lengths that are not multiples of 64 bits, then the
						evaluator shall run the following test:<h:pre>
						For each PAD length [1-7]
							For each byte in PAD
								Set a zero PAD value
								Replace the current byte by a non-zero value
								Encrypt the resulting plaintext
								Verify that the ciphertext fails to decrypt
						</h:pre><h:p/>
						
						<!-- LEA-KW -->
						<h:br/><h:b>LEA-KW</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptogrphic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">LEA-KW</h:td>
								<h:td valign="top">LEA in KW mode</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> 128, 192, 256] bits</h:td>
								<h:td valign="top">ISO/IEC 29192-2:2019 (Subclause 6.3 [LEA]<h:p/>
													[<h:b>selection:</h:b> ISO/IEC 19772:2020 (clause 6), 
														NIST SP 800-38F (Section 6.2)] [KW mode] </h:td>
							</h:tr>
						</h:table><h:p/>	
						To test the TOE’s ability to wrap keys using LEA in Key Wrap mode the evaluator shall
						perform the Algorithm Functional Tests and Additional Negative Tests using the following input
						parameters:<h:ul>
						<h:li>Key size [128, 192, 256] bits</h:li>
						<h:li>Keyword cipher type [cipher, inverse]</h:li>
						<h:li>Payload sizes [<h:ul>
							<h:li>Two sizes that are non-zero multiples of 128 bits (two semi-block lengths)</h:li>
							<h:li>Two sizes that are odd multiples of the semi-block length (64 bits)</h:li>
							<h:li>The largest supported plaintext size less than or equal to 4096 bits]</h:li></h:ul>
						</h:li></h:ul><h:p/>
						<h:br/><h:b>Algorithm Functional Test</h:b><h:p/>
						The evaluator shall generate 100 encryption test cases using random data for each combination
						of claimed key size, keyword cipher type, and supported payload size from the above set.<h:p/>
						The results shall be compared with those generated by a known-good implementation using the
						same inputs.<h:p/>
						The evaluator shall generate 100 decryption test cases using the same parameters as above, but
						with 15 of each 100 test cases modified to produce an incorrect result.<h:p/>
						To determine correctness, the evaluator shall confirm that the results correspond as expected for
						both the modified and unmodified values.<h:p/>
						<h:br/><h:b>Additional Negative Tests</h:b><h:p/>
						In addition to the above, the evaluator shall perform the following tests:<h:p/>
						<h:br/><h:b>Invalid Plaintext Length Test</h:b><h:br/>
						The evaluator shall verify that the implementation rejects attempts to encrypt data with the
						following plaintext sizes:<h:ul>
						<h:li>Plaintext size of 0</h:li>
						<h:li>Plaintext size of 64 bits (one semi-block)</h:li>
						<h:li>Plaintext size not divisible by 64 bits</h:li>
						<h:li>Plaintext size greater than 64 semi-blocks (4096 bits)</h:li></h:ul><h:p/>
						<h:br/><h:b>Invalid Ciphertext Length Test</h:b><h:br/>
						The evaluator shall verify that the implementation rejects attempts to decrypt data with the
						following ciphertext sizes:<h:ul>
						<h:li>Ciphertext size of 0</h:li>
						<h:li>Ciphertext size of 64 bits (one semi-block)</h:li>
						<h:li>Ciphertext size of 128 bits (two semi-blocks)</h:li>						
						<h:li>Ciphertext size not divisible by 64 bits</h:li>
						<h:li>Ciphertext size greater than 65 semi-blocks (4160 bits)</h:li></h:ul><h:p/>
						<h:br/><h:b>Invalid ICV1 Test</h:b><h:br/>
						The evaluator shall verify that the implementation rejects attempts to encrypt data using invalid
						ICV1 values by encrypting any plaintext data eight times using different values for ICV1 as
						follows:<h:ul>
						<h:li>Start with ICV1 of 0xA6A6A6A6A6A6A6A6</h:li>
						<h:li>For each of the 8 tests, change one byte of the ICV1 so that each byte is changed once</h:li>
						<h:li>Verify that the encryption fails for all cases</h:li></h:ul><h:p/>

						

						<!-- LEA-KWP -->
						<h:br/><h:b>LEA-KWP</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptogrphic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">LEA-KWP</h:td>
								<h:td valign="top">LEA in KWP mode</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> 128, 192, 256] bits</h:td>
								<h:td valign="top">ISO/IEC 29192-2:2019 (Subclause 6.3 [LEA]<h:p/>
													NIST SP 800-38F (Section 6.3) [KWP mode] </h:td>
							</h:tr>
						</h:table><h:p/>	
						To test the TOE’s ability to wrap keys using LEA in Key Wrap with Padding mode the
						evaluator shall perform the Algorithm Functional Tests and Additional Negative Tests using the
						following input parameters:<h:ul>
						<h:li>Key size [128, 192, 256] bits</h:li>
						<h:li>Keyword cipher type [cipher, inverse]</h:li>
						<h:li>Payload sizes [<h:ul>
							<h:li>Four sizes that are non-zero multiples of 8 bits</h:li>
							<h:li>The largest supported plaintext length less than or equal to 4096 bits]</h:li></h:ul>
						</h:li></h:ul><h:p/>
						<h:br/><h:b>Algorithm Functional Test</h:b><h:p/>
						The evaluator shall generate 100 encryption test cases using random data for each combination
						of claimed key size, keyword cipher type, and supported payload size from the above set.<h:p/>
						The results shall be compared with those generated by a known-good implementation using the
						same inputs.<h:p/>
						The evaluator shall generate 100 decryption test cases using the same parameters as above, but
						with 15 of each 100 test cases modified to produce an incorrect result.<h:p/>
						To determine correctness, the evaluator shall confirm that the results correspond as expected for
						both the modified and unmodified values.<h:p/>
						<h:br/><h:b>Additional Negative Tests</h:b><h:p/>
						In addition to the above, the evaluator shall perform the following tests:<h:p/>
						<h:br/><h:b>Invalid Plaintext Length Test</h:b><h:br/>
						The evaluator shall verify that the implementation rejects attempts to encrypt data with the
						following plaintext sizes:<h:ul>
						<h:li>Plaintext size of 0</h:li>
						<h:li>Plaintext size not divisible by 8 bits</h:li>
						<h:li>Plaintext size greater than 64 semi-blocks (4096 bits)</h:li></h:ul><h:p/>
						<h:br/><h:b>Invalid Ciphertext Length Test</h:b><h:br/>
						The evaluator shall verify that the implementation rejects attempts to decrypt data with the
						following ciphertext sizes:<h:ul>
						<h:li>Ciphertext size of 0</h:li>
						<h:li>Ciphertext size of 64 bits (one semi-block)</h:li>
						<h:li>Ciphertext size not divisible by 64 bits</h:li>						
						<h:li>Ciphertext size greater than 65 semi-blocks (4160 bits)</h:li></h:ul><h:p/>
						<h:br/><h:b>Invalid ICV2 Test</h:b><h:br/>
						The evaluator shall verify that the implementation rejects attempts to encrypt data using invalid
						ICV2 values by encrypting any plaintext data eight times using different values for ICV2 as
						follows:<h:ul>
						<h:li>Start with ICV2 of 0xA65959A6</h:li>
						<h:li>For each of the four tests, change one byte of the ICV2 so that each byte is changed once</h:li>
						<h:li>Verify that the encryption fails for all cases</h:li></h:ul><h:p/>
						<h:br/><h:b>Invalid Padding Length Test</h:b><h:br/>
						The evaluator shall generate one ciphertext value with substring [len(P)/8]<h:sub>32</h:sub> of S replaced by each
						of the following 32-bit values, where len(P) is the length of P in bits and []<h:sub>32</h:sub> denotes
						representation of an integer in 32 bits:<h:ul>
						<h:li>[0]<h:sub>32</h:sub></h:li>
						<h:li>[len(P)/8 – 8]<h:sub>32</h:sub></h:li>
						<h:li>[len(P)/8 + 8]<h:sub>32</h:sub></h:li>
						<h:li>[513]<h:sub>32</h:sub></h:li></h:ul>
						The evaluator shall verify that the decrypt?? fails for each input????<h:p/>
						<h:br/><h:b>Invalid Padding Bits Test</h:b><h:br/>
						If the implementation supports plaintext lengths that are not multiples of 64 bits, then the
						evaluator shall run the following test:<h:pre>
						For each PAD length [1-7]
							For each byte in PAD
								Set a zero PAD value
								Replace the current byte by a non-zero value
								Encrypt the resulting plaintext
								Verify that the ciphertext fails to decrypt
						</h:pre><h:p/>

					
					</Tests>
				</aactivity>
			</f-element>
						<audit-event/>
					</f-component>
				</section>   <!-- FCS_COP.1/KeyWrap -->

				
				<section title="FCS_COP.1/SigGen Cryptographic Operation - Signature Generation " id="catsec-fcs-cop-1-siggen">

					<h:b>Catalog Guidance Notes</h:b><h:p/>
					This component is for asymmetric cryptographic algorithms that produce cryptographic
					signatures. For symmetric cryptographic algorithms that produce cryptographic signatures, see
					FCS_COP.1/KeyHash and FCS_COP.1/CMAC.<h:p/>
					DSA is no longer approved for digital signature generation. DSA may be used to verify signatures
					generated prior to the implementation date of FIPS PUB 186-5. The specifications and algorithms
					for DSA are no longer included in FIPS PUB 186-5. They may be found in FIPS PUB 186-4. 

					<!-- FCS_COP.1/SigGen Cryptographic Operation - Signature Generation -->
					<f-component id="sfr-fcs-cop-1-siggen" cc-id="fcs_cop.1" iteration="SigGen" name="Cryptographic Operation - Signature Generation">

						<comp-rel>
							<hierarchical-to/>
							<dependencies-to>
								<or-dep>
									<comp-ref>FDP_ITC.1 Import of user data without security attributes</comp-ref> 
									<comp-ref>FDP_ITC.2 Import of user data with security attributes</comp-ref> 
									<comp-ref>FCS_CKM.1/AKG Asymmetric cryptographic key generation</comp-ref>
									<comp-ref>FCS_CKM.5 Cryptographic key derivation</comp-ref>
								</or-dep>
								<or-dep>
									<comp-ref>FCS_COP.1/Hash Hashing</comp-ref>
									<comp-ref>FCS_COP.1/XOF Extendable-Output Function</comp-ref>
								</or-dep>
								<comp-ref>FCS_OTV_EXT.1</comp-ref> 
								<comp-ref>FCS_CKM.6 Timing and event of cryptographic key destruction</comp-ref> 
							</dependencies-to>
						</comp-rel>
		
			<f-element id="fcs-cop-1e1-siggen">
				<title> The TSF shall perform [digital signature generation] in accordance with a specified 
					cryptographic algorithm 
					<selectables>
						<tabularize id="tab-fcs-cop-siggen-sels" title="Recommended choices for FCS_COP.1/SigGen">
							<textcol>Identifier</textcol>
							<reqtext></reqtext>
							<selectcol>Cryptographic algorithm</selectcol>
							<reqtext>and cryptographic key sizes</reqtext>
							<selectcol>Cryptographic key sizes</selectcol>
							<reqtext>that meet the following:</reqtext>
							<selectcol>List of standards</selectcol>
							<reqtext><h:p/><h:p/>The following table provides the recommended choices for
										completion of the selection operations of FCS_COP.1/SigGen.</reqtext>
						</tabularize>
						
						<selectable id="sel-fcs-cop-siggen-rsa-pkcs">
							<col>RSA-PKCS</col>
							<col>RSASSA-PKCS1-v1_5</col>
							<col>Modulus of size <selectables>
								<selectable>2048</selectable>
								<selectable>3072</selectable>
								<selectable>4096</selectable>
							</selectables> bits, hash or XOF <selectables>
								<selectable>SHA-256</selectable>
								<selectable>SHA-384</selectable>
								<selectable>SHA-512</selectable>
								<selectable>SHA3-256</selectable>
								<selectable>SHA3-384</selectable>
								<selectable>SHA3-512</selectable>
							</selectables></col>
							<col>
								RFC 8017 (Section 8.2) [PKCS #1 v2.2]<h:p/>
								FIPS PUB 186-5 (Section 5.4) [RSASSA-PKCS1-v1_5]
							</col>
						</selectable>

						<selectable id="sel-fcs-cop-siggen-rsa-pss">
							<col>RSA-PSS</col>
							<col>RSASSA-PSS</col>
							<col>Modulus of size <selectables>
								<selectable>2048</selectable>
								<selectable>3072</selectable>
								<selectable>4096</selectable>
							</selectables> bits, hash or XOF <selectables>
								<selectable>SHA-256</selectable>
								<selectable>SHA-384</selectable>
								<selectable>SHA-512</selectable>
								<selectable>SHA3-256</selectable>
								<selectable>SHA3-384</selectable>
								<selectable>SHA3-512</selectable>
								<selectable>SHAKE128</selectable>
								<selectable>SHAKE256</selectable>
							</selectables></col>
							<col>
								RFC 8017 (Section 8.1) [PKCS#1 v2.2]<h:p/>
								FIPS PUB 186-5 (Section 5.4) [RSASSA-PSS]
							</col>
						</selectable>

						<selectable id="sel-fcs-cop-siggen-ecdsa">
							<col>ECDSA</col>
							<col>ECDSA</col> 
							<col>Elliptic Curve <selectables>
								<selectable>NIST P-256</selectable>
								<selectable>brainpoolP256r1</selectable>
								<selectable>NIST P-384</selectable>
								<selectable>brainpoolP384r1</selectable>
								<selectable>NIST P-521</selectable>
								<selectable>brainpoolP512r1</selectable>
							</selectables>, per-message secret number generation <selectables>
								<selectable>extra random bits</selectable>
								<selectable>rejection sampling</selectable>
								<selectable>deterministic</selectable>
							</selectables> and hash or XOF function using<selectables>
								<selectable>SHA-256</selectable>
								<selectable>SHA-384</selectable>
								<selectable>SHA-512</selectable>
								<selectable>SHA3-256</selectable>
								<selectable>SHA3-384</selectable>
								<selectable>SHA3-512</selectable>
								<selectable>SHAKE128</selectable>
								<selectable>SHAKE256</selectable>
							</selectables></col>
							<col><selectables>
									<selectable>ISO/IEC 14888-3:2018 (Subclause 6.6)</selectable>
									<selectable>FIPS PUB 186-5 (Sections 6.3.1, 6.4.1]</selectable>
								</selectables>[ECDSA]<h:p/><selectables>
									<selectable>RFC 5639 (Section 3) [Brainpool Curves]</selectable>
									<selectable>NIST SP-800 186 (Section 4) [NIST Curves]]</selectable>
								</selectables>
							</col>
						</selectable>
						
						<selectable id="sel-fcs-cop-siggen-kcdsa">
							<col>KCDSA</col>
							<col>KCDSA</col> 
							<col>hash function using<selectables>
								<selectable>SHA-224</selectable>
								<selectable>SHA-256</selectable>
								<selectable>SHA-384</selectable>
								<selectable>SHA-512</selectable>
							</selectables></col>
							<col>ISO/IEC 14888-3:2018 (Subclause 6.3) [KCDSA]</col>
						</selectable>

						<selectable id="sel-fcs-cop-siggen-eckcdsa">
							<col>EC-KCDSA</col>
							<col>EC-KCDSA</col> 
							<col>Elliptic Curve <selectables>
								<selectable>P-224</selectable>
								<selectable>P-256</selectable>
								<selectable>B-233</selectable>
								<selectable>B-283</selectable>
								<selectable>K-233</selectable>
								<selectable>K-283</selectable>
							</selectables> using hash <selectables>
								<selectable>SHA-224</selectable>
								<selectable>SHA-256</selectable>
								<selectable>SHA-384</selectable>
								<selectable>SHA-512</selectable>
							</selectables></col>
							<col>ISO/IEC 14888-3:2018 (Subclause 6.7) [EC-KCDSA]<h:p/>
									NIST SP 800-186 (Section 3) [NIST Curves]
							</col>
						</selectable>

						<selectable id="sel-fcs-cop-siggen-eddsa">
							<col>EdDSA</col>
							<col>Edwards-Curve Digital Signature Algorithm </col> 
							<col>Domain parameters approved for elliptic curves <selectables>
								<selectable>Edwards25519</selectable>
								<selectable>Edwards448</selectable>
							</selectables></col>
							<col>NIST FIPS PUB 186-5 (Section 7.6) [EdDSA]<h:p/>
									RFC 8032 [Edwards Curves]
							</col>
						</selectable>

						
						<!-- LMS -->
						<selectable id="sel-fcs-cop-siggen-lms">
							<col>LMS</col>
							<col>LMS</col>
							<col>Private key size = <selectables>
								<selectable>192 bits with <selectables>
									<selectable>SHA-256/192</selectable>
									<selectable>SHAKE256/192</selectable>
								</selectables></selectable>
								<selectable>256 bits with <selectables>
									<selectable>SHA-256</selectable>
									<selectable>SHAKE256</selectable>
								</selectables></selectable>
								</selectables><h:p/>
								Winternitz parameter = <selectables>
									<selectable>1</selectable>
									<selectable>2</selectable>
									<selectable>4</selectable>
									<selectable>8</selectable></selectables><h:p/>
								Tree height = <selectables>
									<selectable>5</selectable>
									<selectable>10</selectable>
									<selectable>15</selectable>
									<selectable>20</selectable>
									<selectable>25</selectable></selectables>
							</col>
							<col>RFC 8554 [LMS]<h:p/>
								 NIST SP 800-208 [parameters]
							</col>
						</selectable>
						
						<!-- HSS -->
						<selectable id="sel-fcs-cop-siggen-hss">
							<col>HSS</col>
							<col>Multitree version of LMS</col>
							<col>Private key size = <selectables>
								<selectable>192 bits with <selectables>
									<selectable>SHA-256/192</selectable>
									<selectable>SHAKE256/192</selectable>
								</selectables></selectable>
								<selectable>256 bits with <selectables>
									<selectable>SHA-256</selectable>
									<selectable>SHAKE256</selectable>
								</selectables></selectable>
								</selectables><h:p/>
								Winternitz parameter = <selectables>
									<selectable>1</selectable>
									<selectable>2</selectable>
									<selectable>4</selectable>
									<selectable>8</selectable></selectables><h:p/>
								Tree height = <selectables>
									<selectable>5</selectable>
									<selectable>10</selectable>
									<selectable>15</selectable>
									<selectable>20</selectable>
									<selectable>25</selectable></selectables><h:p/>
								Number of levels = <selectables>
									<selectable>1</selectable>
									<selectable>2</selectable>
									<selectable>3</selectable>
									<selectable>4</selectable>
									<selectable>5</selectable>
									<selectable>6</selectable>
									<selectable>7</selectable>
									<selectable>8</selectable></selectables>
							</col>
							<col>RFC 8554 [HSS]<h:p/>
								 NIST SP 800-208 [parameters]
							</col>
						</selectable>
						
						<!-- XMSS -->
						<selectable id="sel-fcs-cop-siggen-xmss">
							<col>XMSS</col>
							<col>XMSS</col>
							<col>Private key size = <selectables>
								<selectable>192 bits with <selectables>
									<selectable>SHA-256/192</selectable>
									<selectable>SHAKE256/192</selectable>
								</selectables></selectable>
								<selectable>256 bits with <selectables>
									<selectable>SHA-256</selectable>
									<selectable>SHAKE256</selectable>
								</selectables></selectable>
								</selectables><h:p/>
								Tree height = <selectables>
									<selectable>10</selectable>
									<selectable>16</selectable>
									<selectable>20</selectable>
								</selectables>
							</col>
							<col>RFC 8391 [XMSS]<h:p/>
								 NIST SP 800-208 [parameters]
							</col>
						</selectable>

						<!-- ML-DSA Signature Generation -->
						<selectable id="sel-fcs-cop-siggen-mldsa">
							<col>ML-DSA</col>
							<col>ML-DSA Signature Generation</col>
							<col>Perameter set = <selectables>
								<selectable>ML-DSA-44</selectable>
								<selectable>ML-DSA-65</selectable>
								<selectable>ML-DSA-87</selectable>
								</selectables>
							</col>
							<col>NIST FIPS 204 (Section 5.2)</col>
						</selectable>

					</selectables>
				</title>
				<note role="application">			
					This SFR must be included in the ST if digital signature generation is a service provided by the TOE to 
					tenant software, or if digital signature generation is used by the TOE itself to support or implement 
					PP-specified security functionality.<h:p/> 
					Specifically, this SFR must be included if "<h:i>A digital signature of the stored key in accordance with FCS_COP.1/SigGen
					using an asymmetric key that is protected in accordance with FCS_STG_EXT.2</h:i>" is selected in FCS_STG_EXT.3.<h:p/>
					If this SFR is included in the ST, then FCS_COP.1/Hash and FCS_RBG.1 must also be claimed.<h:p/>
					<comment>From catalog</comment>The dependency on FCS_OTV_EXT.1 is needed only for signature schemes that require random
					bits, such as ECDSA, LMS, HSS, XMSS, XMSS<h:sup>MT</h:sup>, and ML-DSA. 
				</note>
				<aactivity>
					<TSS>TBD</TSS>
					<Guidance/>
					<Tests>
						The following tests are conditional based upon the selections made in the SFR. The evaluator
						shall perform the following test or witness respective tests executed by the developer. The tests
						must be executed on a platform that is as close as practically possible to the operational platform
						(but which may be instrumented in terms of, for example, use of a debug mode). Where the test
						is not carried out on the TOE itself, the test platform shall be identified and the differences
						between test environment and TOE execution environment shall be described.<h:p/>
					
						<!-- RSA-PKCS Signature Gneration   -->
						<h:br/><h:b>RSA-PKCS Signature Gneration </h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptogrphic Algorithm Parameters</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">RSA-PKCS </h:td>
								<h:td valign="top">RSASSA-PKCS1-v1_5</h:td>
								<h:td valign="top">Modulus of size [<h:b>selection:</h:b> 2048, 3072, 4096] bits,
									hash or XOF [<h:b>selection:</h:b> SHA-256, SHA-384, SHA-512, SHA3-256, SHA3-384,
												SHA3-512]</h:td>
								<h:td valign="top">RFC 8017 (Section 8.2) [PKCS #1 v2.2]<h:p/>
													NIST FIPS PUB 186-5 (Section 5.4) [RSASSA-PKCS1-v1_5]</h:td>
							</h:tr>
						</h:table><h:p/>	
						To test the TOE’s ability to perform RSA Digital Signature Generation using PKCS1-v1,5
						signature type, the evaluator shall perform the Generated Data Test using the following input
						parameters:<h:ul>
						<h:li>Modulus size [2048, 3072, 4096] bits</h:li>
						<h:li>Hash algorithm [SHA-256, SHA-384, SHA-512, SHA3-256, SHA3-384, SHA3-512]</h:li></h:ul><h:p/>
						<h:br/><h:b>Generated Data Test</h:b><h:p/>
						For each supported combination of the above parameters, the evaluator shall cause the TOE to
						generate three test cases using random data. The evaluator shall compare the results against those
						from a known-good implementation.<h:p/>
						

						<!-- RSA-PSS Signature Gneration    -->
						<h:br/><h:b>RSA-PSS Signature Gneration </h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptogrphic Algorithm Parameters</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">RSA-PSS</h:td>
								<h:td valign="top">RSASSA-PSS</h:td>
								<h:td valign="top">Modulus of size [<h:b>selection:</h:b> 2048, 3072, 4096] bits,
									hash or XOF [<h:b>selection:</h:b> SHA-256, SHA-384, SHA-512, SHA3-256, SHA3-384,
												SHA3-512, SHAKE128, SHAKE256]</h:td>
								<h:td valign="top">RFC 8017 (Section 8.2) [PKCS #1 v2.2]<h:p/>
													NIST FIPS PUB 186-5 (Section 5.4) [RSASSA-PSS]</h:td>
							</h:tr>
						</h:table><h:p/>	
						To test the TOE’s ability to perform RSA Digital Signature Generation using PSS signature type,
						the evaluator shall perform the Generated Data Test using the following input parameters:<h:ul>
						<h:li>Modulus size [2048, 3072, 4096] bits</h:li>
						<h:li>Hash or XOF algorithm [SHA-256, SHA-384, SHA-512, SHA3-256, SHA3-384, SHA3-
							512, SHAKE128, SHAKE25]</h:li>
						<h:li>Salt length [0-hash length] bits Is this paired with hash alg?</h:li>
						<h:li>Mask function [MGF1, SHAKE128, SHAKE256]</h:li></h:ul><h:p/>
						<h:br/><h:b>Generated Data Test</h:b><h:p/>
						For each supported combination of the above parameters, the evaluator shall cause the TOE to
						generate three test cases using random data. The evaluator shall compare the reulsts against those
						from a known-good implementation.<h:p/>
						

						<!-- ECDSA Signature Gneration  -->
						<h:br/><h:b>ECDSA Signature Gneration </h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptogrphic Algorithm Parameters</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">ECDSA</h:td>
								<h:td valign="top">ECDSA</h:td>
								<h:td valign="top">Elliptic Curve [<h:b>selection:</h:b> P-256, brainpoolP256r1, P-384,
									brainpoolP384r1, P-521, brainpoolP512r1], per-message secret number generation
									[<h:b>selection:</h:b> extra random bits, rejection sampling, deterministic] 
									and hash or XOF function using [<h:b>selection:</h:b> SHA256, SHA-384, SHA-512,
									SHA3-256, SHA3-384, SHA3-512, SHAKE-128, SHAKE256] </h:td>
								<h:td valign="top">[<h:b>selection:</h:b> ISO/IEC 14888-3:2018 (Subclause 6.6),
									NIST FIPS PUB 186-5 (Sections 6.3.1, 6.4.1] [ECDSA]<h:p/>
									[<h:b>selection:</h:b> RFC 5639 (Section 3) [Brainpool Curves], 
										NIST SP-800 186 (Section 4) [NIST Curves]] </h:td>
							</h:tr>
						</h:table><h:p/>	
						To test the TOE’s ability to perform ECDSA Digital Signature Generation using extra random
						bits or rejection sampling for secret number generation, the evaluator shall perform the
						Algorithm Functional Test using the following input parameters:<h:ul>
						<h:li>Ellliptic Curve [P-256, brainpoolP256r1, P-384, brainpoolP384r1, P-521,
							brainpoolP512r1]</h:li>
						<h:li>Hash algorithm [SHA-256, SHA-384, SHA-512, SHA3-256, SHA3-384, SHA3-512,
							SHAKE-128, SHAKE-256]</h:li></h:ul><h:p/>
						To test the TOE’s ability to perform ECDSA Digital Signature Generation using deterministic
						secret number generation, the evaluator shall perform the Algorithm Functional Test using the
						following input parameters:	<h:ul>
						<h:li>Ellliptic Curve [P-256, brainpoolP256r1, P-384, brainpoolP384r1, P-521,
							brainpoolP512r1]</h:li>
						<h:li>Hash algorithm [SHA-256, SHA-384, SHA-512, SHA3-256, SHA3-384, SHA3-512]</h:li></h:ul><h:p/>
						<h:br/><h:b>Algorithm Functional Test</h:b><h:p/>
						For each supported combination of the above parameters, the evaluator shall cause the TOE to
						generate 10 test cases using random data. The evaluator shall compare the results against those
						from a known-good implementation.<h:p/>

						<!-- KCDSA Signature Gneration  -->
						<h:br/><h:b>KCDSA Signature Gneration </h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptogrphic Algorithm Parameters</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">KCDSA</h:td>
								<h:td valign="top">KCDSA</h:td>
								<h:td valign="top">Hash function using [<h:b>selection:</h:b> SHA-224, SHA-256, SHA-384, SHA-512] </h:td>
								<h:td valign="top">ISO/IEC 14888-3:2018 (Subclause 6.3) [KCDSA]  </h:td>
							</h:tr>
						</h:table><h:p/>	
						To test the TOE’s ability to perform KCDSA Digital Signature Generation, the evaluator shall
						perform the Algorithm Functional Test using the following input parameters:<h:ul>
						<h:li>Length in bits of prime p [2048, 3072]</h:li>
						<h:li>Length in bits of q [224, 256]</h:li>
						<h:li>Values of L and N: [(2048, 224), (2048, 256), (3072, 256)]</h:li>
						<h:li>Hash algorithm [SHA-224, SHA-256, SHA-384, SHA-512]</h:li></h:ul><h:p/>
						<h:br/><h:b>Algorithm Functional Test</h:b><h:p/>
						For each supported combination of the above parameters, the evaluator shall cause the TOE to
						generate 10 test cases using random data. The evaluator shall compare the results against those
						from a known-good implementation.<h:p/>

						<!-- EC-KCDSA Signature Gneration  -->
						<h:br/><h:b>EC-KCDSA Signature Gneration </h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptogrphic Algorithm Parameters</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">EC-KCDSA</h:td>
								<h:td valign="top">EC-KCDSA</h:td>
								<h:td valign="top">Elliptic Curve [<h:b>selection:</h:b> P-224, P-256, B-233, B-283,
									K-233, K-283] using hash [<h:b>selection:</h:b> SHA-224, SHA-256, SHA-384, SHA-512] </h:td>
								<h:td valign="top">ISO/IEC 14888-3:2018 (Subclause 6.7) [EC-KCDSA] <h:p/>
									NIST SP 800-186 (Section 3) [NIST Curves]  </h:td>
							</h:tr>
						</h:table><h:p/>	
						To test the TOE’s ability to perform EC-KCDSA Digital Signature Generation using extra
						random bits or rejection sampling for secret number generation, the evaluator shall perform the
						Algorithm Functional Test using the following input parameters:<h:ul>
						<h:li>Ellliptic Curve [P-224, P-256, B-233, B-283, K-233, K-283]</h:li>
						<h:li>Hash algorithm [SHA-224, SHA-256, SHA-384, SHA-512]</h:li></h:ul><h:p/>
						<h:br/><h:b>Algorithm Functional Test</h:b><h:p/>
						For each supported combination of the above parameters, the evaluator shall cause the TOE to
						generate 10 test cases using random data. The evaluator shall compare the results against those
						from a known-good implementation.<h:p/>

						<!-- EdDSA Signature Gneration  -->
						<h:br/><h:b>EdDSA Signature Gneration </h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptogrphic Algorithm Parameters</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">EdDSA</h:td>
								<h:td valign="top">Edwards-Curve Digital Signature Algorithm</h:td>
								<h:td valign="top">Domain parameters approved for elliptic curves [<h:b>selection:</h:b>
										Edwards25519, Edwards448] </h:td>
								<h:td valign="top"> NIST FIPS PUB 186-5 (Section 7.6) [EdDSA]<h:p/>
										RFC 8032 [Edwards Curves]</h:td>
							</h:tr>
						</h:table><h:p/>	
						To test the TOE’s ability to perform EdDSA Digital Signature Generation, the evaluator shall
						perform the Algorithm Functional Test and Bit Flip Test using the following input parameters:<h:ul>
						<h:li>Ellliptic Curve [Edwards25519, Edwards448]</h:li>
						<h:li>Length context string [0-255] bytes<h:ul>
							<h:li>Context string is required for curve Edwards448 or PreHash EdDSA</h:li>
							<h:li>Context string is not allowed for curve Edwards25519 when Pure EdDSA
								(required for 448 currve or prehash) (not allowed when 25519 and PreHash is
								false)</h:li></h:ul>
						<h:li>Supports [Pure EdDSA, PreHash EdDSA]</h:li></h:ul><h:p/>
						<h:br/><h:b>Algorithm Functional Test</h:b><h:p/>
						For each supported combination of the above parameters, the evaluator shall cause the TOE to
						generate 10 test cases using random data. The evaluator shall compare the results against those
						from a known-good implementation.<h:p/>
						<h:br/><h:b>Bit Flip Test</h:b><h:p/>
						For this test, the evaluator shall flip individual bits in a message to ensure that the TOE produces
						distinct signatures for each message. How many of these? Do we compare signed bit flip
						message with signed original message to make sure different?<h:p/>

						<!-- LMS and HSS Signature Gneration  -->
						<h:br/><h:b>LMS and HSS Signature Gneration </h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptogrphic Algorithm Parameters</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">LMS</h:td>
								<h:td valign="top">LMS</h:td>
								<h:td valign="top">Private key size = [<h:b>selection:</h:b>
									192 bits with [<h:b>selection:</h:b> SHA256/192, SHAKE256/192], 
									256 bits with [<h:b>selection:</h:b> SHA-256, SHAKE256]] , 
									Winternitz parameter = [<h:b>selection:</h:b> 1, 2, 4, 8], 
									and tree height = [<h:b>selection:</h:b> 5, 10, 15, 20, 25] </h:td>
								<h:td valign="top">RFC 8554 [LMS]<h:p/>
										NIST SP 800-208 [parameters] </h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">HSS</h:td>
								<h:td valign="top">Multitree version of LMS</h:td>
								<h:td valign="top">Private key size = [<h:b>selection:</h:b>
									192 bits with [<h:b>selection:</h:b> SHA256/192, SHAKE256/192], 
									256 bits with [<h:b>selection:</h:b> SHA-256, SHAKE256]] , 
									Winternitz parameter = [<h:b>selection:</h:b> 1, 2, 4, 8], 
									tree height = [<h:b>selection:</h:b> 5, 10, 15, 20, 25] 
									and number of levels [<h:b>selection:</h:b> 1, 2, 3, 4, 5, 6, 7, 8]</h:td>
								<h:td valign="top">RFC 8554 [HSS]<h:p/>
										NIST SP 800-208 [parameters]</h:td>
							</h:tr>
						</h:table><h:p/>	
						To test the TOE’s ability to generate cryptographic digital signature using LMS or HSS, the
						evaluator shall perform the Algorithm Functional Test using the following input parameters:<h:ul>
						<h:li>Hash algorithm [SHA-256/192, SHAKE256/192, SHA-256, SHAKE256]</h:li>
						<h:li>Winterlitz [1, 2, 4, 8]</h:li>
						<h:li>Tree height [5, 10, 15, 20, 25]</h:li>
						<h:li>Number of levels [1, 2, 3, 4, 5, 6, 7, 8] (HSS only)</h:li></h:ul><h:p/>
						<h:br/><h:b>Algorithm Functional Test</h:b><h:p/>
						For each supported combination of the above parameters, the evaluator shall generate 10
						signatures. The evaluator shall verify the correctness of the implementation by comparing values
						generated by the TOE with those generated by a known good implementation using the same
						input parameters.<h:p/>
						For HSS, use the hierarchy created during the key generation using LMS trees. Level 1 testing is
						equivalent to an LMS test. At each supported level 2 through 8, generate 4 HSS signatures for
						each LMS tree found at that level. The evaluator shall verify the correctness of the
						implementation by comparing values generated by the TOE with those generated by a known
						good implementation using the same input parameters.<h:p/>

						<!-- XMSS and XMSSMT Signature Gneration  -->
						<h:br/><h:b>XMSS and XMSS<h:sup>MT</h:sup> Signature Gneration</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptogrphic Algorithm Parameters</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">XMSS</h:td>
								<h:td valign="top">XMSS</h:td>
								<h:td valign="top">Private key size = [<h:b>selection:</h:b>
									192 bits with [<h:b>selection:</h:b> SHA256/192, SHAKE256/192], 
									256 bits with [<h:b>selection:</h:b> SHA-256, SHAKE256]] , 
									and tree height = [<h:b>selection:</h:b> 10, 16, 20] </h:td>
								<h:td valign="top">RFC 8391 [XMSS] <h:p/>
										NIST SP 800-208 [parameters]</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">XMSS<h:sup>MT</h:sup></h:td>
								<h:td valign="top">Multitree version of XMSS</h:td>
								<h:td valign="top">Private key size = [<h:b>selection:</h:b>
									192 bits with [<h:b>selection:</h:b> SHA256/192, SHAKE256/192], 
									256 bits with [<h:b>selection:</h:b> SHA-256, SHAKE256]] , 
									(total tree height, number of levels) = [<h:b>selection:</h:b>
										(20, 2), (20, 4), (40, 2), (40, 4),
										(40, 8), (60, 3), (60, 6), (60, 12)] </h:td>
								<h:td valign="top">RFC 8391 [XMSS<h:sup>MT</h:sup>] <h:p/>
										NIST SP 800-208 [parameters]</h:td>
							</h:tr>
						</h:table><h:p/>	
						To test the TOE’s ability to generate digital signatures using XMSS or XMSS<h:sup>MT</h:sup> , the evaluator
						shall perform the XMSS Key Generation Test using the following input parameters:<h:ul>
						<h:li>Hash algorithm [SHA-256/192, SHAKE256/192, SHA-256, SHAKE256]</h:li>
						<h:li>Tree height [10, 16, 20] (XMSS only)</h:li>
						<h:li>Tree height/levels [20/2, 20/4, 40/2, 40/4, 40/8, 60/3, 60/6, 60/12] (XMSS<h:sup>MT</h:sup> only)</h:li></h:ul><h:p/>
						<h:br/><h:b>XMSS Key Generation Test</h:b><h:p/>
						For each supported combination of the above parameters, the evaluator shall generate the
						following number of keys depending on the tree height:<h:p/>
						<h:b><h:div style="text-align: center;">
						<ctr ctr-type="Table" pre="Table " id="xmss-siggen-test-cases">: Number of Test Cases for XMSS and XMSS<h:sup>MT</h:sup></ctr>
						</h:div></h:b>
						<h:table border="1" style="width:50%">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Height</h:td>
								<h:td valign="top">Number of test cases</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">10</h:td>
								<h:td valign="top">5</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">20</h:td>
								<h:td valign="top">3</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">40</h:td>
								<h:td valign="top">2</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">60</h:td>
								<h:td valign="top">1</h:td>
							</h:tr>
						</h:table><h:p/>										
						Note: The number of test cases is limited due to the extreme amount of time it can take to
						generate XMSS trees.<h:p/>
						The evaluator shall verify the correctness of the TSF’s implementation by comparing values
						generated by the TSF with those generated by a known good implementation using the same
						input parameters.<h:p/>
						
						<!-- ML-DSA Signature Gneration  -->
						<h:br/><h:b>ML-DSA Signature Gneration</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptogrphic Algorithm Parameters</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">ML-DSA</h:td>
								<h:td valign="top">ML-DSA SigGen</h:td>
								<h:td valign="top">Parameter set = [<h:b>selection:</h:b>
									ML-DSA-44, ML-DSA-65, ML-DSA-87]</h:td>
								<h:td valign="top">NIST FIPS PUB 204 (Section 5.2)</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">HashML-DSA</h:td>
								<h:td valign="top">HashML-DSA SigGen</h:td>
								<h:td valign="top">Parameter set = [<h:b>selection:</h:b>
									ML-DSA-44, ML-DSA-65, ML-DSA-87], and hash Function
									[<h:b>selection:</h:b> SHA-256, SHA-512/256, SHA3-256, 
										SHAKE128, SHA-384, SHA3-384, SHA-512, SHA3-512,
										SHAKE256]  </h:td>
								<h:td valign="top">NIST FIPS PUB 204 (Section 5.4)</h:td>
							</h:tr>
						</h:table><h:p/>	
						To test the TOE’s ability to generate digital signatures using ML-DSA and HashML-DSA, the
						evaluator shall perform the Algorithm Functional Test using the following input parameters:<h:ul>
						<h:li>Parameter set [ML-DSA-44, ML-DSA-65, ML-DSA-87]</h:li>
						<h:li>Seed [32 random bytes] (for non-deterministic signature testing), or</h:li>
						<h:li>Seed [32 zero bytes] (for deterministic signature testing)</h:li>
						<h:li>Message to sign [8-65535] bytes</h:li>
						<h:li><h:i>Mu</h:i> value (if generated externally)</h:li>
						<h:li>Previously generated private key (<h:i>sk</h:i>)</h:li>
						<h:li>Context (for external interface testing)</h:li>
						<h:li>Hash algorithm (HashML-DSA only)</h:li></h:ul><h:p/>
						The permitted hash algorithms for HashML-DSA testing are as follows:<h:ul>
						<h:li>HashML-DSA-87 [SHA-512, SHA3-512, SHAKE256]</h:li>
						<h:li>HashML-DSA-65, above plus [SHA-384, SHA3-384]</h:li>
						<h:li>HashML-DSA-44, above plus [SHA-256, SHA-512/256, SHA3-256, SHAKE128]</h:li></h:ul><h:p/>
						<h:br/><h:b>Algorithm Functional Test</h:b><h:p/>
						For each combination of supported parameter set and capabilities, the evaluator shall require the
						implementation under test to generate 15 signatures pairs using 15 different randomly generated
						32-byte seed values. For HashML-DSA testing, each supported and permitted hash or XOF need
						appear in only one of each group of 15 test cases. To determine correctness, the evaluator shall
						compare the resulting key pairs with those generated using a known-good implementation using
						the same inputs.<h:p/>
						<h:br/><h:b>Known Answer Test for Rejection Cases</h:b><h:p/>
						For each supported parameter set, the evaluator shall cause the TOE to generate signatures using
						the data in the below table and a deterministic seed of all 0’s. Correctness is determined by
						comparing the hash of the resulting signature with the hash in the 5 th column.<h:p/>
						<h:b><h:div style="text-align: center;">
						<ctr ctr-type="Table" pre="Table " id="mldsa-siggen-kat-rej">: ML-DSA sigGen Known Answer Tests for Rejection Cases</ctr>
						</h:div></h:b>
						<h:table border="1" style="width:50%">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Security Level</h:td>
								<h:td valign="top">Seed to generate Key pair</h:td>
								<h:td valign="top">Hash of keys SHA-256(pk||sk)</h:td>
								<h:td valign="top">Message</h:td>
								<h:td valign="top">Hash of Resulting Signature SHA-256(sig)</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">ML-DSA-44</h:td>
								<h:td valign="top">
									5C624FCC 18624524<h:br/>
									52D0C665 840D8237<h:br/>
									F43108E5 499EDCDC<h:br/>
									108FBC49 D596E4B7</h:td>
								<h:td valign="top">
									AC825C59 D8A4C453<h:br/>
									A2C4EFEA 8395741C<h:br/>
									A404F300 0E28D56B<h:br/>
									25D03BB4 02E5CB2F</h:td>
								<h:td valign="top">
									951FDF54 73A4CBA6<h:br/>
									D9E5B5DB 7E79FB81<h:br/>
									73921BA5 B13E9271<h:br/>
									401B8F90 7B8B7D5B<h:br/>
								</h:td>
								<h:td valign="top">
									DCC71A42 1BC6FFAF<h:br/>
									B7DF0C7F 6D018A19<h:br/>
									ADA154D1 E2EE360E<h:br/>
									D533CECD 5DC980AD</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
								<h:td valign="top">4</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
								<h:td valign="top">4</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
								<h:td valign="top">4</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
								<h:td valign="top">4</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
								<h:td valign="top">4</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
								<h:td valign="top">4</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
								<h:td valign="top">4</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
								<h:td valign="top">4</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
								<h:td valign="top">4</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
								<h:td valign="top">4</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
								<h:td valign="top">4</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
								<h:td valign="top">4</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
								<h:td valign="top">4</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
								<h:td valign="top">4</h:td>
							</h:tr>
						</h:table><h:p/>										
						
						<h:br/><h:b>Known Answer Test for Large Number of Rejection Cases</h:b><h:p/>
						For each supported parameter set, the evaluator shall cause the TOE to generate signatures using
						the data in the below table and a deterministic seed of all 0’s. Correctness is determined by
						comparing the hash of the resulting signature with the hash in the 6 th column.<h:p/>
						<h:b><h:div style="text-align: center;">
						<ctr ctr-type="Table" pre="Table " id="mldsa-siggen-kat-lnrej">: ML-DSA sigGen Known Answer Tests for Large Number of Rejection Cases</ctr>
						</h:div></h:b>
						<h:table border="1" style="width:50%">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Security Level</h:td>
								<h:td valign="top">Rejection Count</h:td>
								<h:td valign="top">Seed to generate Key pair</h:td>
								<h:td valign="top">Hash of keys SHA-256(pk||sk)</h:td>
								<h:td valign="top">Message</h:td>
								<h:td valign="top">Hash of Resulting Signature SHA-256(sig)</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">ML-DSA-44</h:td>
								<h:td valign="top">77</h:td>
								<h:td valign="top">
									090D97C1 F4166EB3<h:br/>
									2CA67C5F B564ACBE<h:br/>
									0735DB4A F4B8DB3A<h:br/>
									7C2CE740 2357CA44</h:td>
								<h:td valign="top">
									26D79E40 68040E99<h:br/>
									6BC9EB50 34C20489<h:br/>
									C0AD38DC 2FEC1918<h:br/>
									D0760C86 21872408</h:td>
								<h:td valign="top">
									E3838364 B37F47ED<h:br/>
									FCA2B577 B20B80C3<h:br/>
									CB51B9F5 6E0E4CDB<h:br/>
									7DF002C8 74039252</h:td>
								<h:td valign="top">
									CD91150C 610FF02D<h:br/>
									E1DD7049 C309EFE8<h:br/>
									00CE5C1B C2E5A32D<h:br/>
									752AB62C 5BF5E16F</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">16</h:td>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
								<h:td valign="top">4</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">16</h:td>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
								<h:td valign="top">4</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">16</h:td>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
								<h:td valign="top">4</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">16</h:td>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
								<h:td valign="top">4</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">16</h:td>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
								<h:td valign="top">16</h:td>
								<h:td valign="top">4</h:td>
								<h:td valign="top">4</h:td>
							</h:tr>
						</h:table><h:p/>										

					</Tests>
				</aactivity>
			</f-element>
						<audit-event/>
					</f-component>
				</section>   <!-- FCS_COP.1/SigGen -->

				<section title="FCS_COP.1/SigVer Cryptographic Operation - Signature Verification" id="catsec-fcs-cop-1-sigver">

					<h:b>Catalog Guidance Notes</h:b><h:p/>
						As of the publication of FIPS PUB 186-5 on 3 February 2023, DSA is no longer approved for
						digital signature generation. DSA may be used to verify signatures generated prior to the
						implementation date of FIPS PUB 186-5. The specifications and algorithms for DSA are no longer
						included in FIPS PUB 186-5. They can be found in FIPS PUB 186-4. 

					<!-- FCS_COP.1/SigVer Cryptographic Operation - Signature Verification --> 
					<f-component id="sfr-fcs-cop-1-sigver" cc-id="fcs_cop.1" iteration="SigVer" name="Cryptographic Operation - Signature Verification">

						<comp-rel>
							<hierarchical-to/>
							<dependencies-to>
								<or-dep>
									<comp-ref>FDP_ITC.1 Import of user data without security attributes</comp-ref> 
									<comp-ref>FDP_ITC.2 Import of user data with security attributes</comp-ref> 
									<comp-ref>FCS_CKM.1 Cryptographic key generation</comp-ref>
									<comp-ref>FCS_CKM.5 Cryptographic key derivation</comp-ref>
									<comp-ref>No other components</comp-ref>
								</or-dep>
								<or-dep>
									<comp-ref>FCS_COP.1/Hash Hashing</comp-ref>
									<comp-ref>FCS_COP.1/XOF Extendable-Output Function</comp-ref>
								</or-dep>
							</dependencies-to>
						</comp-rel>

			<f-element id="fcs-cop-1e1-sigver">
				<title> 
					The TSF shall perform [digital signature verification] in accordance with a specified 
					cryptographic algorithm  
					<selectables>
					<tabularize id="tab-fcs-cop-sigver-sels" title="Recommended choices for FCS_COP.1/SigVer">
						<textcol>Identifier</textcol>
						<reqtext></reqtext>
						<selectcol>Cryptographic algorithm</selectcol>
						<reqtext>and cryptographic key sizes</reqtext>
						<selectcol>Cryptographic key sizes</selectcol>
						<reqtext>that meet the following:</reqtext>
						<selectcol>List of standards</selectcol>
						<reqtext><h:p/><h:p/>The following table provides the recommended choices for
										completion of the selection operations of FCS_COP.1/SigVer.</reqtext>
					</tabularize>
					
					<selectable id="sel-fcs-cop-sigver-rsa-pkcs">
						<col>RSA-PKCS</col>
						<col>RSASSA-PKCS1-v1_5</col>
						<col>Modulus of size <selectables>
								<selectable>2048</selectable>
								<selectable>3072</selectable>
								<selectable>4096</selectable>
						</selectables> bits, hash or XOF <selectables>
								<selectable>SHA-256</selectable>
								<selectable>SHA-384</selectable>
								<selectable>SHA-512</selectable>
								<selectable>SHA3-256</selectable>
								<selectable>SHA3-384</selectable>
								<selectable>SHA3-512</selectable>
						</selectables></col>
						<col>
								RFC 8017 (Section 8.2) [PKCS #1 v2.2]<h:p/>
								FIPS PUB 186-5 (Section 5.4) [RSASSA-PKCS1-v1_5]
						</col>
					</selectable>

					<selectable id="sel-fcs-cop-sigver-rsa-pss">
							<col>RSA-PSS</col>
							<col>RSASSA-PSS</col>
							<col>Modulus of size <selectables>
								<selectable>2048</selectable>
								<selectable>3072</selectable>
								<selectable>4096</selectable>
							</selectables> bits, hash or XOF <selectables>
								<selectable>SHA-256</selectable>
								<selectable>SHA-384</selectable>
								<selectable>SHA-512</selectable>
								<selectable>SHA3-256</selectable>
								<selectable>SHA3-384</selectable>
								<selectable>SHA3-512</selectable>
								<selectable>SHAKE128</selectable>
								<selectable>SHAKE256</selectable>
							</selectables></col>
							<col>
								RFC 8017 (Section 8.1) [PKCS#1 v2.2]<h:p/>
								FIPS PUB 186-5 (Section 5.4) [RSASSA-PSS]
							</col>
						</selectable>
						
						<selectable id="sel-fcs-cop-sigver-dsa">
							<col>DSA</col>
							<col>DSA</col>
							<col>Domain parameters for (L, N) = <selectables>
								<selectable>(2048, 224)</selectable>
								<selectable>(2048, 256)</selectable>
								<selectable>(3072, 256) </selectable>
							</selectables> bits</col>
							<col>
								FIPS PUB 186-4 (Section 4.7) [DSA Signature Verification]
							</col>
						</selectable>				

						<selectable id="sel-fcs-cop-sigver-ecdsa">
							<col>ECDSA</col>
							<col>ECDSA</col> 
							<col>Elliptic Curve <selectables>
								<selectable>NIST P-256</selectable>
								<selectable>brainpoolP256r1</selectable>
								<selectable>NIST P-384</selectable>
								<selectable>brainpoolP384r1</selectable>
								<selectable>NIST P-521</selectable>
								<selectable>brainpoolP512r1</selectable>
							</selectables> using hash or XOF <selectables>
								<selectable>SHA-256</selectable>
								<selectable>SHA-384</selectable>
								<selectable>SHA-512</selectable>
								<selectable>SHA3-256</selectable>
								<selectable>SHA3-384</selectable>
								<selectable>SHA3-512</selectable>
								<selectable>SHAKE128</selectable>
								<selectable>SHAKE256</selectable>
							</selectables></col>
							<col><selectables>
									<selectable>ISO/IEC 14888-3:2018 (Subclause 6.6)</selectable>
									<selectable>FIPS PUB 186-5 (Section 6.4.2)</selectable>
								</selectables>[ECDSA]<h:p/><selectables>
									<selectable>RFC 5639 (Section 3) [Brainpool Curves]</selectable>
									<selectable>NIST SP-800 186 (Section 4) [NIST Curves]</selectable>
								</selectables>
							</col>
						</selectable>
					
						<selectable id="sel-fcs-cop-sigver-kcdsa">
							<col>KCDSA</col>
							<col>KCDSA</col> 
							<col>hash function using<selectables>
								<selectable>SHA-224</selectable>
								<selectable>SHA-256</selectable>
								<selectable>SHA-384</selectable>
								<selectable>SHA-512</selectable>
							</selectables></col>
							<col>ISO/IEC 14888-3:2018 (Subclause 6.3) [KCDSA]</col>
						</selectable>

						<selectable id="sel-fcs-cop-sigver-eckcdsa">
							<col>EC-KCDSA</col>
							<col>EC-KCDSA</col> 
							<col>Elliptic Curve <selectables>
								<selectable>P-224</selectable>
								<selectable>P-256</selectable>
								<selectable>B-233</selectable>
								<selectable>B-283</selectable>
								<selectable>K-233</selectable>
								<selectable>K-283</selectable>
							</selectables> using hash <selectables>
								<selectable>SHA-224</selectable>
								<selectable>SHA-256</selectable>
								<selectable>SHA-384</selectable>
								<selectable>SHA-512</selectable>
							</selectables></col>
							<col>ISO/IEC 14888-3:2018 (Subclause 6.7) [EC-KCDSA]<h:p/>
									NIST SP 800-186 (Section 3) [NIST Curves]
							</col>
						</selectable>

						<selectable id="sel-fcs-cop-sigver-eddsa">
							<col>EdDSA</col>
							<col>Edwards-Curve Digital Signature Algorithm </col> 
							<col>Domain parameters approved for elliptic curves <selectables>
								<selectable>Edwards25519</selectable>
								<selectable>Edwards448</selectable>
							</selectables></col>
							<col>NIST FIPS PUB 186-5 (Section 7.6) [EdDSA]<h:p/>
									RFC 8032 [Edwards Curves]
							</col>
						</selectable>
		
						<!-- LMS -->
						<selectable id="sel-fcs-cop-sigver-lms">
							<col>LMS</col>
							<col>LMS</col>
							<col>Private key size = <selectables>
								<selectable>192 bits with <selectables>
									<selectable>SHA-256/192</selectable>
									<selectable>SHAKE256/192</selectable>
								</selectables></selectable>
								<selectable>256 bits with <selectables>
									<selectable>SHA-256</selectable>
									<selectable>SHAKE256</selectable>
								</selectables></selectable>
								</selectables><h:p/>
								Winternitz parameter = <selectables>
									<selectable>1</selectable>
									<selectable>2</selectable>
									<selectable>4</selectable>
									<selectable>8</selectable></selectables><h:p/>
								Tree height = <selectables>
									<selectable>5</selectable>
									<selectable>10</selectable>
									<selectable>15</selectable>
									<selectable>20</selectable>
									<selectable>25</selectable></selectables>
							</col>
							<col>RFC 8554 [LMS]<h:p/>
								 NIST SP 800-208 [parameters]
							</col>
						</selectable>
						
						<!-- HSS -->
						<selectable id="sel-fcs-cop-sigver-hss">
							<col>HSS</col>
							<col>Multitree version of LMS</col>
							<col>Private key size = <selectables>
								<selectable>192 bits with <selectables>
									<selectable>SHA-256/192</selectable>
									<selectable>SHAKE256/192</selectable>
								</selectables></selectable>
								<selectable>256 bits with <selectables>
									<selectable>SHA-256</selectable>
									<selectable>SHAKE256</selectable>
								</selectables></selectable>
								</selectables><h:p/>
								Winternitz parameter = <selectables>
									<selectable>1</selectable>
									<selectable>2</selectable>
									<selectable>4</selectable>
									<selectable>8</selectable></selectables><h:p/>
								Tree height = <selectables>
									<selectable>5</selectable>
									<selectable>10</selectable>
									<selectable>15</selectable>
									<selectable>20</selectable>
									<selectable>25</selectable></selectables><h:p/>
								Number of levels = <selectables>
									<selectable>1</selectable>
									<selectable>2</selectable>
									<selectable>3</selectable>
									<selectable>4</selectable>
									<selectable>5</selectable>
									<selectable>6</selectable>
									<selectable>7</selectable>
									<selectable>8</selectable></selectables>
							</col>
							<col>RFC 8554 [HSS]<h:p/>
								 NIST SP 800-208 [parameters]
							</col>
						</selectable>
						
						<!-- XMSS -->
						<selectable id="sel-fcs-cop-sigver-xmss">
							<col>XMSS</col>
							<col>XMSS</col>
							<col>Private key size = <selectables>
								<selectable>192 bits with <selectables>
									<selectable>SHA-256/192</selectable>
									<selectable>SHAKE256/192</selectable>
								</selectables></selectable>
								<selectable>256 bits with <selectables>
									<selectable>SHA-256</selectable>
									<selectable>SHAKE256</selectable>
								</selectables></selectable>
								</selectables><h:p/>
								Tree height = <selectables>
									<selectable>10</selectable>
									<selectable>16</selectable>
									<selectable>20</selectable>
								</selectables>
							</col>
							<col>RFC 8391 [XMSS]<h:p/>
								 NIST SP 800-208 [parameters]
							</col>
						</selectable>

						<!-- XMSS(TM) -->
						<selectable id="sel-fcs-cop-sigver-xmssmt">
							<col>XMSS(MT)</col>
							<col>Multitree version of XMSS</col>
							<col>Private key size = <selectables>
								<selectable>192 bits with <selectables>
									<selectable>SHA-256/192</selectable>
									<selectable>SHAKE256/192</selectable>
								</selectables></selectable>
								<selectable>256 bits with <selectables>
									<selectable>SHA-256</selectable>
									<selectable>SHAKE256</selectable>
								</selectables></selectable>
								</selectables><h:p/>
								(Total Tree height, Number of Levels) = <selectables>
									<selectable>(20, 2)</selectable>
									<selectable>(20, 4)</selectable>
									<selectable>(40, 2)</selectable>
									<selectable>(40, 4)</selectable>
									<selectable>(40, 8)</selectable>
									<selectable>(60, 3)</selectable>
									<selectable>(60, 6)</selectable>
									<selectable>(60, 12)</selectable>
								</selectables>
							</col>
							<col>RFC 8391 [XMSS(MT)]<h:p/>
								 NIST SP 800-208 [parameters]
							</col>
						</selectable>
						
						<!-- ML-DSA Signature Verification -->
						<selectable id="sel-fcs-cop-sigver-mldsa">
							<col>ML-DSA</col>
							<col>ML-DSA Signature Verification</col>
							<col>Perameter set = <selectables>
								<selectable>ML-DSA-44</selectable>
								<selectable>ML-DSA-65</selectable>
								<selectable>ML-DSA-87</selectable>
								</selectables>
							</col>
							<col>NIST FIPS 204 (Section 5.3)</col>
						</selectable>
				
					</selectables>
				</title>
				<note role="application">
					This SFR must be included in the ST if digital signature verification is a service provided by 
					the TOE to tenant software, or if digital signature verification is used by the TOE itself to 
					support or implement PP-specified security functionality.<h:p/> 
					Specifically, this SFR must be included if the ST Author chooses "<h:i>implement an authenticated platform
					firmware update mechanism as described in FPT_TUD_EXT.2</h:i>" or "<h:i>implement a delayed-authentication platform
					firmware update mechanism as described in FPT_TUD_EXT.3</h:i>" in FPT_TUD_EXT.1; or if the ST Author 
					selects "<h:i>verification of a digital signature by trusted code/data</h:i>" in FPT_ROT_EXT.2.<h:p/>	
					If this SFR is included in the ST, then FCS_COP.1/Hash must also be claimed.<h:p/>
					The ST Author should choose the algorithm implemented to perform verification of digital signatures. 
					For the algorithm chosen, the ST Author should make the appropriate assignments/selections to specify the 
					parameters that are implemented for that algorithm. In particular, if ECDSA is selected as one of the signature
					algorithms, the key size specified must match the selection for the curve used in the algorithm.<h:p/>
					For elliptic curve-based schemes, the key size refers to the binary logarithm (log2) of the order of the
					base point. As the preferred approach for digital signatures, elliptic curves will be required after all the
					necessary standards and other supporting information are fully established.<h:p/>
					<comment>From catalog</comment>
					The TOE may contain a public key which is integrity protected (e.g., in hardware), in which 
					case the FDP_ITC.1 and FDP_ITC.2 dependencies do not apply.  In this case, no dependencies 
					may be chosen.  For signature verifications, private keys are not necessary, so there are no
					dependencies required for generating or destroying cryptographic keys.
				</note>
				<aactivity>
				<TSS>
					The evaluator shall check the TSS to ensure that it describes the overall flow of the
					signature verification. This should at least include identification of the format and
					general location (e.g., "firmware on the hard drive device" rather than “memory
					location 0x00007A4B") of the data to be used in verifying the digital signature; how
					the data received from the operational environment are brought onto the device; and
					any processing that is performed that is not part of the digital signature algorithm
					(for instance, checking of certificate revocation lists).
				</TSS>
				<Guidance/>
				<Tests>
					The following tests require the developer to provide access to a test platform that
					provides the evaluator with tools that are typically not found on factory products.<h:p/>
					Each section below contains tests the evaluator must perform for each selected
					digital signature scheme. Based on the assignments and selections in the
					requirement, the evaluator chooses the specific activities that correspond to those
					selections.<h:p/>
					The following tests require the developer to provide access to a test platform that
					provides the evaluator with tools that are not found on the TOE in its evaluated
					configuration.<h:p/>
					<h:b><h:i>RSASSA-PKCS1-v1_5 and RSASSA-PSS</h:i></h:b><h:p/>
					These tests are derived from The 186-4 RSA Validation System (RSA2VS),
					updated 8 Jul 2014, Section 6.4.<h:p/>
					The FIPS 186-4 RSA Signature Verification Test tests the ability of the TSF to
					recognize valid and invalid signatures. The evaluator shall provide a modulus and
					three associated key pairs (d, e) for each combination of selected SHA algorithm,
					modulus size and hash size. Each private key d is used to sign six pseudorandom
					messages each of 1024 bits. For five of the six messages, the public key (e),
					message, IR format, padding, or signature is altered so that signature verification
					should fail. The test passes only if all the signatures made using unaltered
					parameters result in successful signature verification, and all the signatures made
					using altered parameters result in unsuccessful signature verification.<h:p/>
					<h:b><h:i>ECDSA on NIST and Brainpool Curves</h:i></h:b><h:p/>
					These tests are derived from The FIPS 186-4 Elliptic Curve Digital Signature
					Algorithm Validation System (ECDSA2VS), updated 18 Mar 2014, Section 6.5.<h:p/>
					The FIPS 186-5 ECC Signature Verification Test tests the ability of the TSF to
					recognize valid and invalid signatures. The evaluator shall provide a modulus and
					associated key pair (x, y) for each combination of selected curve, SHA algorithm,
					modulus size, and hash size. Each private key (x) is used to sign 15 pseudorandom 
					messages of 1024 bits. For eight of the fifteen messages, the message, IR format,
					padding, or signature is altered so that signature verification should fail. The test
					passes only if all the signatures made using unaltered parameters result in successful
					signature verification, and all the signatures made using altered parameters result in
					unsuccessful signature verification.<h:p/>
					<h:b><h:i>Digital Signature Scheme 2</h:i></h:b><h:p/>
					The following or equivalent steps shall be taken to test the TSF.<h:p/>
					For each supported modulus size, underlying hash algorithm, and length of the
					trailer field (1- or 2-byte), the evaluator shall generate NT sets of recoverable
					message (M1), non-recoverable message (M2), salt, public key and signature (<h:i>&#931;</h:i>).<h:p/>
					<h:ol type="1">
						<h:li><h:i>N<h:sub>T</h:sub></h:i> shall be greater than or equal to 20.</h:li>
						<h:li>The length of salts shall be selected from its supported length range of salt.
							The typical length of salt is equal to the output block length of underlying
							hash algorithm (see 9.2.2 of ISO/IEC 9796-2:2010).</h:li>
						<h:li>The length of recoverable messages should be selected by considering
							modulus size, output block length of underlying hash algorithm, and length
							of salt (<h:i>L<h:sub>S</h:sub></h:i>). As described in Annex D of ISO/IEC 9796-2:2010, it is desirable
							to maximize the length of recoverable message. The following table shows
							the maximum bit-length of recoverable message that is divisible by 512, for
							some combinations of modulus size, underlying hash algorithm, and length
							of salt.
							<h:table class="classic" style="width:50%">
								<h:tr class="header"><h:td>Maximum length of recoverable message divisible by 512 (bits)</h:td>
								<h:td>Modulus size (bits)</h:td>
								<h:td>Underlying hash algorithm (bits)</h:td>
								<h:td>Length of salt L<h:sub>S</h:sub> (bits)</h:td></h:tr>
					
								<h:tr><h:td>1536</h:td><h:td rowspan="5">2048</h:td><h:td rowspan="2">SHA-256</h:td><h:td>128</h:td></h:tr>
								<h:tr><h:td>1024</h:td><h:td>256</h:td></h:tr>
								<h:tr><h:td>1024</h:td><h:td rowspan="3">SHA-512</h:td><h:td>128</h:td></h:tr>
								<h:tr><h:td>1024</h:td><h:td>256</h:td></h:tr>
								<h:tr><h:td>512</h:td><h:td>512</h:td></h:tr>
								<h:tr><h:td>2560</h:td><h:td rowspan="5">3072</h:td><h:td rowspan="2">SHA-256</h:td><h:td>128</h:td></h:tr>
								<h:tr><h:td>2048</h:td><h:td>256</h:td></h:tr>
								<h:tr><h:td>2048</h:td><h:td rowspan="3">SHA-512</h:td><h:td>128</h:td></h:tr>
								<h:tr><h:td>2048</h:td><h:td>256</h:td></h:tr>
								<h:tr><h:td>1536</h:td><h:td>512</h:td></h:tr>
								<h:tr colspan="4">None that 2-byte trailer field is assumed in calculating the maximum length of recoverable message</h:tr>
							</h:table></h:li>
						<h:li>The length of non-recoverable messages should be selected by considering
							the underlying hash algorithm and usages. If the TSF is used for verifying
							the authenticity of software/firmware updates, the length of non-recoverable
							messages should be selected greater than or equal to 2048-bit. With this
							length range, it means that the underlying hash algorithm is also tested for
							two or more input blocks.</h:li>
						<h:li>The evaluator shall select approximately one half of <h:i>N<h:sub>T</h:sub></h:i> sets and shall alter
							one of the values (non-recoverable message, public key exponent or
							signature) in the sets. In altering public key exponent, the evaluator shall
							alter the public key exponent while keeping the exponent odd. In altering
							signatures, the following ways should be considered:
							<h:ol type="a">
								<h:li>Altering a signature just by replacing a bit in the bit-string representation
									of the signature</h:li>
								<h:li>Altering a signature so that the trailer in the message representative
									cannot be interpreted. This can be achieved by following ways:<h:ul>
									<h:li>Setting the rightmost four bits of the message representative to the
										values other than '1100'.</h:li>
									<h:li>In the case when 1-byte trailer is used, setting the rightmost byte of
										the message representative to the values other than '0xbc', while
										keeping the rightmost four bits to '1100'.</h:li>
									<h:li>In the case when 2-byte trailer is used, setting the rightmost byte of
										the message representative to the values other than '0xcc', while
										keeping the rightmost four bits to '1100'.</h:li></h:ul></h:li>
								<h:li>In the case when 2-byte trailer is used, altering a signature so that the
									hash algorithm identifier in the trailer (i.e. the left most byte of the
									trailer) does not correspond to hash algorithms identified in the SFR.
									The hash algorithm identifiers are 0x34 for SHA-256 (see Clause 10 of
									ISO/IEC 10118-3:2018), and 0x35 for SHA-512 (see Clause 11 of
									ISO/IEC 10118-3:2018).</h:li>
								<h:li>Let <h:i>L<h:sub>S</h:sub></h:i> be the length of salt, altering a signature so that the intermediate
									bit string <h:i>D</h:i> in the message representative is set to all zeroes except for
									the rightmost <h:i>L<h:sub>S</h:sub></h:i> bits of <h:i>D</h:i>.</h:li>
								<h:li> (non-conformant signature length) Altering a signature so that the length
									of signature <h:i>&#931;</h:i> is changed to modulus size and the most significant bit of
									signature <h:i>&#931;</h:i> is set equal to '1'.</h:li>
								<h:li>(non-conformant signature) Altering a signature so that the integer
									converted from signature <h:i>&#931;</h:i> is greater than modulus <h:i>n</h:i>.</h:li>
							</h:ol>
						</h:li>
					</h:ol>
					The evaluator shall supply the NT sets to the TSF and obtain in response a set of
					NT Verification-Success or Verification-Fail values. When the Verification-Success is 
					obtained, the evaluator shall also obtain recovered message (M 1*).<h:p/>
					The evaluator shall verify that Verification-Success results correspond to the
					unaltered sets and Verification-Fail results correspond to the altered sets.<h:p/>
					For each recovered message, the evaluator shall compare the recovered message
					(M1*) with the corresponding recoverable message (M 1) in the unaltered sets.<h:p/>
					The test passes only if all the signatures made using unaltered sets result in
					Verification-Success, each recovered message (M 1*) is equal to corresponding M 
					1 in the unaltered sets, and all the signatures made using altered sets result in
					Verification-Fail.<h:p/>
					<h:b><h:i>Digital Signature Scheme 3</h:i></h:b><h:p/>
					The evaluator shall perform the test described for Digital Signature Scheme
					2 while using a fixed salt for NT sets.
				</Tests>
				</aactivity>
			</f-element>
						<audit-event/>
					</f-component>	
				</section>   <!-- FCS_COP.1/SigVer -->
				
				<section title="FCS_COP.1/SKC Cryptographic Operation - Symmetric-Key Cryptography " id="catsec-fcs-cop-1-skc">

					<h:b>Catalog Guidance Notes</h:b><h:p/>
						The modes covered in FCS_COP.1/SKC are used for symmetric-key cryptography without
						authentication.  

					<!-- FCS_COP.1/SKC Cryptographic Operation - Symmetric Key Cryptography -->	
					<f-component id="sfr-fcs-cop-1-skc" cc-id="fcs_cop.1" iteration="SKC" name="Cryptographic Operation - Symmetric Key Cryptography">

						<comp-rel>
							<hierarchical-to/>
							<dependencies-to>
								<or-dep>
									<comp-ref>FDP_ITC.1 Import of user data without security attributes</comp-ref> 
									<comp-ref>FDP_ITC.2 Import of user data with security attributes</comp-ref> 
									<comp-ref>FCS_CKM.1 Cryptographic key generation</comp-ref>
									<comp-ref>FCS_CKM.5 Cryptographic key derivation</comp-ref>
									<comp-ref>FCS_CKM_EXT.7 Cryptographic key agreement</comp-ref>
									<comp-ref>FCS_CKM_EXT.8 Password-based key derivation</comp-ref>
								</or-dep>
								<comp-ref>FCS_CKM.6 Timing and event of cryptographic key destruction</comp-ref>
								<comp-ref>FCS_OTV_EXT.1 One Time Value</comp-ref>
							</dependencies-to>
						</comp-rel>
	
			<f-element id="fcs-cop-1e1-skc">
				<title>
					The TSF shall perform [symmetric-key encryption/decryption] in accordance with a 
					specified cryptographic algorithm   
					<selectables>
						<tabularize id="fcs-cop-skc-sels" title="Recommended choices for FCS_COP.1/SKC">
							<textcol>Identifier</textcol>
							<reqtext></reqtext>
							<selectcol>Cryptographic algorithm</selectcol>
							<reqtext>and cryptographic key sizes</reqtext>
							<selectcol>Cryptographic key sizes</selectcol>
							<reqtext>that meet the following:</reqtext>
							<selectcol>List of standards</selectcol>
							<reqtext><h:p/><h:p/>The following table provides the recommended choices for
								completion of the selection operations of FCS_COP.1/SKC.</reqtext>							
						</tabularize>

						<!-- AES-CBC -->
						<selectable id="sel-fcs-cop-skc-aes-cbc">
							<col>AES-CBC</col>
							<col>AES in CBC mode with non-repeating and unpredictable IVs</col>
							<col><selectables>
									<selectable>128</selectable>
									<selectable>192</selectable>
									<selectable>256</selectable>
								</selectables> bits</col>
							<col><selectables>
								<selectable>ISO/IEC 18033-3:2010 (Subclause 5.2)</selectable> 
								<selectable>FIPS PUB 197</selectable></selectables> [AES]<h:p/><selectables>
								<selectable>ISO/IEC 10116:2017 (Clause 7)</selectable> 
								<selectable>NIST SP 800-38A</selectable></selectables> [CBC]
							</col>
						</selectable>

						<!-- XTS-AES -->
						<selectable id="sel-fcs-cop-skc-aes-xts">
							<col>XTS-AES</col>
							<col>AES in XTS mode with unique tweak values that are consecutive non-negative 
								integers starting at an arbitrary non-negative integer</col>
							<col><selectables>
									<selectable>256</selectable>
									<selectable>512</selectable>
								</selectables> bits</col>
							<col><selectables>
								<selectable>ISO/IEC 18033-3:2010 (Subclause 5.2)</selectable> 
								<selectable>FIPS PUB 197</selectable></selectables> [AES]<h:p/><selectables>
								<selectable>IEEE Std. 1619-2018</selectable> 
								<selectable>NIST SP 800-38E</selectable></selectables> [XTS]
							</col>
						</selectable>

						<!-- AES-CTR -->
						<selectable id="sel-fcs-cop-skc-aes-ctr">
							<col>AES-CTR</col>
							<col>AES in Counter Mode with a non-repeating initial counter and with no repeated
								use of counter values across multiple messages with the same secret key</col>
							<col><selectables>
									<selectable>128</selectable>
									<selectable>192</selectable>
									<selectable>256</selectable>
								</selectables> bits</col>
							<col><selectables>
								<selectable>ISO/IEC 18033-3:2010 (Subclause 5.2)</selectable> 
								<selectable>FIPS PUB 197</selectable></selectables> [AES]<h:p/><selectables>
								<selectable>: ISO/IEC 10116:2017 (Clause 10)</selectable> 
								<selectable>NIST SP 800-38A</selectable></selectables> [CBC]
							</col>
						</selectable>

						<!-- CAM-CBC -->
						<selectable id="sel-fcs-cop-skc-cam-cbc">
							<col>CAM-CBC</col>
							<col>Camellia in CBC mode with non-repeating and unpredictable IVs</col>
							<col><selectables>
									<selectable>128</selectable>
									<selectable>192</selectable>
									<selectable>256</selectable>
								</selectables> bits</col>
							<col>ISO/IEC 18033-3:2010 (Subclause 5.3) [Camellia]<h:p/><selectables>
								<selectable>ISO/IEC 10116:2017 (Clause 7)</selectable> 
								<selectable>NIST SP 800-38A</selectable></selectables> [CBC]
							</col>
						</selectable>

						<!-- CAM-CFB -->
						<selectable id="sel-fcs-cop-skc-cam-cfb">
							<col>CAM-CFB</col>
							<col>Camellia in CFB mode with non-repeating and unpredictable IVs</col>
							<col><selectables>
									<selectable>128</selectable>
									<selectable>192</selectable>
									<selectable>256</selectable>
								</selectables> bits</col>
							<col>ISO/IEC 18033-3:2010 (Subclause 5.3) [Camellia]<h:p/><selectables>
								<selectable>ISO/IEC 10116:2017 (Clause 8)</selectable> 
								<selectable>NIST SP 800-38A</selectable></selectables> [CFB]
							</col>
						</selectable>

						<!-- CAM-OFB -->
						<selectable id="sel-fcs-cop-skc-cam-ofb">
							<col>CAM-OFB</col>
							<col>Camellia in OFB mode with unique IVs</col>
							<col><selectables>
									<selectable>128</selectable>
									<selectable>192</selectable>
									<selectable>256</selectable>
								</selectables> bits</col>
							<col>ISO/IEC 18033-3:2010 (Subclause 5.3) [Camellia]<h:p/><selectables>
								<selectable>ISO/IEC 10116:2017 (Clause 9)</selectable> 
								<selectable>NIST SP 800-38A</selectable></selectables> [OFB]
							</col>
						</selectable>

						<!-- XTS-CAM -->
						<selectable id="sel-fcs-cop-skc-cam-xts">
							<col>XTS-CAM</col>
							<col>Camellia in XTS mode with unique tweak values that are consecutive non-negative
								integers starting at an arbitrary non-negative integer </col>
							<col><selectables>
									<selectable>256</selectable>
									<selectable>512</selectable>
								</selectables> bits</col>
							<col>ISO/IEC 18033-3:2010 (Subclause 5.3) [Camellia]<h:p/><selectables>
								<selectable>IEEE Std. 1619-2018</selectable> 
								<selectable>NIST SP 800-38E</selectable></selectables> [XTS]
							</col>
						</selectable>

						<!-- CAM-CTR -->
						<selectable id="sel-fcs-cop-skc-cam-ctr">
							<col>CAM-CTR</col>
							<col>Camellia in CTR mode with a non-repeating initial counter and with no repeated use
								of counter values across multiple messages with the same secret key.</col>
							<col><selectables>
									<selectable>128</selectable>
									<selectable>192</selectable>
									<selectable>256</selectable>
								</selectables> bits</col>
							<col>ISO/IEC 18033-3:2010 (Subclause 5.3) [Camellia]<h:p/><selectables>
								<selectable>ISO/IEC 10116:2017 (Clause 10)</selectable> 
								<selectable>NIST SP 800-38A</selectable></selectables> [CTR]
							</col>
						</selectable>

						<!-- SEED-CBC -->
						<selectable id="sel-fcs-cop-skc-seed-cbc">
							<col>SEED-CBC</col>
							<col>SEED in CBC mode with non-repeating and unpredictable IVs</col>
							<col>128 bits</col>
							<col>ISO/IEC 18033-3:2010 (Subclause 5.4) [SEED]<h:p/><selectables>
								<selectable>ISO/IEC 10116:2017 (Clause 7)</selectable> 
								<selectable>NIST SP 800-38A</selectable></selectables> [CBC]
							</col>
						</selectable>

						<!-- SEED-CFB -->
						<selectable id="sel-fcs-cop-skc-seed-cfb">
							<col>SEED-CFB</col>
							<col>SEED in CFB mode with non-repeating and unpredictable IVs</col>
							<col>128 bits</col>
							<col>ISO/IEC 18033-3:2010 (Subclause 5.4) [SEED]<h:p/><selectables>
								<selectable>ISO/IEC 10116:2017 (Clause 8)</selectable> 
								<selectable>NIST SP 800-38A</selectable></selectables> [CFB]
							</col>
						</selectable>

						<!-- SEED-OFB -->
						<selectable id="sel-fcs-cop-skc-seed-ofb">
							<col>SEED-OFB</col>
							<col>SEED in OFB mode with unique IVs</col>
							<col>128 bits</col>
							<col>ISO/IEC 18033-3:2010 (Subclause 5.4) [SEED]<h:p/><selectables>
								<selectable>ISO/IEC 10116:2017 (Clause 9)</selectable> 
								<selectable>NIST SP 800-38A</selectable></selectables> [OFB]
							</col>
						</selectable>

						<!-- SEED-CTR -->
						<selectable id="sel-fcs-cop-skc-seed-ctr">
							<col>SEED-CTR</col>
							<col>SEED in CTR mode with unique, incremental counter</col>
							<col>128 bits</col>
							<col>ISO/IEC 18033-3:2010 (Subclause 5.4) [SEED]<h:p/><selectables>
								<selectable>ISO/IEC 10116:2017 (Clause 10)</selectable> 
								<selectable>NIST SP 800-38A</selectable></selectables> [CTR]
							</col>
						</selectable>

						<!-- HIGHT-CBC -->
						<selectable id="sel-fcs-cop-skc-hight-cbc">
							<col>HIGHT-CBC</col>
							<col>HIGHT in CBC mode with non-repeating and unpredictable IVs</col>
							<col>128 bits</col>
							<col>ISO/IEC 18033-3:2010 (Subclause 4.5) [HIGHT]<h:p/><selectables>
								<selectable>ISO/IEC 10116:2017 (Clause 7)</selectable> 
								<selectable>NIST SP 800-38A</selectable></selectables> [CBC]
							</col>
						</selectable>

						<!-- HIGHT-CFB -->
						<selectable id="sel-fcs-cop-skc-hight-cfb">
							<col>HIGHT-CFB</col>
							<col>HIGHT in CFB mode with non-repeating and unpredictable IVs</col>
							<col>128 bits</col>
							<col>ISO/IEC 18033-3:2010 (Subclause 4.5) [HIGHT]<h:p/><selectables>
								<selectable>ISO/IEC 10116:2017 (Clause 8)</selectable> 
								<selectable>NIST SP 800-38A</selectable></selectables> [CFB]
							</col>
						</selectable>

						<!-- HIGHT-OFB -->
						<selectable id="sel-fcs-cop-skc-hight-ofb">
							<col>HIGHT-OFB</col>
							<col>HIGHT in OFB mode with unique IVs</col>
							<col>128 bits</col>
							<col>ISO/IEC 18033-3:2010 (Subclause 4.5) [HIGHT]<h:p/><selectables>
								<selectable>ISO/IEC 10116:2017 (Clause 9)</selectable> 
								<selectable>NIST SP 800-38A</selectable></selectables> [OFB]
							</col>
						</selectable>

						<!-- HIGHT-CTR -->
						<selectable id="sel-fcs-cop-skc-hight-ctr">
							<col>HIGHT-CTR</col>
							<col>HIGHT in CTR mode with unique, incremental counter</col>
							<col>128 bits</col>
							<col>ISO/IEC 18033-3:2010 (Subclause 4.5) [HIGHT]<h:p/><selectables>
								<selectable>ISO/IEC 10116:2017 (Clause 10)</selectable> 
								<selectable>NIST SP 800-38A</selectable></selectables> [CTR]
							</col>
						</selectable>

						<!-- LEA-CBC -->
						<selectable id="sel-fcs-cop-skc-lea-cbc">
							<col>LEA-CBC</col>
							<col>LEA in CBC mode with non-repeating and unpredictable IVs</col>
							<col><selectables>
									<selectable>128</selectable>
									<selectable>192</selectable>
									<selectable>256</selectable>
								</selectables> bits</col>
							<col>ISO/IEC 29192-2:2019 (Subclause 6.3) [LEA]<h:p/><selectables>
								<selectable>ISO/IEC 10116:2017 (Clause 7)</selectable> 
								<selectable>NIST SP 800-38A</selectable></selectables> [CBC]
							</col>
						</selectable>

						<!-- LEA-CFB -->
						<selectable id="sel-fcs-cop-skc-lea-cfb">
							<col>LEA-CFB</col>
							<col>LEA in CFB mode with non-repeating and unpredictable IVs</col>
							<col><selectables>
									<selectable>128</selectable>
									<selectable>192</selectable>
									<selectable>256</selectable>
								</selectables> bits</col>
							<col>ISO/IEC 29192-2:2019 (Subclause 6.3) [LEA]<h:p/><selectables>
								<selectable>ISO/IEC 10116:2017 (Clause 8)</selectable> 
								<selectable>NIST SP 800-38A</selectable></selectables> [CFB]
							</col>
						</selectable>

						<!-- LEA-OFB -->
						<selectable id="sel-fcs-cop-skc-lea-ofb">
							<col>LEA-OFB</col>
							<col>LEA in OFB mode with unique IVs</col>
							<col><selectables>
									<selectable>128</selectable>
									<selectable>192</selectable>
									<selectable>256</selectable>
								</selectables> bits</col>
							<col>ISO/IEC 29192-2:2019 (Subclause 6.3) [LEA]<h:p/><selectables>
								<selectable>ISO/IEC 10116:2017 (Clause 9)</selectable> 
								<selectable>NIST SP 800-38A</selectable></selectables> [OFB]
							</col>
						</selectable>

						<!-- LEA-CTR -->
						<selectable id="sel-fcs-cop-skc-lea-ctr">
							<col>LEA-CTR</col>
							<col>LEA in CTR mode with a non-repeating initial counter and with no repeated use
								of counter values across multiple messages with the same secret key.</col>
							<col><selectables>
									<selectable>128</selectable>
									<selectable>192</selectable>
									<selectable>256</selectable>
								</selectables> bits</col>
							<col>ISO/IEC 29192-2:2019 (Subclause 6.3) [LEA]<h:p/><selectables>
								<selectable>ISO/IEC 10116:2017 (Clause 10)</selectable> 
								<selectable>NIST SP 800-38A</selectable></selectables> [CTR]
							</col>
						</selectable>
					</selectables>
				</title>
				<note role="application">
					This SFR must be included in the ST if symmetric-key cryptography is a service provided by the TOE 
					to tenant software, or if the TOE itself uses SKC to support or implement PP-specified security 
					functionality.<h:p/> 
					Specifically, this SFR must be included if the ST includes FCS_IPSEC_EXT.1 or FCS_STG_EXT.2, or includes
					any of the following selections: <h:ul>
						<h:li>"<h:i>CTR_DRBG (AES)</h:i>" in FCS_RBG.1</h:li>
						<h:li>"<h:i>ECIES</h:i>" in FCS_COP.1/KAT</h:li>
						<h:li>"<h:i>AES-*</h:i>" in FCS_STG_EXT.3</h:li>
					</h:ul>
					
					<h:p/>
					<comment>From catalog</comment>
					If the selected “cryptographic algorithm" requires an IV, counter, or tweak value,
					then FCS_OTV_EXT.1 must be claimed.
				</note>
				<aactivity>
					<TSS>
						The evaluator shall check that the TSS includes a description of encryption
						functions used for symmetric key encryption. The evaluator should check that this
						description of the selected encryption function includes the key sizes and modes of
						operations as specified in <xref to="fcs-cop-skc-sels"/>.<h:p/>
						The evaluator shall check that the TSS describes the means by which the TOE
						satisfies constraints on algorithm parameters included in the selections made for
						"cryptographic algorithm" and "list of standards."
					</TSS>
					<Guidance>
						If the product supports multiple modes, the evaluator shall examine the AGD
						to determine that the method of choosing a specific mode/key size
						is described.
					</Guidance>
					<CustomEA name="KMD">
						The evaluator shall examine the KMD to ensure that the points at which symmetric
						key encryption and decryption occurs are described, and that the complete data path
						for symmetric key encryption is described. The evaluator checks that this
						description is consistent with the relevant parts of the TSS.<h:p/>
						Assessment of the complete data path for symmetric key encryption includes
						confirming that the KMD describes the data flow from the device’s host interface
						to the device’s non-volatile memory storing the data, and gives information
						enabling the user data path to be distinguished from those situations in which
						data bypasses the data encryption engine (e.g. read-write operations to an
						unencrypted Master Boot Record area). The evaluator shall ensure that the
						documentation of the data path is detailed enough that it thoroughly describes the
						parts of the TOE that the data passes through (e.g. different memory types,
						processors and co-processors), its encryption state (i.e. encrypted or unencrypted)
						in each part, and any places where the data is stored. For example, any caching or
						buffering of the data should be identified and distinguished from the final
						destination in non-volatile memory (the latter represents the location from which
						the host will expect to retrieve the data in future).<h:p/>
						If support for AES-CTR is claimed and the counter value source is internal to the
						TOE, the evaluator shall verify that the KMD describes the internal counter
						mechanism used to ensure that it provides unique counter block values.
					</CustomEA>
					<Tests>
						The following tests require the developer to provide access to a test platform that
						provides the evaluator with tools that are typically not found on factory products.<h:p/>
						The following tests are conditional based upon the selections made in the SFR. The
						evaluator shall perform the following test or witness respective tests executed by
						the developer. The tests must be executed on a platform that is as close as practically
						possible to the operational platform (but which may be instrumented in terms of,
						for example, use of a debug mode). Where the test is not carried out on the TOE
						itself, the test platform shall be identified and the differences between test
						environment and TOE execution environment shall be described.<h:p/>
						Preconditions for testing:<h:ul>
						<h:li>Specification of keys as input parameter to the function to be tested</h:li>
						<h:li>specification of required input parameters such as modes</h:li>
						<h:li>Specification of user data (plaintext)</h:li>
						<h:li>Tapping of encrypted user data (ciphertext) directly in the non-volatile memory</h:li></h:ul>
						<h:p/>

						<!-- AES-CBC -->
						<h:br/><h:b>AES-CBC</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">AES-CBC</h:td>
								<h:td valign="top">AES in CBC mode with non-repeating and unpredictable IVs</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> 128, 192, 256] bits</h:td>
								<h:td valign="top">
									[<h:b>selection:</h:b> ISO/IEC 18033-3:2010 (Subclause 5.2),
										FIPS PUB 197] [AES]<h:p/>
									[<h:b>selection:</h:b>  ISO/IEC 10116:2017 (Clause 7), 
										NIST SP 800-38A] [CBC]</h:td>
							</h:tr>
						</h:table><h:p/>	
						
						To test the TOE’s ability to encrypt/decrypt data using AES in CBC mode, the evaluator 
						shall perform Algorithm Functional Tests and Monte Carlo Tests using the following
						input parameters:<h:ul>
						<h:li>Key size [128, 192, 256] bits</h:li>
						<h:li>Direction [encryption, decryption]</h:li></h:ul><h:p/>
						<h:br/><h:b>Algorithm Functional Tests</h:b><h:p/>
						Algorithm Functional Tests are designed to verify the correct operation of the logical
						components of the algorithm implementation under normal operation using different block sizes.
						For AES-CBC, there are two types of AFTs:<h:p/>
						<h:br/><h:b><h:i>Known-Answer Tests</h:i></h:b><h:p/>
						For each combination of direction and claimed key size, the TOE must be tested using the
						GFSbox, KeySbox, VarTxt, and VarKey test cases listed in Appendixes B through E of <h:i>The
						Advanced Encryption Standard Algorithm Validation Suite (AESAVS)</h:i>, NIST, 15 November 2002.<h:p/>
						<h:br/><h:b><h:i>Multi-Block Message Tests</h:i></h:b><h:p/>
						For each combination of direction and claimed key size, the TOE must be tested against 10 test
						cases consisting of a random IV, random key, and random plaintext/ciphertext. The
						plaintext/ciphertext starts with a length of 16 bytes and increases by 16 bytes for each test case
						until reaching 160 bytes.<h:p/>
						<h:br/><h:b><h:i>Monte Carlo Tests</h:i></h:b><h:p/>
						Monte Carlo tests are intended to test the implementation under strenuous conditions. The TOE
						must process the test cases according to the following algorithm once for each combination of
						direction and key size:<h:p/>
		<h:pre>
		Key[0] = Key
		IV[0] = IV
		PT[0] = PT
		for i = 0 to 99 {
			Output Key[i], IV[i], PT[0]
			for j = 0 to 999 {
				if (j == 0) {
					CT[j] = AES-CBC-Encrypt(Key[i], IV[i], PT[j])
					PT[j+1] = IV[i]
				} else {
					CT[j] = AES-CBC-Encrypt(Key[i], PT[j])
					PT[j+1] = CT[j-1]
				}
			}
			Output CT[j]
			AES_KEY_SHUFFLE(Key, CT)
			IV[i+1] = CT[j]
			PT[0] = CT[j-1]
		}
		</h:pre><h:p/>	
		where <h:pre>AES_KEY_SHUFFLE</h:pre> is defined as: <h:p/>
		<h:pre>
		If ( keylen = 128 )
			Key[i+1] = Key[i] xor MSB(CT[j], 128)
		If ( keylen = 192 )
			Key[i+1] = Key[i] xor (LSB(CT[j-1], 64) || MSB(CT[j], 128))
		If ( keylen = 256 )
			Key[i+1] = Key[i] xor (MSB(CT[j-1], 128) || MSB(CT[j], 128))
		</h:pre><h:p/>
						The initial IV, key, and plaintext/ciphertext should be random.<h:p/>
						The ciphertext computed in the 1000th iteration (CT[999]) is the result for each of
						the 100 3-tuples for each selected key size. This result shall be compared to the
						result of running 1000 iterations with the same values using a known good
						implementation.<h:p/>
						The evaluator shall test the decrypt functionality using the same test as above,
						exchanging CT and PT, and replacing AES-CBC-Encrypt with AES-CBC-Decrypt.<h:p/>

						
						<!-- XTS-AES -->
						<h:br/><h:b>XTS-AES</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">XTS-AES</h:td>
								<h:td valign="top">AES in XTS mode with unique tweak values that are consecutive
									non-negative integers starting at an arbitrary non-negative integer</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> 256, 512] bits</h:td>
								<h:td valign="top">
									[<h:b>selection:</h:b> ISO/IEC 18033-3:2010 (Subclause 5.2),
										FIPS PUB 197] [AES]<h:p/>
									[<h:b>selection:</h:b> IEEE Std. 1619-2018, 
										NIST SP 800-38E] [XTS]</h:td>
							</h:tr>
						</h:table><h:p/>	
						To test the TOE’s ability to encrypt/decrypt data using AES in XTS mode, the evaluator shall
						perform the Single Data Unit Test and the Multiple Data Unit Test using the following input
						parameters:<h:ul>
						<h:li>Direction [encryption, decryption]</h:li>
						<h:li>Key size [128, 256] bits</h:li>
						<h:li>Tweak value format [128-bit hex string, data unit sequence number]</h:li></h:ul><h:p/>
						<h:br/><h:b>Single Data Unit Test</h:b><h:p/>
						For each combination of claimed key size, direction, and supported tweak value format, the
						evaluator shall generate 50 test cases consisting of random payload data. The payload data size is
						determined randomly for each test case from supported values within the range [128-65536] bits.
						The payload size and data unit size must be equal.<h:p/>
						<h:br/><h:b>Multiple Data Unit Test</h:b><h:p/>
						For each combination of claimed key size, direction, and supported tweak value format, the
						evaluator shall generate 50 test cases consisting of random payload data. The payload data size is
						determined randomly for each test case from supported values within the range [128-65536] bits.
						Likewise, the data unit size is determined randomly for each test case from supported values
						within the range [128-65535] bits. The payload size and data unit size must not be equal.<h:p/>
						The evaluator shall verify the correctness of the TSF’s implementation by comparing values
						generated by the TSF with those generated by a known good implementation using the same
						input parameters.<h:p/>

						<!-- AES-CTR -->
						<h:br/><h:b>AES-CTR</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">AES-CTR</h:td>
								<h:td valign="top">AES in Counter Mode with a non-repeating initial counter and
									with no repeated use of counter values across multiple messages with the 
									same secret key.</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> 128, 192, 256] bits</h:td>
								<h:td valign="top">
									[<h:b>selection:</h:b> ISO/IEC 18033-3:2010 (Subclause 5.2),
										FIPS PUB 197] [AES]<h:p/>
									[<h:b>selection:</h:b>  ISO/IEC 10116:2017 (Clause 10), 
										NIST SP 800-38A] [CTR]</h:td>
							</h:tr>
						</h:table><h:p/>	
						To test the TOE’s ability to encrypt/decrypt data using AES in CTR mode, the evaluator shall
						perform the Algorithm Functional Test and the Counter Test using the following input
						parameters:<h:ul>
						<h:li>Direction [encryption, decryption]</h:li>
						<h:li>Key size [128, 192, 256] bits</h:li></h:ul><h:p/>
						<h:br/><h:b>Algorithm Functional Tests</h:b><h:p/>
						Algorithm Functional Tests are designed to verify the correct operation of the logical
						components of the algorithm implementation under normal operation using different block sizes.
						For AES-CTR, there are three types of AFTs:<h:p/>
						<h:br/><h:b><h:i>Known-Answer Tests</h:i></h:b><h:p/>
						For each combination of direction and claimed key size, the TOE must be tested using the
						GFSbox, KeySbox, VarTxt, and VarKey test cases listed in Appendixes B through E of <h:i>The
						Advanced Encryption Standard Algorithm Validation Suite (AESAVS)</h:i>, NIST, 15 November 2002.<h:p/>
						<h:br/><h:b><h:i>Single Block Message Tests</h:i></h:b><h:p/>
						For each combination of direction and claimed key, the evaluator shall generate 10 test cases
						with a data size of 128 bits.<h:p/>
						<h:br/><h:b><h:i>Partial Block Message Tests</h:i></h:b><h:p/>
						Monte Carlo tests are intended to test the implementation under strenuous conditions. The TOE
						must process the test cases according to the following algorithm once for each combination of
						direction and key size:<h:p/>
						For each combination of direction and claimed key, the evaluator shall generate five test cases
						such that the data size is not a multiple of 128 bits.<h:p/>
						The evaluator shall verify the correctness of the TSF’s implementation by comparing values
						generated by the TSF with those generated by a known good implementation using the same
						input parameters.
						<h:br/><h:b><h:i>Counter Test</h:i></h:b><h:p/>
						The evaluator shall generate a single message of 1000 blocks (128000 bits) and either encrypt or
						decrypt it. Back-compute the IVs used. Verify that they are unique and increasing (encryption) or
						decreasing (decryption).<h:p/>

						<!-- CAM-CBC -->
						<h:br/><h:b>CAM-CBC</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">CAM-CBC</h:td>
								<h:td valign="top">Camellia in CBC mode with non-repeating and unpredictable IVs</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> 128, 192, 256] bits</h:td>
								<h:td valign="top">ISO/IEC 18033-3:2010 (Subclause 5.3) [Camellia]<h:p/>
									[<h:b>selection:</h:b>  ISO/IEC 10116:2017 (Clause 7), 
										NIST SP 800-38A] [CBC]</h:td>
							</h:tr>
						</h:table><h:p/>	

						<!-- CAM-CFB -->
						<h:br/><h:b>CAM-CFB</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">CAM-CFB</h:td>
								<h:td valign="top">Camellia in CFB mode with non-repeating and unpredictable IVs</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> 128, 192, 256] bits</h:td>
								<h:td valign="top">ISO/IEC 18033-3:2010 (Subclause 5.3) [Camellia]<h:p/>
									[<h:b>selection:</h:b>  ISO/IEC 10116:2017 (Clause 8), 
										NIST SP 800-38A] [CFB]</h:td>
							</h:tr>
						</h:table><h:p/>	

						<!-- CAM-OFB -->
						<h:br/><h:b>CAM-OFB</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">CAM-OFB</h:td>
								<h:td valign="top">Camellia in OFB mode with unique IVs</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> 128, 192, 256] bits</h:td>
								<h:td valign="top">ISO/IEC 18033-3:2010 (Subclause 5.3) [Camellia]<h:p/>
									[<h:b>selection:</h:b>  ISO/IEC 10116:2017 (Clause 9), 
										NIST SP 800-38A] [OFB]</h:td>
							</h:tr>
						</h:table><h:p/>	

						<!-- XTS-CAM -->
						<h:br/><h:b>XTS-CAM</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">XTS-CAM</h:td>
								<h:td valign="top">Camellia in XTS mode with unique tweak values that are 
									consecutive non-negative integers starting at an arbitrary non-negative
									integer</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> 128, 192, 256] bits</h:td>
								<h:td valign="top">ISO/IEC 18033-3:2010 (Subclause 5.3) [Camellia]<h:p/>
									[<h:b>selection:</h:b> IEEE Std. 1619-2018, 
										NIST SP 800-38E] [XTS]</h:td>
							</h:tr>
						</h:table><h:p/>	

						<!-- CAM-CTR -->
						<h:br/><h:b>CAM-CTR</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">CAM-CTR</h:td>
								<h:td valign="top">Camellia in CTR mode with a non-repeating initial counter 
									and with no repeated use of counter values across multiple messages with 
									the same secret key.</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> 128, 192, 256] bits</h:td>
								<h:td valign="top">ISO/IEC 18033-3:2010 (Subclause 5.3) [Camellia]<h:p/>
									[<h:b>selection:</h:b>  ISO/IEC 10116:2017 (Clause 10), 
										NIST SP 800-38A] [CTR]</h:td>
							</h:tr>
						</h:table><h:p/>	

						<!-- SEED-CBC -->
						<h:br/><h:b>SEED-CBC</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">SEED-CBC</h:td>
								<h:td valign="top">SEED in CBC mode with non-repeating and unpredictable IVs</h:td>
								<h:td valign="top">128 bits</h:td>
								<h:td valign="top">ISO/IEC 18033-3:2010 (Subclause 5.4) [SEED]<h:p/>
									[<h:b>selection:</h:b>  ISO/IEC 10116:2017 (Clause 7), 
										NIST SP 800-38A] [CBC]</h:td>
							</h:tr>
						</h:table><h:p/>	

						<!-- SEED-CFB -->
						<h:br/><h:b>SEED-CFB</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">SEED-CFB</h:td>
								<h:td valign="top">SEED in CFB mode with non-repeating and unpredictable IVs</h:td>
								<h:td valign="top">128 bits</h:td>
								<h:td valign="top">ISO/IEC 18033-3:2010 (Subclause 5.4) [SEED]<h:p/>
									[<h:b>selection:</h:b>  ISO/IEC 10116:2017 (Clause 8), 
										NIST SP 800-38A] [CFB]</h:td>
							</h:tr>
						</h:table><h:p/>	

						<!-- SEED-OFB -->
						<h:br/><h:b>SEED-OFB</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">SEED-OFB</h:td>
								<h:td valign="top">SEED in OFB mode with unique IVs</h:td>
								<h:td valign="top">128 bits</h:td>
								<h:td valign="top">ISO/IEC 18033-3:2010 (Subclause 5.4) [SEED]<h:p/>
									[<h:b>selection:</h:b>  ISO/IEC 10116:2017 (Clause 9), 
										NIST SP 800-38A] [OFB]</h:td>
							</h:tr>
						</h:table><h:p/>	

						<!-- SEED-CTR -->
						<h:br/><h:b>SEED-CTR</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">SEED-CTR</h:td>
								<h:td valign="top">SEED in CTR mode with unique, incremental counter</h:td>
								<h:td valign="top">128 bits</h:td>
								<h:td valign="top">ISO/IEC 18033-3:2010 (Subclause 5.4) [SEED]<h:p/>
									[<h:b>selection:</h:b>  ISO/IEC 10116:2017 (Clause 10), 
										NIST SP 800-38A] [CTR]</h:td>
							</h:tr>
						</h:table><h:p/>	

						<!-- HIGHT-CBC -->
						<h:br/><h:b>HIGHT-CBC</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">HIGHT-CBC</h:td>
								<h:td valign="top">HIGHT in CBC mode with non-repeating and unpredictable IVs</h:td>
								<h:td valign="top">128 bits</h:td>
								<h:td valign="top">ISO/IEC 18033-3:2010 (Subclause 4.5) [HIGHT]<h:p/>
									[<h:b>selection:</h:b>  ISO/IEC 10116:2017 (Clause 7), 
										NIST SP 800-38A] [CBC]</h:td>
							</h:tr>
						</h:table><h:p/>	

						<!-- HIGHT-CFB -->
						<h:br/><h:b>HIGHT-CFB</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">HIGHT-CFB</h:td>
								<h:td valign="top">HIGHT in CFB mode with non-repeating and unpredictable IVs</h:td>
								<h:td valign="top">128 bits</h:td>
								<h:td valign="top">ISO/IEC 18033-3:2010 (Subclause 4.5) [HIGHT]<h:p/>
									[<h:b>selection:</h:b>  ISO/IEC 10116:2017 (Clause 8), 
										NIST SP 800-38A] [CFB]</h:td>
							</h:tr>
						</h:table><h:p/>	

						<!-- HIGHT-OFB -->
						<h:br/><h:b>HIGHT-OFB</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">HIGHT-OFB</h:td>
								<h:td valign="top">HIGHT in OFB mode with unique IVs</h:td>
								<h:td valign="top">128 bits</h:td>
								<h:td valign="top">ISO/IEC 18033-3:2010 (Subclause 4.5) [HIGHT]<h:p/>
									[<h:b>selection:</h:b>  ISO/IEC 10116:2017 (Clause 9), 
										NIST SP 800-38A] [OFB]</h:td>
							</h:tr>
						</h:table><h:p/>	

						<!-- HIGHT-CTR -->
						<h:br/><h:b>HIGHT-CTR</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">HIGHT-CTR</h:td>
								<h:td valign="top">HIGHT in CTR mode with unique, incremental counter</h:td>
								<h:td valign="top">128 bits</h:td>
								<h:td valign="top">ISO/IEC 18033-3:2010 (Subclause 4.5) [HIGHT]<h:p/>
									[<h:b>selection:</h:b>  ISO/IEC 10116:2017 (Clause 10), 
										NIST SP 800-38A] [CTR]</h:td>
							</h:tr>
						</h:table><h:p/>	

						<!-- LEA-CBC -->
						<h:br/><h:b>LEA-CBC</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">LEA-CBC</h:td>
								<h:td valign="top">LEA in CBC mode with non-repeating and unpredictable IVs</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> 128, 192, 256] bits</h:td>
								<h:td valign="top">ISO/IEC 29192-2:2019 (Subclause 6.3) [LEA]<h:p/>
									[<h:b>selection:</h:b>  ISO/IEC 10116:2017 (Clause 7), 
										NIST SP 800-38A] [CBC]</h:td>
							</h:tr>
						</h:table><h:p/>	

						<!-- LEA-CFB -->
						<h:br/><h:b>LEA-CFB</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">LEA-CFB</h:td>
								<h:td valign="top">LEA in CFB mode with non-repeating and unpredictable IVs</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> 128, 192, 256] bits</h:td>
								<h:td valign="top">ISO/IEC 29192-2:2019 (Subclause 6.3) [LEA]<h:p/>
									[<h:b>selection:</h:b>  ISO/IEC 10116:2017 (Clause 8), 
										NIST SP 800-38A] [CFB]</h:td>
							</h:tr>
						</h:table><h:p/>	

						<!-- LEA-OFB -->
						<h:br/><h:b>LEA-OFB</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">LEA-OFB</h:td>
								<h:td valign="top">LEA in OFB mode with unique IVs</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> 128, 192, 256] bits</h:td>
								<h:td valign="top">ISO/IEC 29192-2:2019 (Subclause 6.3) [LEA]<h:p/>
									[<h:b>selection:</h:b>  ISO/IEC 10116:2017 (Clause 9), 
										NIST SP 800-38A] [OFB]</h:td>
							</h:tr>
						</h:table><h:p/>	

						<!-- LEA-CTR -->
						<h:br/><h:b>LEA-CTR</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Identifier</h:td>
								<h:td valign="top">Cryptographic Algorithm</h:td>
								<h:td valign="top">Cryptographic Key Sizes</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">LEA-CTR</h:td>
								<h:td valign="top">LEA in CTR mode with unique, incremental counter</h:td>
								<h:td valign="top">[<h:b>selection:</h:b> 128, 192, 256] bits</h:td>
								<h:td valign="top">ISO/IEC 29192-2:2019 (Subclause 6.3) [LEA]<h:p/>
									[<h:b>selection:</h:b>  ISO/IEC 10116:2017 (Clause 10), 
										NIST SP 800-38A] [CTR]</h:td>
							</h:tr>
						</h:table><h:p/>	
					</Tests>
				</aactivity>
			</f-element>
						<audit-event/>
					</f-component>
				</section>   <!-- FCS_COP.1/SKC -->

				<section title="FCS_COP.1/XOF Extendable-Output Function" id="catsec-fcs-cop-1-xof">

					<!-- FCS_COP.1/XOF Cryptographic Operation - Extendable-Output Function  -->
					<f-component id="sfr-fcs-cop-1-xof" cc-id="fcs_cop.1" iteration="XOF" name="Cryptographic Operation - Extendable-Output Function">

						<comp-rel>
							<hierarchical-to/>
							<dependencies-to>
								<or-dep>
									<comp-ref>FDP_ITC.1 Import of user data without security attributes</comp-ref> 
									<comp-ref>FDP_ITC.2 Import of user data with security attributes</comp-ref> 
									<comp-ref>FCS_CKM.1 Cryptographic key generation</comp-ref>
									<comp-ref>FCS_CKM.5 Cryptographic key derivation</comp-ref>
								</or-dep>
							</dependencies-to>
						</comp-rel>
				
			<f-element id="fcs-cop-1e1-xof">
				<title>
					The TSF shall perform [extendable-output function] in accordance with a specified cryptographic algorithm  
					<selectables>
						<tabularize id="fcs-cop-xof-sels" title="Recommended choices for FCS_COP.1/XOF">
							<selectcol>Cryptographic algorithm</selectcol>
							<reqtext>and and parameters</reqtext>
							<selectcol>Parameters</selectcol>
							<reqtext>that meet the following:</reqtext>
							<selectcol>List of standards</selectcol>
							<reqtext><h:p/><h:p/>The following table provides the recommended choices for
								completion of the selection operations of FCS_COP.1/XOF.</reqtext>
						</tabularize>
						
						<!-- cSHAKE -->
						<selectable id="sel-fcs-cop-xof-cshake">
							<col>cSHAKE</col>
							<col>Output length d = <selectables>
								<selectable>128</selectable>
								<selectable>256</selectable>
								</selectables> bits and function <selectables>
								<selectable>SHAKEd</selectable>
								<selectable>KECCAK[<h:i>2d</h:i>]</selectable></selectables>
							</col>
							<col>NIST SP 800-185  Section 3 [cSHAKE], Section 6.2 [SHAKE]<h:p/>
								NIST FIPS PUB 202 Section 5 [KECCAK]
							</col>
						</selectable>

						<!-- KMACXOF -->
						<selectable id="sel-fcs-cop-xof-kmacxof">
							<col>KMACXOF</col>
							<col>Output length d = <selectables>
								<selectable>128</selectable>
								<selectable>256</selectable>
								</selectables> bits
							</col>
							<col>NIST SP 800-185 Section 4.3.1 [KMACXOF]</col>
						</selectable>

						<!-- SHAKE -->
						<selectable id="sel-fcs-cop-xof-shake">
							<col>SHAKE</col>
							<col>Output length d = <selectables>
								<selectable>128</selectable>
								<selectable>256</selectable>
								</selectables> bits
							</col>
							<col>NIST FIPS PUB 202 Section 6.2 [SHAKE]</col>
						</selectable>
					</selectables>
				</title>
				<note role="application">
					The functions in cSHAKE depend on the output length d. i.e. SHAKEd is either SHAKE128 
					for d = 128 or SHAKE256 for d = 256.  Similarly, KECCAK[2d] is either KECCAK[256] for d = 128 
					or KECCAK[512] for d = 256.  Note that KECCAK is a cryptographic primitive which should have 
					no direct interface exposed to the user of the TOE.
				</note>
				<aactivity>
					<TSS>TBD</TSS>
					<Guidance>TBD</Guidance>
					<Tests>
						The following tests are conditional based upon the selections made in the SFR. The evaluator
						shall perform the following test or witness respective tests executed by the developer. The tests
						must be executed on a platform that is as close as practically possible to the operational platform
						(but which may be instrumented in terms of, for example, use of a debug mode). Where the test
						is not carried out on the TOE itself, the test platform shall be identified and the differences
						between test environment and TOE execution environment shall be described.<h:p/>

						<!-- cSHAKE -->
						<h:br/><h:b>cSHAKE</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Cryptographic Algorithm</h:td>
								<h:td valign="top">Parameters</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">cSHAKE</h:td>
								<h:td valign="top">Output length <h:i>d</h:i> = [<h:b>selection:</h:b> 128, 256] bits and
									function [<h:b>selection:</h:b> SHAKE<h:i>d</h:i>, KECCAK[2<h:i>d</h:i>]]</h:td>
								<h:td valign="top">NIST SP 800-185 Section 3 [cSHAKE], Section 6.2 [SHAKE]<h:p/>
									NIST FIPS PUB 202 Section 5 [KECCAK]</h:td>
							</h:tr>
						</h:table><h:p/>	
						
						<!-- SHAKE -->
						<h:br/><h:b>SHAKE</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Cryptographic Algorithm</h:td>
								<h:td valign="top">Parameters</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">SHAKE</h:td>
								<h:td valign="top">Output length <h:i>d</h:i> = [<h:b>selection:</h:b> 128, 256] bits</h:td>
								<h:td valign="top">NIST FIPS PUB 202 Section 6.2 [SHAKE]</h:td>
							</h:tr>
						</h:table><h:p/>	

						<!-- KMACXOF -->
						<h:br/><h:b>KMACXOF</h:b><h:p/>
						<h:table border="1">
							<h:tr class="header" bgcolor="#cccccc">
								<h:td valign="top">Cryptographic Algorithm</h:td>
								<h:td valign="top">Parameters</h:td>
								<h:td valign="top">List of Standards</h:td>
							</h:tr>
							<h:tr>
								<h:td valign="top">KMACXOF</h:td>
								<h:td valign="top">Output length <h:i>d</h:i> = [<h:b>selection:</h:b> 128, 256] bits</h:td>
								<h:td valign="top">NIST SP 800-185 Section 4.3.1 [KMACXOF]</h:td>
							</h:tr>
						</h:table><h:p/>	
						For KMACXOF tests, refer to FCS_COP.1/KeyedHash.
					</Tests>
				</aactivity>
			</f-element>
						<audit-event/>
					</f-component>
				</section>   <!-- FCS_COP.1/XOF -->
				
			</section>   <!-- FCS_COP.1 -->

			<section id="sec-fcs-otv" title="One-Time Value Generation (FCS_OTV)">

				<ext-comp-def fam-id="FCS_OTV_EXT" title="One-Time value generation (extended) (FCS_OTV)">
					<fam-behavior>
						Cryptographic operations often require one-time values such as nonces, IVs, salts,
						and initial counters. These values are often non-secret.
					</fam-behavior>					
				</ext-comp-def>

				<section id="sec-fcs-otv-cg" title="Catalog Guidance Notes for Family FCS_OTV_EXT">
					The lone SFR under FCS_OTV pertains to generation or derivation of one-time use values, such
					as initialization vectors, nonces, tweak values, and salts. 
				</section>
				

					<section title="FCS_OTV_EXT.1 One-Time Value" id="catsec-fcs-otv-ext-1">

						<h:b>Catalog Guidance Notes</h:b>
						TSFs frequently generate cryptographic one-time values, often non-secret, such as nonces, IVs,
						salts, and initial counters (sometimes called initial sequential nonces) using the output of an
						RBG specified in FCS_RBG.1. If the TSF is generating OTVs, then this SFR is used.<h:p/>
						Salts help protect against dictionary and other precomputation attacks. Systems often prepend or
						append salts to passwords and other long-term, potentially guessable values to increase the size
						of a dictionary an attacker must build to attack it. Salts, once associated with a password,
						generally do not change for the life of that password. Salts should also be unique for each
						password and should not be reused. Therefore, systems should randomly generate salts with
						sufficient size such that the combined entropy of both the salt and the password meets the
						minimal key strength sizes of the chosen algorithms.<h:p/>
						Nonces help protect against replay attacks in cryptographic authentication protocols and some
						encryption modes. A nonce should never repeat. Using a sequence of nonces with a counter
						embedded in the value will ensure a nonce will never repeat. In protocol sessions that require
						multiple nonces, using sequential nonces that increment for each message—the receiver can
						check for and accept only an increase in the nonce value to verify that the message has not been
						replayed. In some protocols, the initial sequential nonce needs only to be sent once at the
						beginning of the session and the receiver can predict the remaining nonces in that session, which
						saves transmission bandwidth. Randomly generated nonces protect against attacks against
						sessions in which multiple keys are expected to be used. Therefore, nonces should be both
						randomly generated and never repeat. However, sequential nonces may be predictable. NIST
						provides additional guidance for the composition of a nonce in NIST SP 800-38c, NIST SP 800-
						56A Revision 3, NIST SP 800-56B Revision 2, NIST SP 800-63B, and NIST SP 800-90A
						Revision 1.<h:p/>
						Initialization Vectors (IVs) help protect against attacks which depend on the reuse of static keys.
						Certain encryption modes often require IVs. They should be randomly generated in a
						nonpredictable way, cannot be sequential, and cannot repeat.<h:p/>
						Each algorithm and mode have varying guidance on the lengths of the salts, nonces, and
						initialization vectors used therein. Please consult the referenced standards documents for the
						appropriate guidance for each. 						

						<!-- FCS_OTV_EXT.1 One-Time Value  -->
						<f-component id="sfr-fcs-otv-ext-1" cc-id="fcs_otv_ext.1" name="One-Time Value">

							<ecd-info>
								<comp-lev> requires that values such as salts, nonces, IVs, and initial counters
									be generated using random bit generation. 
								</comp-lev>
								<manageable-actions/>
								<auditable-actions>
									<action-descr>minimal: Success and failure of the activity;</action-descr>
									<action-descr>basic: The object attribute(s), and object value(s) excluding 
										any sensitive information.</action-descr>
								</auditable-actions>
							</ecd-info>

							<comp-rel>
								<hierarchical-to/>
								<dependencies-to>
									<comp-ref>FCS_RBG.1 Random Bit Generators</comp-ref> 
									<or-dep>
										<comp-ref>FCS_COP.1/HMAC Key Hash</comp-ref> 
										<comp-ref>FCS_COP.1/SKC Symmetric key cryptography</comp-ref> 
										<comp-ref>FCS_CKM.5 Cryptographic key derivation</comp-ref>
										<comp-ref>FCS_CKM_EXT.8 Password-Based Key Derivation</comp-ref>
										<comp-ref>FCS_COP.1/CMAC CMAC</comp-ref>
										<comp-ref>FCS_COP.1/KeyWrap Key Wrapping</comp-ref>
										<comp-ref>FCS_COP.1/AEAD Authenticated Encryption with Associated Data</comp-ref>
										<comp-ref>FCS_COP.1/KeyEncap Key Encapsulation</comp-ref>
									</or-dep>
								</dependencies-to>
							</comp-rel>
			
							<f-element id="fcs-otv-ext-1e1">
								<title>
									The TSF shall perform cryptographic one-time value generation for   
									<selectables>
										<tabularize id="fcs-otv-ext-sels" title="Recommended choices and guidance for FCS_OTV_EXT.1">
											<selectcol>Algorithm or mode</selectcol>
											<reqtext>using the output of a 
												<selectables>
													<selectable>random bit generator as defined in FCS_RBG.1</selectable>
													<selectable>deterministic OTV construction</selectable>
													<selectable><assignable>OTV construction method</assignable></selectable>
												</selectables> and sizes of length that meet the following:
											</reqtext>
											<selectcol>List of standards</selectcol>
											<textcol>Notes</textcol>
											<reqtext><h:p/><h:p/>The following table provides the recommended choices for
												completion of the selection operations of FCS_COP.1/XOF.</reqtext>
										</tabularize>
										
										<selectable id="sel-fcs-otv-hmac">
											<col>HMAC</col>
											<col>FIPS PUB 198-1, NIST SP 800-56C Revision  2</col>
											<col>Depending on the use case, salts can be secret or known, randomly generated or all 
												zero. Secret IVs may be required, e.g., for key derivation.  Refer to the relevant
												standards for your use case.</col>
										</selectable>
											
										<selectable id="sel-fcs-otv-kmac">
											<col>KMAC</col>
											<col>NIST SP 800-185<h:br/>
												 NIST SP 800-56C Revision  2
											</col>
											<col>Depending on the use case, salts can be secret or known, randomly generated or all zero.
												Secret IVs may be required, e.g., for key derivation.  Refer to the relevant
												standards for your use case.</col>
										</selectable>
					
										<selectable id="sel-fcs-otv-kdf">
											<col>KDF</col>
											<col>NIST SP 800-108 Revision 1<h:br/>
												 NIST SP 800-135 Revision 1<h:br/>
												 ISO/IEC 11770-6:2016 (Subclause 7.3.2)							 
											</col>
											<col>Salts and IVs are generated as directed for HMAC, AES, and CAM cryptographic
												algorithms.  Refer to the relevant standards.</col>
										</selectable>
					
										<selectable id="sel-fcs-otv-pbkdf">
											<col>PBKDF</col>
											<col>NIST SP 800-132</col>
											<col>Salts are generated and used as directed in PBKDFs.</col>
										</selectable>

										<selectable id="sel-fcs-otv-ctr">
											<col>CTR</col>
											<col>NIST SP 800-38A</col>
											<col>"Initial Counter" (nonce) shall be non-repeating. No counter value shall be 
												repeated across multiple messages with the same secret key.</col>
										</selectable>

										<selectable id="sel-fcs-otv-cbc">
											<col>CBC</col>
											<col>NIST SP 800-38A Appendix C</col>
											<col>Depending on the use case, IVs shall be unpredictable. Repeating IVs leak 
												information about whether the first one or more blocks are shared between two
												messages, so IVs should be non-repeating in such situations. Refer to the relevant 
												standards for your use case.</col>
										</selectable>

										<selectable id="sel-fcs-otv-ofb">
											<col>OFB</col>
											<col>NIST SP 800-38A</col>
											<col>IVs shall be non-repeating and shall not be generated by invoking the cipher 
												on another IV.  OFB may require the IV to be a nonce.</col>
										</selectable>

										<selectable id="sel-fcs-otv-cfb">
											<col>CFB</col>
											<col>NIST SP 800-38A</col>
											<col>IVs should be non-repeating as repeating IVs leak information about the first
												plaintext block and about common shared prefixes in messages</col>
										</selectable>

										<selectable id="sel-fcs-otv-xts">
											<col>XTS</col>
											<col>NIST SP 800-38E<h:br/>
												IEEE Std 1619-2018</col>
											<col>Tweak values shall be non-negative integers, assigned consecutively, and starting
												at an arbitrary non-negative integer (i.e., sequential nonces).</col>
										</selectable>

										<selectable id="sel-fcs-otv-cmac">
											<col>CMAC</col>
											<col>NIST SP 800-38B</col>
											<col>IV is all zeroes</col>
										</selectable>

										<selectable id="sel-fcs-otv-kw">
											<col>KW, KWP</col>
											<col>NIST SP 800-38F</col>
											<col>Depending on the use case, nonces may be required.  Please reference the relevant 
												standards for your use case.</col>
										</selectable>

										<selectable id="sel-fcs-otv-ccm">
											<col>CCM</col>
											<col>NIST SP 800-38C</col>
											<col>Nonces shall be non-repeating.</col>
										</selectable>
					
										<selectable id="sel-fcs-otv-gcm">
											<col>GCM</col>
											<col>NIST SP 800-38D</col>
											<col>For RBG-based IV construction (section 8.2.2) the number of invocations of GCM 
												shall not exceed 2^32 for a given secret key. </col>
										</selectable>
										
										<selectable id="sel-fcs-otv-oaep">
											<col>RSA-OAEP</col>
											<col>NIST SP 800-56B Revision 2</col>
											<col>Mask for padding shall be randomly generated</col>
										</selectable>
									</selectables>
								</title>
								<note role="application">
									See the algorithm- or mode-specific Notes above for guidance on completing the second selection.
								</note>
								<aactivity>
									<no-tests>TBD</no-tests>
								</aactivity>
							</f-element>
							<audit-event/>
						</f-component>
					</section>   <!-- FCS_OTV_EXT.1 -->
				</section>  <!-- FCS_OTV -->						


			<section id="sec-fcs-rbg" title="Random Bit Generation (FCS_RBG)">

				<section title="Catalog Guidance Notes for Family FCS_RBG" id="sec-fcs-rbg-cg">
					The SFRs in FCS_RBG apply only to deterministic random bit generators and not to nondeterministic RBGs. Health tests for the RBG are specified in FPT_TST.1. In the context of
					these FCS_RBG SFRs, the term noise source refers to both raw noise sources as well as
					conditioned entropy sources, both of which must meet min-entropy requirements for initializing
					DRBGs.<h:p/>
					In the context of these FCS_RBG SFRs, the term seed is used to mean the collection of all
					parameters used to initialize the DRBG. The term seeding has multiple meanings depending on
					the context. For external seeding and internal seeding, we mean external entropy source and
					internal entropy source. Otherwise, the term seeding means the process of initialization, which
					is distinct from reseeding.<h:p/>
					The following components are based on the FCS_RBG family of the CC:2022 Revision 1 Part 2
					with proposed corrections and interpretations from the errata CCMB-2024-07-002 Version 1.1. 
				</section>

				<section id="sec-fcs-rbg-1" title="FCS_RBG.1 Random Bit Generation (RBG)">

					<!-- FCS_RBG.1 Random Bit Generation -->
					<f-component cc-id="fcs_rbg.1" name="Random Bit Generation (RBG)">

						<comp-rel>
							<hierarchical-to/>
							<dependencies-to>
								<or-dep>
									<comp-ref>FCS_RBG.2 Random Bit Generation (External Seeding)</comp-ref> 
									<comp-ref>FCS_RBG.3 Random Bit Generation (Internal Seeding Single Source)</comp-ref> 
								</or-dep>
								<comp-ref>FCS_COP.1/Hash Hashing</comp-ref> 
								<comp-ref>FCS_COP.1/SKC Symmetric Key Cryptography</comp-ref> 
								<comp-ref>FPT_FLS.1 Failure with preservation of secure state</comp-ref> 
								<comp-ref>FPT_TST.1 TSF testing</comp-ref> 
							</dependencies-to>
						</comp-rel>

						<f-element id="fcs-rbg-1e1">
							<title>
								TSF shall perform deterministic random bit generation services using   
								<selectables>
									<tabularize id="fcs-rbg-1-sels" title="Recommended choices for FCS_RBG.1.1">
										<textcol>Identifier</textcol>
										<reqtext></reqtext>
										<selectcol>DRBG Algorithm</selectcol>
										<reqtext> in accordance with </reqtext>
										<selectcol>List of standards</selectcol>
										<reqtext>after initialization.<h:p/><h:p/>The following table provides the recommended choices for
											completion of the selection operations of FCS_RBG.1.</reqtext>
									</tabularize>
									
									<selectable id="sel-fcs-rbg-hash-drbg">
										<col>HASH_DRBG</col>
										<col>Hash_DRBG with <selectables>
											<selectable>SHA-256</selectable>
											<selectable>SHA-384</selectable>
											<selectable>SHA-512</selectable>
											<selectable>SHA3-256</selectable>
											<selectable>SHA3-384</selectable>
											<selectable>SHA3-512</selectable>
										</selectables></col>
										<col><selectables>
											<selectable>ISO/IEC 18031: 2011 (Section C.2.2)</selectable>
											<selectable>NIST SP 800-90A Revision 1 Section 10.1.1</selectable></selectables>
										</col>
									</selectable>
				
									<selectable id="sel-fcs-rbg-hmac-drbg">
										<col>HMAC_DRBG</col>
										<col>HMAC_DRBG with  <selectables>
											<selectable>SHA-256</selectable>
											<selectable>SHA-384</selectable>
											<selectable>SHA-512</selectable>
											<selectable>SHA3-256</selectable>
											<selectable>SHA3-384</selectable>
											<selectable>SHA3-512</selectable>
										</selectables></col>
										<col><selectables>
											<selectable>ISO/IEC 18031: 2011 (Section C.2.3)</selectable>
											<selectable>NIST SP 800-90A Revision 1 Section 10.1.2</selectable></selectables>
										</col>
									</selectable>
										<selectable id="sel-fcs-rbg-ctr-drbg">
										<col>CTR_DRBG</col>
										<col>CTR_DRBG  with  <selectables>
											<selectable>AES-128</selectable>
											<selectable>AES-192</selectable>
											<selectable>AES-256</selectable>
											<selectable>CAM-128</selectable>
											<selectable>CAM-192</selectable>
											<selectable>CAM-256</selectable>
											<selectable>SEED-128</selectable>
											<selectable>HIGHT-128</selectable>
											<selectable>LEA-128</selectable>
											<selectable>LEA-192</selectable>
											<selectable>LEA-256</selectable>
										</selectables></col>
										<col><selectables>
											<selectable>ISO/IEC 18031: 2011 (Section C.3.2)</selectable>
											<selectable>NIST SP800-90A Revision 1 Section 10.2.1</selectable></selectables>
										</col>
									</selectable>
								</selectables>
							</title>
							<aactivity level="element">
								<no-tests>TBD</no-tests>
							</aactivity>
						</f-element>
						<f-element id="fcs-rbg-1e2">
							<title>
								The TSF shall use a <selectables>
									<selectable id="internal-seed">TSF noise source <assignable>name of noise source</assignable></selectable>
									<selectable id="external-seed">TSF interface for seeding</selectable>
								</selectables>
								for initialization and reseeding.
							</title>
							<aactivity level="element">
								<no-tests>
									Documentation will be produced - and the evaluator shall perform the
									activities - in accordance with the entropy appendix and
									the Clarification to the Entropy Documentation and Assessment Annex.
								</no-tests>
							</aactivity>
						</f-element>
						
						<f-element id="fcs-rbg-1e3">
							<title>
								The TSF shall update the DRBG state by <selectables>
									<selectable>reseeding</selectable>
									<selectable>uninstantiating and re-instantiating</selectable>
								</selectables> using a <selectables>
									<selectable>TSF entropy source <assignable>name of entropy source</assignable></selectable>
									<selectable>TSF interface for obtaining entropy <assignable>name of the interface</assignable></selectable></selectables>
								in the following situations: <selectables linebreak="yes">
									<selectable>never</selectable>
									<selectable>on demand</selectable>
									<selectable>on the condition: <assignable>condition</assignable></selectable>
									<selectable>after <assignable>time</assignable></selectable>
								</selectables>
								in accordance with <assignable>list of standards</assignable>.
							</title>
							<note role="application">
								No rationale is acceptable for not satisfying one of these dependencies.<h:p/>
								If a reseeding is selected in the first selection and something other than “never” is 
								selected in the third selection of FCS_RBG.1.3, but reseeding is not feasible, the TSF will
								uninstantiate RBGs, rather than produce output that is of insufficient quality.  The listed 
								standards should specify the reseed interval and procedure for uninstantiating and reseeding. 
								The remaining selection allows the PP Author to require application-specific conditions for 
								reseeding.<h:p/>
								"Uninstantiate” means that the internal state of the DRBG is no longer available for use. 
								In the second selection of FCS_RBG.1.3, “on demand” means that a TOE presents an interface to 
								reseed as a TSFI (e.g., an API call).  The interface causes the DRBG to reseed at the request 
								of an authorized user, either with an internal source, an external source, or from input 
								provided through the TSFI (e.g., the API call).
							</note>
							<aactivity level="element">              
								<no-tests>TBD</no-tests>
							</aactivity>
						</f-element>
						<audit-event>
							<audit-event-descr>Failure of the randomization process</audit-event-descr>
							<audit-event-info>None.</audit-event-info>
						</audit-event>
					</f-component>    
				</section>   <!-- FCS_RBG.1 -->

				<section id="sec-fcs-rbg-2" title="FCS_RBG.2 Random Bit Generation (External Seeding)">
						<!-- FCS_RBG.2 Random Bit Generation (External Seeding) -->
					<f-component cc-id="fcs_rbg.2" name="Random Bit Generation (External Seeding)">
							<comp-rel>
							<hierarchical-to/>
							<dependencies-to>
								<comp-ref>FCS_RBG.1 Random Bit Generation (RBG)</comp-ref> 
							</dependencies-to>
						</comp-rel>
		
						<f-element id="fcs-rbg-2e1">
							<title>
								The TSF shall be able to accept a minimum input of <assignable>minimum input length greater than zero</assignable>
								from a TSF interface for the purpose of obtaining entropy.
							</title>
							<note role="application">
								In order to maintain compliance with NIST SP 800-90A Revision 1, the TSF accepts enough 
								bits of input from an external noise source to satisfy the entropy requirements of the DRBG.
								The TSF should also protect the integrity and confidentiality of the entropy it receives from
								the external noise source.<h:p/>
								The TSF interface for the purpose of seeding here is the interface used to gather entropy 
								for initializing the seed.
							</note>
							<aactivity>
								<no-tests>
									TBD
								</no-tests>
							</aactivity>
						</f-element>
						<audit-event/>
					</f-component>
				</section>   <!-- FCS_RBG.2 -->
				
				<section id="sec-fcs-rbg-3" title="FCS_RBG.3 Random Bit Generation (Internal Seeding - Single Source)">
						<!-- FCS_RBG.3 Random Bit Generation (Internal Seeding - Single Source) -->
					<f-component cc-id="fcs_rbg.3" name="Random Bit Generation (Internal Seeding - Single Source)">
							<comp-rel>
							<hierarchical-to/>
							<dependencies-to>
								<comp-ref>FCS_RBG.1 Random Bit Generation (RBG)</comp-ref> 
								<comp-ref>FCS_RBG.5 Random Bit Generation (Combining Entropy Sources)</comp-ref> 
							</dependencies-to>
						</comp-rel>
						
						<f-element id="fcs-rbg-3e1">
							<title>
								The TSF shall be able to seed the DRBG using a <selectables choose-one-of="yes">
									<selectable>TSF software-based entropy source</selectable>
									<selectable>TSF hardware-based entropy source <assignable>name of entropy source</assignable></selectable></selectables>
								with <assignable>number of bits</assignable> bits of min-entropy.
							</title>        
							<note role="application">
								If an ST Author wishes to use multiple internal noise sources, they iterate this requirement
								for each noise source used by the TSF.<h:p/>
								Hardware-based noise sources are entropy sources whose primary function is noise generation, 
								such as ring oscillators, diodes, and thermal noise.  While a TOE may use software to collect
								the noise from these hardware sources, these are not software-based.  Software-based noise 
								sources are those sources that have some other primary function, and the noise is a byproduct 
								of their normal operation.  Examples of software-based noise sources are user or system-based 
								events, reading the least significant bits from an event timer, etc. <h:p/>
								Hardware-based noise sources may be stochastically modelled, in which case the amount of 
								entropy is well understood.  Software-based noise sources are usually less well understood 
								and therefore will typically take a more conservative approach, gathering larger numbers of 
								bits than required, then performing a compression function to derive the final output. 
								Software-based noise sources often rely on an entropy estimator. 
							</note>
							<aactivity>
								<no-tests>TBD
								</no-tests>
							</aactivity>
						</f-element>
						<audit-event/>
					</f-component>
				</section>   <!-- FCS_RBG.3 -->
				
				<section id="sec-fcs-rbg-4" title="FCS_RBG.4 Random Bit Generation (Internal Seeding - Multiple Sources)">

					<!-- FCS_RBG.4 Random Bit Generation (Internal Seeding - Multiple Sources) -->
					<f-component cc-id="fcs_rbg.4" name="Random Bit Generation (Internal Seeding - Multiple Sources)">
							<comp-rel>
							<hierarchical-to/>
							<dependencies-to>
								<comp-ref>FCS_RBG.1 Random Bit Generation (RBG)</comp-ref> 
								<comp-ref>FCS_RBG.5 Random Bit Generation (Combining Entropy Sources)</comp-ref> 
							</dependencies-to>
						</comp-rel>
				
						<f-element id="fcs-rbg-4e1">
							<title>
								The TSF shall be able to seed the DRBG using <selectables>
									<selectable><assignable>number</assignable> TSF software-based entropy source(s)</selectable>
									<selectable><assignable>number</assignable> TSF hardware-based entropy source(s)</selectable>
								</selectables>.
							</title>
							<aactivity>
								<no-tests>TBD
								</no-tests>
							</aactivity>
						</f-element>
						<audit-event/>
					</f-component>
				</section>   <!-- FCS_RBG.4 -->
				
				<section id="sec-fcs-rbg-5" title="FCS_RBG.5 Random Bit Generation (Combining Entropy Sources)">

					<!-- FCS_RBG.5 Random Bit Generation (Combining Noise Sources) -->
					<f-component cc-id="fcs_rbg.5" name="Random Bit Generation (Combining Entropy Sources)">
							<comp-rel>
							<hierarchical-to/>
							<dependencies-to>
								<comp-ref>FCS_RBG.1 Random Bit Generation (RBG)</comp-ref> 
								<or-dep>
									<comp-ref>FCS_RBG.2 Random Bit Generation (External Seeding)</comp-ref> 
									<comp-ref>FCS_RBG.3 Random Bit Generation (Internal Seeding - Single Source)</comp-ref> 
									<comp-ref> FCS_RBG.4 Random Bit Generation (Internal Seeding - Multiple Sources)</comp-ref> 									
								</or-dep>
							</dependencies-to>
						</comp-rel>
							<f-element id="fcs-rbg-5e1">
							<title>
								The TSF shall <selectables>
									<selectable>hash</selectable>
									<selectable>concatenate and hash</selectable>
									<selectable>XOR</selectable>
									<selectable>input into a linear feedback shift register</selectable>
									<selectable><assignable>combining operation</assignable></selectable> </selectables>
									<selectables>
									<selectable>output from TSF entropy source(s)</selectable>
									<selectable>input from TSF interface(s) for obtaining entropy</selectable></selectables>
								resulting in a minimum of <assignable>number of bits</assignable>
								bits of min-entropy to create the entropy input into the derivation function as defined in
								<selectables>
									<selectable>ISO/IEC 18031:2011</selectable>
									<selectable>NIST SP 800-90A Revision 1</selectable>
								</selectables>						
							</title>        
							<note role="application">
								One can apply NIST SP 800-90B (or AIS-31) statistical tests against internal noise sources 
								(a.k.a. raw entropy) to confirm the min-entropy of the noise sources either in aggregate or 
								individually.  One should not apply NIST SP 800-90B (or AIS-31) statistical tests against 
								external noise sources since the TOE is unable to enforce entropy requirements or conditioning 
								requirements against external sources of entropy.  However, the TSS may include estimates 
								for min-entropy from external sources that contribute to the overall entropy requirements 
								for either the DRBG or for FCS_OTV_EXT.1.<h:p/>
								FCS_RBG.5 specifies the combining operation such that the combined min-entropy of all the 
								internal sources and the estimated entropy of the external sources is greater than or equal 
								to the desired entropy of the output of the combining operation.  The output could be used as 
								a nonce or a seed for a DRBG.  The combining operation should avoid crushing the entropy of
								the sources such that the desired entropy of the output cannot be met.<h:p/>
								The TSF interface(s) for seeding here is the interface used to gather entropy for
								initializing the seed.
							</note>
							<aactivity>
								<no-tests>TBD
								</no-tests>
							</aactivity>
						</f-element>
						<audit-event/>
					</f-component>  
				</section>    <!-- FCS_RBG.5 -->
	
				<section id="sec-fcs-rbg-6" title="FCS_RBG.6 Random Bit Generation Service">
					<!-- FCS_RBG.6 Random Bit Generation Service -->
					<f-component cc-id="fcs_rbg.6" name="Random Bit Generation (Combining Entropy Sources)">
						<comp-rel>
						<hierarchical-to/>
						<dependencies-to>
								<comp-ref>FCS_RBG.1 Random Bit Generation (RBG)</comp-ref> 
							</dependencies-to>
						</comp-rel>
							<f-element id="fcs-rbg-6e1">
							<title>
								The TSF shall provide a <selectables>
									<selectable>hardware</selectable>
									<selectable>software</selectable>
									<selectable><assignable>other interface type</assignable></selectable> </selectables>
								interface to make the DRBG output, as specified in FCS_RBG.1 Random Bit Generation (RBG), 
								available as a service to entities outside of the TOE.
							</title>        
							<aactivity>
								<no-tests>TBD
								</no-tests>
							</aactivity>
						</f-element>
						<audit-event/>
					</f-component>  
				</section>   <!-- FCS_RBG.6 -->
			</section>   <!-- FCS_RBG -->
		</section>  <!-- FCS -->
	</section>  <!-- SFRs -->
	
</SFRCatalog>
